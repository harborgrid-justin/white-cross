/**
 * LOC: MALK1234567
 * File: /reuse/threat/malware-analysis-kit.ts
 *
 * UPSTREAM (imports from):
 *   - None (leaf node - reusable utilities)
 *
 * DOWNSTREAM (imported by):
 *   - Threat intelligence services
 *   - Malware analysis controllers
 *   - Security monitoring systems
 */
interface MalwareHash {
    md5: string;
    sha1: string;
    sha256: string;
    sha512?: string;
    ssdeep?: string;
}
interface FileSignature {
    magicNumber: string;
    fileType: string;
    mimeType: string;
    extension: string;
    confidence: number;
}
interface YaraRule {
    ruleName: string;
    namespace?: string;
    tags: string[];
    meta: Record<string, string>;
    strings: YaraString[];
    condition: string;
}
interface YaraString {
    identifier: string;
    type: 'text' | 'hex' | 'regex';
    value: string;
    modifiers?: string[];
}
interface YaraMatch {
    ruleName: string;
    namespace?: string;
    tags: string[];
    matchedStrings: MatchedString[];
    metadata: Record<string, string>;
    severity: 'low' | 'medium' | 'high' | 'critical';
}
interface MatchedString {
    identifier: string;
    offset: number;
    data: string;
}
interface MalwareFamily {
    familyName: string;
    aliases: string[];
    type: MalwareType;
    firstSeen: Date;
    lastSeen: Date;
    prevalence: number;
    dangerLevel: 'low' | 'medium' | 'high' | 'critical';
}
type MalwareType = 'trojan' | 'ransomware' | 'worm' | 'virus' | 'rootkit' | 'spyware' | 'adware' | 'backdoor' | 'botnet' | 'keylogger' | 'cryptominer' | 'downloader' | 'dropper' | 'apt' | 'unknown';
interface StaticAnalysisResult {
    hashes: MalwareHash;
    fileSignature: FileSignature;
    fileSize: number;
    entropy: number;
    packers: string[];
    imports: string[];
    exports: string[];
    sections: FileSection[];
    strings: ExtractedString[];
    isSuspicious: boolean;
    suspicionReasons: string[];
}
interface DynamicAnalysisResult {
    processCreated: ProcessInfo[];
    filesModified: string[];
    filesDeleted: string[];
    registryModified: RegistryChange[];
    networkConnections: NetworkConnection[];
    mutexes: string[];
    dllsLoaded: string[];
    behaviors: BehaviorIndicator[];
    isMalicious: boolean;
    maliciousScore: number;
}
interface ProcessInfo {
    pid: number;
    name: string;
    commandLine: string;
    parentPid?: number;
    username?: string;
    startTime: Date;
}
interface RegistryChange {
    action: 'create' | 'modify' | 'delete';
    keyPath: string;
    valueName?: string;
    valueData?: string;
    timestamp: Date;
}
interface NetworkConnection {
    protocol: 'tcp' | 'udp' | 'icmp' | 'http' | 'https' | 'dns';
    sourceIp: string;
    sourcePort: number;
    destinationIp: string;
    destinationPort: number;
    domain?: string;
    bytesTransferred: number;
    timestamp: Date;
}
interface BehaviorIndicator {
    category: 'persistence' | 'defense_evasion' | 'credential_access' | 'discovery' | 'lateral_movement' | 'collection' | 'exfiltration' | 'command_control' | 'impact';
    technique: string;
    mitreAttackId?: string;
    description: string;
    severity: 'low' | 'medium' | 'high' | 'critical';
    confidence: number;
}
interface SandboxConfig {
    timeout: number;
    vmType: 'windows' | 'linux' | 'macos';
    vmVersion: string;
    enableNetwork: boolean;
    enableInternet: boolean;
    captureTraffic: boolean;
    captureScreenshots: boolean;
    memoryDumpOnExit: boolean;
}
interface SandboxResult {
    analysisId: string;
    startTime: Date;
    endTime: Date;
    status: 'completed' | 'timeout' | 'error' | 'crashed';
    staticAnalysis: StaticAnalysisResult;
    dynamicAnalysis: DynamicAnalysisResult;
    screenshots: string[];
    memoryDump?: string;
    verdict: 'benign' | 'suspicious' | 'malicious';
    score: number;
}
interface PEFileHeader {
    machineType: string;
    numberOfSections: number;
    timeDateStamp: Date;
    characteristics: string[];
    optionalHeaderMagic: string;
    entryPoint: number;
    imageBase: number;
    subsystem: string;
}
interface ELFFileHeader {
    class: 'ELF32' | 'ELF64';
    data: 'little-endian' | 'big-endian';
    version: number;
    osAbi: string;
    type: 'executable' | 'shared_object' | 'core';
    machine: string;
    entryPoint: number;
}
interface MachOFileHeader {
    magic: string;
    cpuType: string;
    cpuSubtype: string;
    fileType: 'executable' | 'dylib' | 'bundle';
    numberOfCommands: number;
    flags: string[];
}
interface FileSection {
    name: string;
    virtualAddress: number;
    virtualSize: number;
    rawSize: number;
    entropy: number;
    characteristics?: string[];
    permissions?: string;
}
interface ExtractedString {
    value: string;
    offset: number;
    type: 'ascii' | 'unicode' | 'url' | 'ip' | 'email' | 'filepath' | 'registry';
    encoding: string;
}
interface MalwareSample {
    id: string;
    md5: string;
    sha1: string;
    sha256: string;
    fileSize: number;
    fileType: string;
    firstSeen: Date;
    lastSeen: Date;
    submissionCount: number;
    detectionRate: number;
    malwareFamily?: string;
    malwareType?: MalwareType;
    tags: string[];
    yaraMatches: string[];
    isMalicious: boolean;
    analysisStatus: 'pending' | 'analyzing' | 'completed' | 'failed';
}
/**
 * Computes MD5 hash of file buffer.
 *
 * @param {Buffer} fileBuffer - File buffer to hash
 * @returns {string} MD5 hash (lowercase hex)
 *
 * @example
 * ```typescript
 * const buffer = fs.readFileSync('suspicious.exe');
 * const md5 = computeMD5Hash(buffer);
 * // Result: 'a1b2c3d4e5f6...'
 * ```
 */
export declare const computeMD5Hash: (fileBuffer: Buffer) => string;
/**
 * Computes SHA1 hash of file buffer.
 *
 * @param {Buffer} fileBuffer - File buffer to hash
 * @returns {string} SHA1 hash (lowercase hex)
 *
 * @example
 * ```typescript
 * const buffer = fs.readFileSync('malware.dll');
 * const sha1 = computeSHA1Hash(buffer);
 * // Result: '9f3c8e1b7a4d...'
 * ```
 */
export declare const computeSHA1Hash: (fileBuffer: Buffer) => string;
/**
 * Computes SHA256 hash of file buffer.
 *
 * @param {Buffer} fileBuffer - File buffer to hash
 * @returns {string} SHA256 hash (lowercase hex)
 *
 * @example
 * ```typescript
 * const buffer = fs.readFileSync('trojan.exe');
 * const sha256 = computeSHA256Hash(buffer);
 * // Result: '7f8e9d0a1b2c...'
 * ```
 */
export declare const computeSHA256Hash: (fileBuffer: Buffer) => string;
/**
 * Computes all standard hashes (MD5, SHA1, SHA256, SHA512) for a file.
 *
 * @param {Buffer} fileBuffer - File buffer to hash
 * @returns {MalwareHash} Object containing all hash values
 *
 * @example
 * ```typescript
 * const buffer = fs.readFileSync('sample.bin');
 * const hashes = computeAllHashes(buffer);
 * // Result: { md5: '...', sha1: '...', sha256: '...', sha512: '...' }
 * ```
 */
export declare const computeAllHashes: (fileBuffer: Buffer) => MalwareHash;
/**
 * Validates hash format (supports MD5, SHA1, SHA256).
 *
 * @param {string} hash - Hash string to validate
 * @param {'md5' | 'sha1' | 'sha256' | 'sha512'} type - Expected hash type
 * @returns {boolean} True if hash format is valid
 *
 * @example
 * ```typescript
 * const isValid = validateHashFormat('a1b2c3d4...', 'md5');
 * // Result: true or false
 * ```
 */
export declare const validateHashFormat: (hash: string, type: "md5" | "sha1" | "sha256" | "sha512") => boolean;
/**
 * Normalizes hash string to lowercase and removes whitespace.
 *
 * @param {string} hash - Hash string to normalize
 * @returns {string} Normalized hash
 *
 * @example
 * ```typescript
 * const normalized = normalizeHash('  A1B2C3D4  ');
 * // Result: 'a1b2c3d4'
 * ```
 */
export declare const normalizeHash: (hash: string) => string;
/**
 * Detects file type from magic number (file signature).
 *
 * @param {Buffer} fileBuffer - File buffer (at least first 512 bytes)
 * @returns {FileSignature | null} File signature information or null
 *
 * @example
 * ```typescript
 * const buffer = fs.readFileSync('unknown.bin');
 * const signature = detectFileSignature(buffer);
 * // Result: { magicNumber: '4D5A', fileType: 'PE', mimeType: 'application/x-dosexec', ... }
 * ```
 */
export declare const detectFileSignature: (fileBuffer: Buffer) => FileSignature | null;
/**
 * Extracts magic number from file buffer.
 *
 * @param {Buffer} fileBuffer - File buffer
 * @param {number} [length] - Number of bytes to extract (default: 8)
 * @returns {string} Magic number as hex string
 *
 * @example
 * ```typescript
 * const buffer = fs.readFileSync('file.exe');
 * const magic = extractMagicNumber(buffer, 4);
 * // Result: '4D5A9000'
 * ```
 */
export declare const extractMagicNumber: (fileBuffer: Buffer, length?: number) => string;
/**
 * Validates if file matches expected type based on magic number.
 *
 * @param {Buffer} fileBuffer - File buffer
 * @param {string} expectedType - Expected file type (e.g., 'PE', 'ELF')
 * @returns {boolean} True if file type matches
 *
 * @example
 * ```typescript
 * const buffer = fs.readFileSync('file.exe');
 * const isPE = validateFileType(buffer, 'PE');
 * // Result: true
 * ```
 */
export declare const validateFileType: (fileBuffer: Buffer, expectedType: string) => boolean;
/**
 * Creates a YARA rule object from components.
 *
 * @param {string} ruleName - Rule name
 * @param {YaraString[]} strings - Array of YARA strings
 * @param {string} condition - YARA condition
 * @param {Record<string, string>} [meta] - Metadata
 * @param {string[]} [tags] - Tags
 * @returns {YaraRule} YARA rule object
 *
 * @example
 * ```typescript
 * const rule = createYaraRule('MalwareDetection',
 *   [{ identifier: '$malware', type: 'text', value: 'malicious' }],
 *   'any of them',
 *   { author: 'Security Team', description: 'Detects malware' },
 *   ['malware', 'trojan']
 * );
 * ```
 */
export declare const createYaraRule: (ruleName: string, strings: YaraString[], condition: string, meta?: Record<string, string>, tags?: string[]) => YaraRule;
/**
 * Formats YARA rule as string for file export.
 *
 * @param {YaraRule} rule - YARA rule object
 * @returns {string} Formatted YARA rule string
 *
 * @example
 * ```typescript
 * const ruleString = formatYaraRule(rule);
 * // Result: 'rule MalwareDetection : malware trojan { meta: ... strings: ... condition: ... }'
 * ```
 */
export declare const formatYaraRule: (rule: YaraRule) => string;
/**
 * Parses YARA match result with severity assessment.
 *
 * @param {string} ruleName - Matched rule name
 * @param {MatchedString[]} matchedStrings - Matched strings with offsets
 * @param {Record<string, string>} metadata - Rule metadata
 * @returns {YaraMatch} YARA match result
 *
 * @example
 * ```typescript
 * const match = parseYaraMatch('Ransomware',
 *   [{ identifier: '$encrypt', offset: 1024, data: 'AES256' }],
 *   { author: 'Team', severity: 'critical' }
 * );
 * ```
 */
export declare const parseYaraMatch: (ruleName: string, matchedStrings: MatchedString[], metadata: Record<string, string>) => YaraMatch;
/**
 * Validates YARA rule syntax and structure.
 *
 * @param {YaraRule} rule - YARA rule to validate
 * @returns {boolean} True if rule is valid
 *
 * @example
 * ```typescript
 * const isValid = validateYaraRule(rule);
 * // Result: true or false
 * ```
 */
export declare const validateYaraRule: (rule: YaraRule) => boolean;
/**
 * Creates malware family classification record.
 *
 * @param {string} familyName - Malware family name
 * @param {MalwareType} type - Type of malware
 * @param {string[]} [aliases] - Known aliases
 * @returns {Partial<MalwareFamily>} Malware family object
 *
 * @example
 * ```typescript
 * const family = createMalwareFamily('WannaCry', 'ransomware', ['WCry', 'WanaCrypt0r']);
 * ```
 */
export declare const createMalwareFamily: (familyName: string, type: MalwareType, aliases?: string[]) => Partial<MalwareFamily>;
/**
 * Determines malware danger level based on type and characteristics.
 *
 * @param {MalwareType} type - Malware type
 * @param {number} prevalence - Prevalence score (0-100)
 * @returns {'low' | 'medium' | 'high' | 'critical'} Danger level
 *
 * @example
 * ```typescript
 * const danger = determineDangerLevel('ransomware', 85);
 * // Result: 'critical'
 * ```
 */
export declare const determineDangerLevel: (type: MalwareType, prevalence: number) => "low" | "medium" | "high" | "critical";
/**
 * Classifies malware by analyzing behavioral patterns.
 *
 * @param {BehaviorIndicator[]} behaviors - Array of behavior indicators
 * @returns {MalwareType} Classified malware type
 *
 * @example
 * ```typescript
 * const behaviors = [
 *   { category: 'impact', technique: 'Data Encrypted', ... },
 *   { category: 'command_control', technique: 'C2 Communication', ... }
 * ];
 * const type = classifyMalwareByBehavior(behaviors);
 * // Result: 'ransomware'
 * ```
 */
export declare const classifyMalwareByBehavior: (behaviors: BehaviorIndicator[]) => MalwareType;
/**
 * Updates malware family prevalence statistics.
 *
 * @param {MalwareFamily} family - Malware family object
 * @param {number} newSamples - Number of new samples detected
 * @returns {MalwareFamily} Updated malware family
 *
 * @example
 * ```typescript
 * const updated = updateFamilyPrevalence(family, 25);
 * // Increments prevalence and updates lastSeen timestamp
 * ```
 */
export declare const updateFamilyPrevalence: (family: MalwareFamily, newSamples: number) => MalwareFamily;
/**
 * Calculates Shannon entropy of file buffer (0-8, higher = more random/packed).
 *
 * @param {Buffer} buffer - File buffer
 * @returns {number} Entropy value
 *
 * @example
 * ```typescript
 * const buffer = fs.readFileSync('packed.exe');
 * const entropy = calculateFileEntropy(buffer);
 * // Result: 7.85 (likely packed/encrypted)
 * ```
 */
export declare const calculateFileEntropy: (buffer: Buffer) => number;
/**
 * Detects if file is likely packed/compressed based on entropy.
 *
 * @param {number} entropy - File entropy value
 * @param {number} [threshold] - Entropy threshold (default: 7.0)
 * @returns {boolean} True if likely packed
 *
 * @example
 * ```typescript
 * const isPacked = isFilePacked(7.85);
 * // Result: true
 * ```
 */
export declare const isFilePacked: (entropy: number, threshold?: number) => boolean;
/**
 * Extracts strings from binary buffer (ASCII and Unicode).
 *
 * @param {Buffer} buffer - File buffer
 * @param {number} [minLength] - Minimum string length (default: 4)
 * @returns {ExtractedString[]} Array of extracted strings
 *
 * @example
 * ```typescript
 * const buffer = fs.readFileSync('malware.exe');
 * const strings = extractStringsFromBuffer(buffer, 5);
 * // Result: [{ value: 'http://evil.com', offset: 1024, type: 'url', ... }, ...]
 * ```
 */
export declare const extractStringsFromBuffer: (buffer: Buffer, minLength?: number) => ExtractedString[];
/**
 * Detects type of extracted string (URL, IP, email, etc.).
 *
 * @param {string} str - String to analyze
 * @returns {'ascii' | 'unicode' | 'url' | 'ip' | 'email' | 'filepath' | 'registry'} String type
 *
 * @example
 * ```typescript
 * const type = detectStringType('http://malicious.com');
 * // Result: 'url'
 * ```
 */
export declare const detectStringType: (str: string) => "ascii" | "unicode" | "url" | "ip" | "email" | "filepath" | "registry";
/**
 * Identifies common packers from file signatures and sections.
 *
 * @param {Buffer} buffer - File buffer
 * @param {FileSection[]} sections - File sections
 * @returns {string[]} Array of detected packer names
 *
 * @example
 * ```typescript
 * const packers = identifyPackers(buffer, sections);
 * // Result: ['UPX', 'Themida']
 * ```
 */
export declare const identifyPackers: (buffer: Buffer, sections: FileSection[]) => string[];
/**
 * Analyzes process creation patterns for suspicious behavior.
 *
 * @param {ProcessInfo[]} processes - Array of process information
 * @returns {BehaviorIndicator[]} Detected suspicious behaviors
 *
 * @example
 * ```typescript
 * const behaviors = analyzeProcessBehavior(processes);
 * // Result: [{ category: 'defense_evasion', technique: 'Process Injection', ... }]
 * ```
 */
export declare const analyzeProcessBehavior: (processes: ProcessInfo[]) => BehaviorIndicator[];
/**
 * Analyzes network connections for C2 communication patterns.
 *
 * @param {NetworkConnection[]} connections - Array of network connections
 * @returns {BehaviorIndicator[]} Detected C2 behaviors
 *
 * @example
 * ```typescript
 * const c2Behaviors = analyzeNetworkBehavior(connections);
 * // Result: [{ category: 'command_control', technique: 'C2 Communication', ... }]
 * ```
 */
export declare const analyzeNetworkBehavior: (connections: NetworkConnection[]) => BehaviorIndicator[];
/**
 * Analyzes registry modifications for persistence mechanisms.
 *
 * @param {RegistryChange[]} changes - Array of registry changes
 * @returns {BehaviorIndicator[]} Detected persistence behaviors
 *
 * @example
 * ```typescript
 * const persistenceBehaviors = analyzeRegistryBehavior(changes);
 * // Result: [{ category: 'persistence', technique: 'Registry Run Keys', ... }]
 * ```
 */
export declare const analyzeRegistryBehavior: (changes: RegistryChange[]) => BehaviorIndicator[];
/**
 * Calculates overall malicious score from dynamic analysis results.
 *
 * @param {DynamicAnalysisResult} result - Dynamic analysis results
 * @returns {number} Malicious score (0-100)
 *
 * @example
 * ```typescript
 * const score = calculateMaliciousScore(dynamicResult);
 * // Result: 85 (highly malicious)
 * ```
 */
export declare const calculateMaliciousScore: (result: DynamicAnalysisResult) => number;
/**
 * Creates sandbox configuration for malware analysis.
 *
 * @param {Partial<SandboxConfig>} overrides - Configuration overrides
 * @returns {SandboxConfig} Complete sandbox configuration
 *
 * @example
 * ```typescript
 * const config = createSandboxConfig({
 *   timeout: 300000,
 *   vmType: 'windows',
 *   enableNetwork: true
 * });
 * ```
 */
export declare const createSandboxConfig: (overrides?: Partial<SandboxConfig>) => SandboxConfig;
/**
 * Validates sandbox result for completeness and integrity.
 *
 * @param {SandboxResult} result - Sandbox analysis result
 * @returns {boolean} True if result is valid
 *
 * @example
 * ```typescript
 * const isValid = validateSandboxResult(result);
 * // Result: true or false
 * ```
 */
export declare const validateSandboxResult: (result: SandboxResult) => boolean;
/**
 * Generates sandbox verdict from analysis results.
 *
 * @param {StaticAnalysisResult} staticResult - Static analysis results
 * @param {DynamicAnalysisResult} dynamicResult - Dynamic analysis results
 * @returns {{ verdict: 'benign' | 'suspicious' | 'malicious'; score: number }} Verdict and score
 *
 * @example
 * ```typescript
 * const { verdict, score } = generateSandboxVerdict(staticResult, dynamicResult);
 * // Result: { verdict: 'malicious', score: 92 }
 * ```
 */
export declare const generateSandboxVerdict: (staticResult: StaticAnalysisResult, dynamicResult: DynamicAnalysisResult) => {
    verdict: "benign" | "suspicious" | "malicious";
    score: number;
};
/**
 * Parses PE file header from buffer.
 *
 * @param {Buffer} buffer - PE file buffer
 * @returns {PEFileHeader | null} Parsed PE header or null
 * @throws {Error} If buffer is not a valid PE file
 *
 * @example
 * ```typescript
 * const buffer = fs.readFileSync('malware.exe');
 * const peHeader = parsePEHeader(buffer);
 * // Result: { machineType: 'x86', numberOfSections: 5, ... }
 * ```
 */
export declare const parsePEHeader: (buffer: Buffer) => PEFileHeader | null;
/**
 * Extracts sections from PE file.
 *
 * @param {Buffer} buffer - PE file buffer
 * @returns {FileSection[]} Array of file sections
 *
 * @example
 * ```typescript
 * const sections = extractPESections(buffer);
 * // Result: [{ name: '.text', virtualAddress: 0x1000, ... }, ...]
 * ```
 */
export declare const extractPESections: (buffer: Buffer) => FileSection[];
/**
 * Parses ELF file header from buffer.
 *
 * @param {Buffer} buffer - ELF file buffer
 * @returns {ELFFileHeader | null} Parsed ELF header or null
 * @throws {Error} If buffer is not a valid ELF file
 *
 * @example
 * ```typescript
 * const buffer = fs.readFileSync('malware.elf');
 * const elfHeader = parseELFHeader(buffer);
 * // Result: { class: 'ELF64', data: 'little-endian', ... }
 * ```
 */
export declare const parseELFHeader: (buffer: Buffer) => ELFFileHeader | null;
/**
 * Parses Mach-O file header from buffer.
 *
 * @param {Buffer} buffer - Mach-O file buffer
 * @returns {MachOFileHeader | null} Parsed Mach-O header or null
 * @throws {Error} If buffer is not a valid Mach-O file
 *
 * @example
 * ```typescript
 * const buffer = fs.readFileSync('malware.macho');
 * const machoHeader = parseMachOHeader(buffer);
 * // Result: { magic: 'MH_MAGIC_64', cpuType: 'x86_64', ... }
 * ```
 */
export declare const parseMachOHeader: (buffer: Buffer) => MachOFileHeader | null;
/**
 * Creates Sequelize model definition for malware samples.
 *
 * @returns {Record<string, any>} Sequelize model attributes
 *
 * @example
 * ```typescript
 * const MalwareSampleModel = sequelize.define('MalwareSample', createMalwareSampleModel());
 * ```
 */
export declare const createMalwareSampleModel: () => Record<string, any>;
/**
 * Creates Sequelize query for finding malware by hash.
 *
 * @param {string} hash - Hash value (MD5, SHA1, or SHA256)
 * @returns {Record<string, any>} Sequelize where clause
 *
 * @example
 * ```typescript
 * const where = createMalwareHashQuery('abc123...');
 * const malware = await MalwareSample.findOne({ where });
 * ```
 */
export declare const createMalwareHashQuery: (hash: string) => Record<string, any>;
/**
 * Creates Sequelize query for malware family search.
 *
 * @param {string} familyName - Malware family name
 * @param {Date} [startDate] - Start date filter
 * @param {Date} [endDate] - End date filter
 * @returns {Record<string, any>} Sequelize where clause
 *
 * @example
 * ```typescript
 * const where = createMalwareFamilyQuery('Emotet', new Date('2025-01-01'));
 * const samples = await MalwareSample.findAll({ where });
 * ```
 */
export declare const createMalwareFamilyQuery: (familyName: string, startDate?: Date, endDate?: Date) => Record<string, any>;
/**
 * Creates NestJS service method for malware analysis.
 *
 * @param {Buffer} fileBuffer - File buffer to analyze
 * @returns {Promise<StaticAnalysisResult>} Static analysis result
 *
 * @example
 * ```typescript
 * // In NestJS service:
 * async analyzeFile(fileBuffer: Buffer): Promise<StaticAnalysisResult> {
 *   return await performStaticAnalysis(fileBuffer);
 * }
 * ```
 */
export declare const performStaticAnalysis: (fileBuffer: Buffer) => Promise<Partial<StaticAnalysisResult>>;
/**
 * Creates NestJS service method for sandbox submission.
 *
 * @param {string} sha256 - Malware SHA256 hash
 * @param {SandboxConfig} config - Sandbox configuration
 * @returns {Promise<string>} Sandbox analysis ID
 *
 * @example
 * ```typescript
 * // In NestJS service:
 * async submitToSandbox(sha256: string, config: SandboxConfig): Promise<string> {
 *   return await submitMalwareToSandbox(sha256, config);
 * }
 * ```
 */
export declare const submitMalwareToSandbox: (sha256: string, config: SandboxConfig) => Promise<string>;
/**
 * Creates NestJS service method for retrieving malware by hash.
 *
 * @param {string} hash - Malware hash
 * @returns {Promise<MalwareSample | null>} Malware sample or null
 *
 * @example
 * ```typescript
 * // In NestJS service:
 * async getMalwareByHash(hash: string): Promise<MalwareSample | null> {
 *   return await retrieveMalwareByHash(hash);
 * }
 * ```
 */
export declare const retrieveMalwareByHash: (hash: string) => Promise<Partial<MalwareSample> | null>;
/**
 * Creates Swagger API documentation for malware upload endpoint.
 *
 * @returns {Record<string, any>} Swagger API specification
 *
 * @example
 * ```typescript
 * @ApiOperation(createMalwareUploadApiDoc())
 * @Post('/malware/upload')
 * async uploadMalware(@UploadedFile() file: Express.Multer.File) { ... }
 * ```
 */
export declare const createMalwareUploadApiDoc: () => Record<string, any>;
/**
 * Creates Swagger API documentation for malware analysis endpoint.
 *
 * @returns {Record<string, any>} Swagger API specification
 *
 * @example
 * ```typescript
 * @ApiOperation(createMalwareAnalysisApiDoc())
 * @Get('/malware/:hash/analysis')
 * async getMalwareAnalysis(@Param('hash') hash: string) { ... }
 * ```
 */
export declare const createMalwareAnalysisApiDoc: () => Record<string, any>;
/**
 * Creates Swagger schema for malware sample response.
 *
 * @returns {Record<string, any>} Swagger schema definition
 *
 * @example
 * ```typescript
 * @ApiResponse({ schema: createMalwareSampleSchema() })
 * ```
 */
export declare const createMalwareSampleSchema: () => Record<string, any>;
/**
 * Creates Swagger schema for YARA rule response.
 *
 * @returns {Record<string, any>} Swagger schema definition
 *
 * @example
 * ```typescript
 * @ApiResponse({ schema: createYaraRuleSchema() })
 * ```
 */
export declare const createYaraRuleSchema: () => Record<string, any>;
/**
 * Validates malware upload file constraints.
 *
 * @param {Express.Multer.File} file - Uploaded file
 * @param {number} [maxSizeBytes] - Maximum file size (default: 100MB)
 * @returns {{ isValid: boolean; error?: string }} Validation result
 *
 * @example
 * ```typescript
 * const validation = validateMalwareUpload(file, 104857600);
 * if (!validation.isValid) throw new Error(validation.error);
 * ```
 */
export declare const validateMalwareUpload: (file: {
    size: number;
    mimetype?: string;
    originalname?: string;
}, maxSizeBytes?: number) => {
    isValid: boolean;
    error?: string;
};
/**
 * Creates NestJS DTO for malware search query.
 *
 * @param {string} [hash] - Hash filter
 * @param {string} [family] - Malware family filter
 * @param {string} [type] - Malware type filter
 * @param {boolean} [maliciousOnly] - Filter only malicious samples
 * @returns {Record<string, any>} Query DTO
 *
 * @example
 * ```typescript
 * const dto = createMalwareSearchDto(undefined, 'Emotet', 'trojan', true);
 * // Use in controller query
 * ```
 */
export declare const createMalwareSearchDto: (hash?: string, family?: string, type?: string, maliciousOnly?: boolean) => Record<string, any>;
/**
 * Extracts metadata from malware sample for indexing.
 *
 * @param {Buffer} fileBuffer - File buffer
 * @param {StaticAnalysisResult} analysis - Static analysis result
 * @returns {Record<string, any>} Malware metadata
 *
 * @example
 * ```typescript
 * const metadata = extractMalwareMetadata(buffer, staticAnalysis);
 * // Result: { fileSize: 1024, entropy: 7.5, isPacked: true, ... }
 * ```
 */
export declare const extractMalwareMetadata: (fileBuffer: Buffer, analysis: StaticAnalysisResult) => Record<string, any>;
/**
 * Generates malware analysis report summary.
 *
 * @param {SandboxResult} result - Sandbox analysis result
 * @returns {string} Human-readable analysis summary
 *
 * @example
 * ```typescript
 * const summary = generateAnalysisSummary(sandboxResult);
 * // Result: "Malicious: Detected ransomware behavior with C2 communication..."
 * ```
 */
export declare const generateAnalysisSummary: (result: SandboxResult) => string;
/**
 * Compares two malware samples for similarity.
 *
 * @param {MalwareHash} hash1 - First malware hashes
 * @param {MalwareHash} hash2 - Second malware hashes
 * @returns {{ isSame: boolean; similarity: number }} Comparison result
 *
 * @example
 * ```typescript
 * const comparison = compareMalwareSamples(hashes1, hashes2);
 * // Result: { isSame: false, similarity: 0.0 }
 * ```
 */
export declare const compareMalwareSamples: (hash1: MalwareHash, hash2: MalwareHash) => {
    isSame: boolean;
    similarity: number;
};
/**
 * Creates batch analysis job configuration.
 *
 * @param {string[]} hashes - Array of malware hashes to analyze
 * @param {SandboxConfig} config - Sandbox configuration
 * @returns {Record<string, any>} Batch job configuration
 *
 * @example
 * ```typescript
 * const batchJob = createBatchAnalysisJob(['hash1', 'hash2', 'hash3'], sandboxConfig);
 * // Result: { jobId: 'batch_...', totalSamples: 3, config: {...} }
 * ```
 */
export declare const createBatchAnalysisJob: (hashes: string[], config: SandboxConfig) => Record<string, any>;
/**
 * Validates sandbox configuration parameters.
 *
 * @param {SandboxConfig} config - Sandbox configuration
 * @returns {{ isValid: boolean; errors: string[] }} Validation result
 *
 * @example
 * ```typescript
 * const validation = validateSandboxConfig(config);
 * if (!validation.isValid) throw new Error(validation.errors.join(', '));
 * ```
 */
export declare const validateSandboxConfig: (config: SandboxConfig) => {
    isValid: boolean;
    errors: string[];
};
/**
 * Generates malware report in JSON format for API response.
 *
 * @param {MalwareSample} sample - Malware sample
 * @param {SandboxResult} [sandboxResult] - Optional sandbox analysis result
 * @returns {Record<string, any>} JSON report
 *
 * @example
 * ```typescript
 * const jsonReport = generateMalwareJsonReport(sample, sandboxResult);
 * // Result: { sample: {...}, analysis: {...}, timestamp: '...' }
 * ```
 */
export declare const generateMalwareJsonReport: (sample: MalwareSample, sandboxResult?: SandboxResult) => Record<string, any>;
declare const _default: {
    computeMD5Hash: (fileBuffer: Buffer) => string;
    computeSHA1Hash: (fileBuffer: Buffer) => string;
    computeSHA256Hash: (fileBuffer: Buffer) => string;
    computeAllHashes: (fileBuffer: Buffer) => MalwareHash;
    validateHashFormat: (hash: string, type: "md5" | "sha1" | "sha256" | "sha512") => boolean;
    normalizeHash: (hash: string) => string;
    detectFileSignature: (fileBuffer: Buffer) => FileSignature | null;
    extractMagicNumber: (fileBuffer: Buffer, length?: number) => string;
    validateFileType: (fileBuffer: Buffer, expectedType: string) => boolean;
    createYaraRule: (ruleName: string, strings: YaraString[], condition: string, meta?: Record<string, string>, tags?: string[]) => YaraRule;
    formatYaraRule: (rule: YaraRule) => string;
    parseYaraMatch: (ruleName: string, matchedStrings: MatchedString[], metadata: Record<string, string>) => YaraMatch;
    validateYaraRule: (rule: YaraRule) => boolean;
    createMalwareFamily: (familyName: string, type: MalwareType, aliases?: string[]) => Partial<MalwareFamily>;
    determineDangerLevel: (type: MalwareType, prevalence: number) => "low" | "medium" | "high" | "critical";
    classifyMalwareByBehavior: (behaviors: BehaviorIndicator[]) => MalwareType;
    updateFamilyPrevalence: (family: MalwareFamily, newSamples: number) => MalwareFamily;
    calculateFileEntropy: (buffer: Buffer) => number;
    isFilePacked: (entropy: number, threshold?: number) => boolean;
    extractStringsFromBuffer: (buffer: Buffer, minLength?: number) => ExtractedString[];
    detectStringType: (str: string) => "ascii" | "unicode" | "url" | "ip" | "email" | "filepath" | "registry";
    identifyPackers: (buffer: Buffer, sections: FileSection[]) => string[];
    analyzeProcessBehavior: (processes: ProcessInfo[]) => BehaviorIndicator[];
    analyzeNetworkBehavior: (connections: NetworkConnection[]) => BehaviorIndicator[];
    analyzeRegistryBehavior: (changes: RegistryChange[]) => BehaviorIndicator[];
    calculateMaliciousScore: (result: DynamicAnalysisResult) => number;
    createSandboxConfig: (overrides?: Partial<SandboxConfig>) => SandboxConfig;
    validateSandboxResult: (result: SandboxResult) => boolean;
    generateSandboxVerdict: (staticResult: StaticAnalysisResult, dynamicResult: DynamicAnalysisResult) => {
        verdict: "benign" | "suspicious" | "malicious";
        score: number;
    };
    parsePEHeader: (buffer: Buffer) => PEFileHeader | null;
    extractPESections: (buffer: Buffer) => FileSection[];
    parseELFHeader: (buffer: Buffer) => ELFFileHeader | null;
    parseMachOHeader: (buffer: Buffer) => MachOFileHeader | null;
    createMalwareSampleModel: () => Record<string, any>;
    createMalwareHashQuery: (hash: string) => Record<string, any>;
    createMalwareFamilyQuery: (familyName: string, startDate?: Date, endDate?: Date) => Record<string, any>;
    performStaticAnalysis: (fileBuffer: Buffer) => Promise<Partial<StaticAnalysisResult>>;
    submitMalwareToSandbox: (sha256: string, config: SandboxConfig) => Promise<string>;
    retrieveMalwareByHash: (hash: string) => Promise<Partial<MalwareSample> | null>;
    createMalwareUploadApiDoc: () => Record<string, any>;
    createMalwareAnalysisApiDoc: () => Record<string, any>;
    createMalwareSampleSchema: () => Record<string, any>;
    createYaraRuleSchema: () => Record<string, any>;
    validateMalwareUpload: (file: {
        size: number;
        mimetype?: string;
        originalname?: string;
    }, maxSizeBytes?: number) => {
        isValid: boolean;
        error?: string;
    };
    createMalwareSearchDto: (hash?: string, family?: string, type?: string, maliciousOnly?: boolean) => Record<string, any>;
    extractMalwareMetadata: (fileBuffer: Buffer, analysis: StaticAnalysisResult) => Record<string, any>;
    generateAnalysisSummary: (result: SandboxResult) => string;
    compareMalwareSamples: (hash1: MalwareHash, hash2: MalwareHash) => {
        isSame: boolean;
        similarity: number;
    };
    createBatchAnalysisJob: (hashes: string[], config: SandboxConfig) => Record<string, any>;
    validateSandboxConfig: (config: SandboxConfig) => {
        isValid: boolean;
        errors: string[];
    };
    generateMalwareJsonReport: (sample: MalwareSample, sandboxResult?: SandboxResult) => Record<string, any>;
};
export default _default;
//# sourceMappingURL=malware-analysis-kit.d.ts.map