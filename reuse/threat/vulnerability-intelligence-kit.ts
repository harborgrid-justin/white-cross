/**
 * LOC: VUIN1234567
 * File: /reuse/threat/vulnerability-intelligence-kit.ts
 *
 * UPSTREAM (imports from):
 *   - None (leaf node - reusable utilities)
 *
 * DOWNSTREAM (imported by):
 *   - Threat intelligence services
 *   - Vulnerability analytics controllers
 *   - Security intelligence platforms
 */

/**
 * File: /reuse/threat/vulnerability-intelligence-kit.ts
 * Locator: WC-THR-VUIN-001
 * Purpose: Comprehensive Vulnerability Intelligence Utilities - Exploit prediction, zero-day tracking, trend analysis
 *
 * Upstream: Independent utility module for vulnerability intelligence and analytics
 * Downstream: ../backend/*, threat intelligence controllers, analytics services, intelligence feeds
 * Dependencies: TypeScript 5.x, Node 18+, NestJS 10.x, Sequelize 6.x, Swagger/OpenAPI
 * Exports: 40 utility functions for exploit prediction, zero-day tracking, trend analysis, intelligence feeds
 *
 * LLM Context: Comprehensive vulnerability intelligence utilities for implementing advanced threat intelligence systems.
 * Provides exploit prediction algorithms, zero-day vulnerability tracking, trend analysis, exploit kit detection,
 * threat correlation, NVD integration, intelligence feed parsing, and advanced analytics for proactive security.
 * Essential for building predictive, intelligence-driven healthcare security platforms.
 */

// ============================================================================
// TYPE DEFINITIONS
// ============================================================================

interface ExploitPrediction {
  cveId: string;
  exploitProbability: number;
  timeToExploit: number;
  predictionConfidence: number;
  riskFactors: {
    technicalComplexity: number;
    attackSurfaceSize: number;
    vendorResponseTime: number;
    publicInterest: number;
    darkWebChatter: number;
  };
  predictedExploitDate?: Date;
  reasoning: string[];
}

interface ZeroDayVulnerability {
  id: string;
  discoveryDate: Date;
  disclosureDate?: Date;
  vendorNotificationDate?: Date;
  affectedProducts: {
    vendor: string;
    product: string;
    versions: string[];
  }[];
  severity: 'CRITICAL' | 'HIGH' | 'MEDIUM' | 'LOW';
  exploitationStatus: 'IN_THE_WILD' | 'POC_AVAILABLE' | 'THEORETICAL';
  attribution?: {
    threatActor?: string;
    campaign?: string;
    targetedSectors?: string[];
  };
  iocData?: {
    ipAddresses?: string[];
    domains?: string[];
    fileHashes?: string[];
  };
  mitigation?: string;
}

interface VulnerabilityTrend {
  period: 'daily' | 'weekly' | 'monthly' | 'yearly';
  startDate: Date;
  endDate: Date;
  totalVulnerabilities: number;
  severityDistribution: {
    critical: number;
    high: number;
    medium: number;
    low: number;
  };
  topVendors: { vendor: string; count: number }[];
  topCWEs: { cweId: string; count: number; description: string }[];
  exploitTrends: {
    exploitsPublished: number;
    zeroDay: number;
    weaponized: number;
  };
  growthRate: number;
}

interface ExploitKit {
  name: string;
  aliases: string[];
  firstSeen: Date;
  lastSeen: Date;
  targetedVulnerabilities: string[];
  deliveryMethods: string[];
  payloadTypes: string[];
  detectionSignatures: string[];
  associatedThreatActors: string[];
  prevalence: 'WIDESPREAD' | 'MODERATE' | 'LIMITED' | 'RARE';
  sophistication: 'ADVANCED' | 'INTERMEDIATE' | 'BASIC';
}

interface ThreatCorrelation {
  cveId: string;
  correlatedThreats: {
    threatId: string;
    threatType: 'APT' | 'RANSOMWARE' | 'MALWARE' | 'EXPLOIT_KIT' | 'PHISHING';
    correlation Score: number;
    evidenceLinks: string[];
    firstObserved: Date;
    lastObserved: Date;
  }[];
  attackPatterns: string[];
  victimology: {
    sectors: string[];
    regions: string[];
    organizationSizes: string[];
  };
  recommendedActions: string[];
}

interface NVDFeedEntry {
  cveId: string;
  sourceIdentifier: string;
  published: Date;
  lastModified: Date;
  vulnStatus: 'ANALYZED' | 'MODIFIED' | 'UNDERGOING_ANALYSIS' | 'AWAITING_ANALYSIS' | 'REJECTED';
  descriptions: { lang: string; value: string }[];
  metrics: {
    cvssMetricV31?: any;
    cvssMetricV30?: any;
    cvssMetricV2?: any;
  };
  weaknesses: { source: string; type: string; description: { lang: string; value: string }[] }[];
  configurations: any[];
  references: { url: string; source: string; tags?: string[] }[];
}

interface IntelligenceFeed {
  feedId: string;
  feedName: string;
  feedType: 'NVD' | 'CISA_KEV' | 'EXPLOIT_DB' | 'VENDOR' | 'OSINT' | 'COMMERCIAL';
  lastUpdated: Date;
  updateFrequency: string;
  entriesCount: number;
  reliability: 'CONFIRMED' | 'PROBABLE' | 'POSSIBLE' | 'UNCONFIRMED';
  dataQuality: number;
  coverage: string[];
}

interface VulnerabilityIntelligenceReport {
  reportId: string;
  generatedDate: Date;
  reportPeriod: { start: Date; end: Date };
  executiveSummary: string;
  keyFindings: string[];
  criticalVulnerabilities: {
    cveId: string;
    severity: string;
    exploitStatus: string;
    affectedAssets: number;
  }[];
  emergingThreats: {
    threat: string;
    description: string;
    impact: string;
    indicators: string[];
  }[];
  recommendations: {
    priority: 'IMMEDIATE' | 'HIGH' | 'MEDIUM' | 'LOW';
    action: string;
    rationale: string;
  }[];
  metrics: {
    vulnerabilitiesDiscovered: number;
    vulnerabilitiesPatched: number;
    meanTimeToDetect: number;
    meanTimeToRemediate: number;
  };
}

// ============================================================================
// EXPLOIT PREDICTION
// ============================================================================

/**
 * Predicts exploit likelihood for a vulnerability using ML-like heuristics.
 *
 * @param {string} cveId - CVE identifier
 * @param {object} features - Feature set for prediction
 * @returns {ExploitPrediction} Exploit prediction result
 *
 * @example
 * ```typescript
 * const prediction = predictExploitLikelihood('CVE-2024-1234', {
 *   cvssScore: 9.8,
 *   attackComplexity: 'LOW',
 *   publicDisclosure: true,
 *   vendorPatchAvailable: false,
 *   affectedProductPopularity: 0.95
 * });
 * // Result: { exploitProbability: 0.87, timeToExploit: 14, ... }
 * ```
 */
export const predictExploitLikelihood = (
  cveId: string,
  features: {
    cvssScore: number;
    attackComplexity: 'LOW' | 'HIGH';
    publicDisclosure: boolean;
    vendorPatchAvailable: boolean;
    affectedProductPopularity: number;
    socialMediaMentions?: number;
  },
): ExploitPrediction => {
  const { cvssScore, attackComplexity, publicDisclosure, vendorPatchAvailable, affectedProductPopularity } = features;

  // Feature scoring (0-1 scale)
  const technicalComplexity = attackComplexity === 'LOW' ? 0.8 : 0.3;
  const attackSurfaceSize = affectedProductPopularity;
  const vendorResponseTime = vendorPatchAvailable ? 0.3 : 0.9;
  const publicInterest = publicDisclosure ? 0.7 : 0.2;
  const darkWebChatter = (features.socialMediaMentions || 0) / 1000;

  // Weighted probability calculation
  const exploitProbability = Math.min(
    (cvssScore / 10) * 0.3 +
    technicalComplexity * 0.25 +
    attackSurfaceSize * 0.2 +
    vendorResponseTime * 0.15 +
    publicInterest * 0.1,
    1.0,
  );

  // Time to exploit estimation (days)
  const baseTime = 30;
  const complexityFactor = attackComplexity === 'LOW' ? 0.5 : 1.5;
  const disclosureFactor = publicDisclosure ? 0.6 : 1.2;
  const timeToExploit = Math.round(baseTime * complexityFactor * disclosureFactor * (1 - exploitProbability));

  const reasoning = [
    `CVSS score ${cvssScore} indicates ${cvssScore >= 7 ? 'high' : 'moderate'} severity`,
    `Attack complexity is ${attackComplexity}`,
    `Patch ${vendorPatchAvailable ? 'is' : 'is not'} available`,
    `${publicDisclosure ? 'Public' : 'Limited'} disclosure increases attention`,
  ];

  return {
    cveId,
    exploitProbability: Math.round(exploitProbability * 100) / 100,
    timeToExploit,
    predictionConfidence: 0.78,
    riskFactors: {
      technicalComplexity,
      attackSurfaceSize,
      vendorResponseTime,
      publicInterest,
      darkWebChatter: Math.min(darkWebChatter, 1),
    },
    predictedExploitDate: new Date(Date.now() + timeToExploit * 24 * 60 * 60 * 1000),
    reasoning,
  };
};

/**
 * Calculates EPSS (Exploit Prediction Scoring System) score.
 *
 * @param {object} vulnerability - Vulnerability metadata
 * @returns {number} EPSS score (0.0 - 1.0)
 *
 * @example
 * ```typescript
 * const epss = calculateEPSSScore({
 *   cveAge: 30,
 *   cvssScore: 9.1,
 *   references: 15,
 *   exploitCodeMaturity: 'FUNCTIONAL'
 * });
 * // Result: 0.64
 * ```
 */
export const calculateEPSSScore = (vulnerability: {
  cveAge: number;
  cvssScore: number;
  references: number;
  exploitCodeMaturity: 'UNPROVEN' | 'POC' | 'FUNCTIONAL' | 'HIGH';
}): number => {
  const maturityScore = {
    UNPROVEN: 0.1,
    POC: 0.4,
    FUNCTIONAL: 0.7,
    HIGH: 0.95,
  }[vulnerability.exploitCodeMaturity];

  const ageWeight = Math.min(vulnerability.cveAge / 365, 1);
  const cvssWeight = vulnerability.cvssScore / 10;
  const referencesWeight = Math.min(vulnerability.references / 50, 1);

  const epss =
    maturityScore * 0.4 +
    cvssWeight * 0.3 +
    ageWeight * 0.2 +
    referencesWeight * 0.1;

  return Math.round(epss * 100) / 100;
};

/**
 * Assesses weaponization potential of a vulnerability.
 *
 * @param {string} cveId - CVE identifier
 * @param {object} characteristics - Vulnerability characteristics
 * @returns {object} Weaponization assessment
 *
 * @example
 * ```typescript
 * const assessment = assessWeaponizationPotential('CVE-2024-5678', {
 *   remoteExploitable: true,
 *   requiresAuth: false,
 *   impactScope: 'SYSTEM',
 *   exploitReliability: 0.95
 * });
 * ```
 */
export const assessWeaponizationPotential = (
  cveId: string,
  characteristics: {
    remoteExploitable: boolean;
    requiresAuth: boolean;
    impactScope: 'LIMITED' | 'APPLICATION' | 'SYSTEM';
    exploitReliability: number;
  },
): { potential: 'VERY_HIGH' | 'HIGH' | 'MEDIUM' | 'LOW'; score: number; factors: string[] } => {
  let score = 0;
  const factors: string[] = [];

  if (characteristics.remoteExploitable) {
    score += 40;
    factors.push('Remotely exploitable');
  }

  if (!characteristics.requiresAuth) {
    score += 30;
    factors.push('No authentication required');
  }

  if (characteristics.impactScope === 'SYSTEM') {
    score += 20;
    factors.push('System-level impact');
  } else if (characteristics.impactScope === 'APPLICATION') {
    score += 10;
  }

  score += characteristics.exploitReliability * 10;
  factors.push(`Reliability: ${(characteristics.exploitReliability * 100).toFixed(0)}%`);

  let potential: 'VERY_HIGH' | 'HIGH' | 'MEDIUM' | 'LOW';
  if (score >= 85) potential = 'VERY_HIGH';
  else if (score >= 65) potential = 'HIGH';
  else if (score >= 40) potential = 'MEDIUM';
  else potential = 'LOW';

  return { potential, score, factors };
};

// ============================================================================
// ZERO-DAY TRACKING
// ============================================================================

/**
 * Registers a new zero-day vulnerability discovery.
 *
 * @param {Partial<ZeroDayVulnerability>} zeroDay - Zero-day vulnerability data
 * @returns {ZeroDayVulnerability} Registered zero-day vulnerability
 *
 * @example
 * ```typescript
 * const zeroDay = registerZeroDayVulnerability({
 *   affectedProducts: [{ vendor: 'Microsoft', product: 'Exchange', versions: ['2019', '2016'] }],
 *   severity: 'CRITICAL',
 *   exploitationStatus: 'IN_THE_WILD'
 * });
 * ```
 */
export const registerZeroDayVulnerability = (zeroDay: Partial<ZeroDayVulnerability>): ZeroDayVulnerability => {
  return {
    id: zeroDay.id || `ZERO-${Date.now()}`,
    discoveryDate: zeroDay.discoveryDate || new Date(),
    affectedProducts: zeroDay.affectedProducts || [],
    severity: zeroDay.severity || 'HIGH',
    exploitationStatus: zeroDay.exploitationStatus || 'THEORETICAL',
    ...zeroDay,
  };
};

/**
 * Tracks zero-day disclosure timeline.
 *
 * @param {ZeroDayVulnerability} zeroDay - Zero-day vulnerability
 * @returns {object} Disclosure timeline analysis
 *
 * @example
 * ```typescript
 * const timeline = trackZeroDayDisclosure(zeroDay);
 * // Result: { daysSinceDiscovery: 45, daysToVendorNotification: 3, daysToPublicDisclosure: 30 }
 * ```
 */
export const trackZeroDayDisclosure = (
  zeroDay: ZeroDayVulnerability,
): {
  daysSinceDiscovery: number;
  daysToVendorNotification?: number;
  daysToPublicDisclosure?: number;
  isStillZeroDay: boolean;
} => {
  const now = new Date();
  const daysSinceDiscovery = Math.floor((now.getTime() - zeroDay.discoveryDate.getTime()) / (1000 * 60 * 60 * 24));

  const daysToVendorNotification = zeroDay.vendorNotificationDate
    ? Math.floor(
        (zeroDay.vendorNotificationDate.getTime() - zeroDay.discoveryDate.getTime()) / (1000 * 60 * 60 * 24),
      )
    : undefined;

  const daysToPublicDisclosure = zeroDay.disclosureDate
    ? Math.floor((zeroDay.disclosureDate.getTime() - zeroDay.discoveryDate.getTime()) / (1000 * 60 * 60 * 24))
    : undefined;

  const isStillZeroDay = !zeroDay.disclosureDate;

  return {
    daysSinceDiscovery,
    daysToVendorNotification,
    daysToPublicDisclosure,
    isStillZeroDay,
  };
};

/**
 * Identifies potential zero-day indicators from vulnerability data.
 *
 * @param {object} vulnerability - Vulnerability data to analyze
 * @returns {object} Zero-day indicators
 *
 * @example
 * ```typescript
 * const indicators = identifyZeroDayIndicators({
 *   exploitInTheWild: true,
 *   vendorAwareness: false,
 *   publicCVE: false,
 *   unusualAttackPattern: true
 * });
 * ```
 */
export const identifyZeroDayIndicators = (vulnerability: {
  exploitInTheWild: boolean;
  vendorAwareness: boolean;
  publicCVE: boolean;
  unusualAttackPattern: boolean;
  targetedAttacks: boolean;
}): { isLikelyZeroDay: boolean; confidence: number; indicators: string[] } => {
  const indicators: string[] = [];
  let score = 0;

  if (vulnerability.exploitInTheWild && !vulnerability.publicCVE) {
    score += 40;
    indicators.push('Active exploitation without public CVE');
  }

  if (!vulnerability.vendorAwareness) {
    score += 30;
    indicators.push('Vendor appears unaware of vulnerability');
  }

  if (vulnerability.unusualAttackPattern) {
    score += 15;
    indicators.push('Novel attack pattern detected');
  }

  if (vulnerability.targetedAttacks) {
    score += 15;
    indicators.push('Targeted attacks observed');
  }

  return {
    isLikelyZeroDay: score >= 60,
    confidence: Math.min(score, 100) / 100,
    indicators,
  };
};

// ============================================================================
// VULNERABILITY TREND ANALYSIS
// ============================================================================

/**
 * Analyzes vulnerability trends over a time period.
 *
 * @param {Date} startDate - Analysis start date
 * @param {Date} endDate - Analysis end date
 * @param {any[]} vulnerabilities - Vulnerability dataset
 * @returns {VulnerabilityTrend} Trend analysis result
 *
 * @example
 * ```typescript
 * const trends = analyzeVulnerabilityTrends(
 *   new Date('2024-01-01'),
 *   new Date('2024-12-31'),
 *   vulnerabilityData
 * );
 * ```
 */
export const analyzeVulnerabilityTrends = (
  startDate: Date,
  endDate: Date,
  vulnerabilities: any[],
): VulnerabilityTrend => {
  const totalVulnerabilities = vulnerabilities.length;

  const severityDistribution = vulnerabilities.reduce(
    (acc, v) => {
      const severity = (v.severity || 'LOW').toLowerCase();
      acc[severity] = (acc[severity] || 0) + 1;
      return acc;
    },
    { critical: 0, high: 0, medium: 0, low: 0 },
  );

  const vendorCounts = vulnerabilities.reduce((acc, v) => {
    const vendor = v.vendor || 'Unknown';
    acc[vendor] = (acc[vendor] || 0) + 1;
    return acc;
  }, {} as Record<string, number>);

  const topVendors = Object.entries(vendorCounts)
    .map(([vendor, count]) => ({ vendor, count: count as number }))
    .sort((a, b) => b.count - a.count)
    .slice(0, 10);

  const cweCounts = vulnerabilities.reduce((acc, v) => {
    (v.cweIds || []).forEach((cwe: string) => {
      acc[cwe] = (acc[cwe] || 0) + 1;
    });
    return acc;
  }, {} as Record<string, number>);

  const topCWEs = Object.entries(cweCounts)
    .map(([cweId, count]) => ({ cweId, count: count as number, description: `CWE ${cweId}` }))
    .sort((a, b) => b.count - a.count)
    .slice(0, 10);

  const exploitsPublished = vulnerabilities.filter(v => v.exploitAvailable).length;
  const zeroDay = vulnerabilities.filter(v => v.isZeroDay).length;
  const weaponized = vulnerabilities.filter(v => v.weaponized).length;

  const daysDiff = Math.ceil((endDate.getTime() - startDate.getTime()) / (1000 * 60 * 60 * 24));
  const period = daysDiff <= 7 ? 'daily' : daysDiff <= 31 ? 'weekly' : daysDiff <= 365 ? 'monthly' : 'yearly';

  return {
    period,
    startDate,
    endDate,
    totalVulnerabilities,
    severityDistribution,
    topVendors,
    topCWEs,
    exploitTrends: {
      exploitsPublished,
      zeroDay,
      weaponized,
    },
    growthRate: 0.12, // Placeholder
  };
};

/**
 * Predicts future vulnerability trends using historical data.
 *
 * @param {VulnerabilityTrend[]} historicalTrends - Historical trend data
 * @returns {object} Trend prediction
 *
 * @example
 * ```typescript
 * const forecast = predictVulnerabilityTrends(pastYearTrends);
 * // Result: { nextMonth: 450, confidence: 0.78, trendDirection: 'INCREASING' }
 * ```
 */
export const predictVulnerabilityTrends = (
  historicalTrends: VulnerabilityTrend[],
): { nextPeriod: number; confidence: number; trendDirection: 'INCREASING' | 'STABLE' | 'DECREASING' } => {
  if (historicalTrends.length < 2) {
    return { nextPeriod: 0, confidence: 0, trendDirection: 'STABLE' };
  }

  const counts = historicalTrends.map(t => t.totalVulnerabilities);
  const avgGrowth = counts.slice(1).reduce((acc, val, idx) => acc + (val - counts[idx]), 0) / (counts.length - 1);
  const lastCount = counts[counts.length - 1];
  const nextPeriod = Math.max(0, Math.round(lastCount + avgGrowth));

  let trendDirection: 'INCREASING' | 'STABLE' | 'DECREASING';
  if (avgGrowth > 5) trendDirection = 'INCREASING';
  else if (avgGrowth < -5) trendDirection = 'DECREASING';
  else trendDirection = 'STABLE';

  return {
    nextPeriod,
    confidence: 0.72,
    trendDirection,
  };
};

/**
 * Compares vulnerability trends across different time periods.
 *
 * @param {VulnerabilityTrend} current - Current period trend
 * @param {VulnerabilityTrend} previous - Previous period trend
 * @returns {object} Comparison result
 *
 * @example
 * ```typescript
 * const comparison = compareVulnerabilityTrends(thisMonthTrend, lastMonthTrend);
 * ```
 */
export const compareVulnerabilityTrends = (
  current: VulnerabilityTrend,
  previous: VulnerabilityTrend,
): {
  volumeChange: number;
  severityShift: { critical: number; high: number; medium: number; low: number };
  topChanges: string[];
} => {
  const volumeChange = ((current.totalVulnerabilities - previous.totalVulnerabilities) / previous.totalVulnerabilities) * 100;

  const severityShift = {
    critical: current.severityDistribution.critical - previous.severityDistribution.critical,
    high: current.severityDistribution.high - previous.severityDistribution.high,
    medium: current.severityDistribution.medium - previous.severityDistribution.medium,
    low: current.severityDistribution.low - previous.severityDistribution.low,
  };

  const topChanges = [
    `Total vulnerabilities ${volumeChange >= 0 ? 'increased' : 'decreased'} by ${Math.abs(volumeChange).toFixed(1)}%`,
    `Critical vulnerabilities changed by ${severityShift.critical}`,
  ];

  return { volumeChange, severityShift, topChanges };
};

// ============================================================================
// EXPLOIT KIT DETECTION
// ============================================================================

/**
 * Detects exploit kit signatures in attack data.
 *
 * @param {object} attackData - Attack data to analyze
 * @returns {object} Exploit kit detection result
 *
 * @example
 * ```typescript
 * const detection = detectExploitKit({
 *   payloadSignatures: ['signature1', 'signature2'],
 *   deliveryMethod: 'malvertising',
 *   targetedCVEs: ['CVE-2024-1234']
 * });
 * ```
 */
export const detectExploitKit = (attackData: {
  payloadSignatures: string[];
  deliveryMethod: string;
  targetedCVEs: string[];
}): { detected: boolean; kitName?: string; confidence: number; matchedSignatures: string[] } => {
  const knownKits: Record<string, { signatures: string[]; cves: string[] }> = {
    'Angler': { signatures: ['sig_angler_1', 'sig_angler_2'], cves: ['CVE-2015-5119', 'CVE-2016-0189'] },
    'RIG': { signatures: ['sig_rig_1', 'sig_rig_2'], cves: ['CVE-2018-8174', 'CVE-2019-0752'] },
    'Magnitude': { signatures: ['sig_mag_1'], cves: ['CVE-2021-26411'] },
  };

  for (const [kitName, kitData] of Object.entries(knownKits)) {
    const matchedSignatures = attackData.payloadSignatures.filter(s => kitData.signatures.includes(s));
    const matchedCVEs = attackData.targetedCVEs.filter(c => kitData.cves.includes(c));

    if (matchedSignatures.length > 0 || matchedCVEs.length > 0) {
      const confidence = (matchedSignatures.length + matchedCVEs.length) / (kitData.signatures.length + kitData.cves.length);
      return {
        detected: true,
        kitName,
        confidence: Math.min(confidence, 1),
        matchedSignatures,
      };
    }
  }

  return { detected: false, confidence: 0, matchedSignatures: [] };
};

/**
 * Profiles exploit kit capabilities and behavior.
 *
 * @param {ExploitKit} kit - Exploit kit to profile
 * @returns {object} Capability profile
 *
 * @example
 * ```typescript
 * const profile = profileExploitKitCapabilities(exploitKit);
 * ```
 */
export const profileExploitKitCapabilities = (
  kit: ExploitKit,
): { threatLevel: 'CRITICAL' | 'HIGH' | 'MEDIUM' | 'LOW'; capabilities: string[]; recommendations: string[] } => {
  const capabilities = [
    `Targets ${kit.targetedVulnerabilities.length} known vulnerabilities`,
    `Uses ${kit.deliveryMethods.join(', ')} for delivery`,
    `Delivers ${kit.payloadTypes.join(', ')} payloads`,
  ];

  let threatLevel: 'CRITICAL' | 'HIGH' | 'MEDIUM' | 'LOW';
  if (kit.prevalence === 'WIDESPREAD' && kit.sophistication === 'ADVANCED') {
    threatLevel = 'CRITICAL';
  } else if (kit.prevalence === 'WIDESPREAD' || kit.sophistication === 'ADVANCED') {
    threatLevel = 'HIGH';
  } else if (kit.prevalence === 'MODERATE') {
    threatLevel = 'MEDIUM';
  } else {
    threatLevel = 'LOW';
  }

  const recommendations = [
    'Deploy signatures to IDS/IPS systems',
    'Block known delivery domains',
    'Patch targeted vulnerabilities immediately',
  ];

  return { threatLevel, capabilities, recommendations };
};

// ============================================================================
// THREAT CORRELATION
// ============================================================================

/**
 * Correlates vulnerability with threat intelligence.
 *
 * @param {string} cveId - CVE identifier
 * @param {any[]} threatIntelligence - Threat intelligence data
 * @returns {ThreatCorrelation} Correlation result
 *
 * @example
 * ```typescript
 * const correlation = correlateVulnerabilityWithThreats('CVE-2024-1234', threatData);
 * ```
 */
export const correlateVulnerabilityWithThreats = (
  cveId: string,
  threatIntelligence: any[],
): ThreatCorrelation => {
  const correlatedThreats = threatIntelligence
    .filter(threat => threat.targetedCVEs?.includes(cveId))
    .map(threat => ({
      threatId: threat.id,
      threatType: threat.type || 'MALWARE',
      correlationScore: 0.85,
      evidenceLinks: threat.references || [],
      firstObserved: new Date(threat.firstSeen || Date.now()),
      lastObserved: new Date(threat.lastSeen || Date.now()),
    }));

  const attackPatterns = [...new Set(threatIntelligence.flatMap(t => t.attackPatterns || []))];

  const sectors = [...new Set(threatIntelligence.flatMap(t => t.targetSectors || []))];
  const regions = [...new Set(threatIntelligence.flatMap(t => t.targetRegions || []))];

  return {
    cveId,
    correlatedThreats,
    attackPatterns,
    victimology: {
      sectors,
      regions,
      organizationSizes: ['LARGE', 'MEDIUM'],
    },
    recommendedActions: [
      'Monitor for indicators of compromise',
      'Implement additional detection rules',
      'Prioritize patching for this CVE',
    ],
  };
};

/**
 * Maps vulnerability to MITRE ATT&CK techniques.
 *
 * @param {string} cveId - CVE identifier
 * @param {object} exploitCharacteristics - Exploit characteristics
 * @returns {object} MITRE ATT&CK mapping
 *
 * @example
 * ```typescript
 * const mapping = mapVulnerabilityToMITREATTACK('CVE-2024-1234', {
 *   exploitType: 'remote_code_execution',
 *   targetComponent: 'web_application'
 * });
 * ```
 */
export const mapVulnerabilityToMITREATTACK = (
  cveId: string,
  exploitCharacteristics: { exploitType: string; targetComponent: string },
): { tactics: string[]; techniques: { id: string; name: string; tactic: string }[] } => {
  const techniqueMap: Record<string, { id: string; name: string; tactic: string }[]> = {
    remote_code_execution: [
      { id: 'T1190', name: 'Exploit Public-Facing Application', tactic: 'Initial Access' },
      { id: 'T1203', name: 'Exploitation for Client Execution', tactic: 'Execution' },
    ],
    privilege_escalation: [
      { id: 'T1068', name: 'Exploitation for Privilege Escalation', tactic: 'Privilege Escalation' },
    ],
    sql_injection: [
      { id: 'T1190', name: 'Exploit Public-Facing Application', tactic: 'Initial Access' },
      { id: 'T1213', name: 'Data from Information Repositories', tactic: 'Collection' },
    ],
  };

  const techniques = techniqueMap[exploitCharacteristics.exploitType] || [];
  const tactics = [...new Set(techniques.map(t => t.tactic))];

  return { tactics, techniques };
};

// ============================================================================
// NVD INTEGRATION
// ============================================================================

/**
 * Parses NVD JSON feed entry.
 *
 * @param {any} nvdEntry - Raw NVD JSON entry
 * @returns {NVDFeedEntry} Parsed NVD entry
 *
 * @example
 * ```typescript
 * const parsed = parseNVDFeedEntry(rawNVDData);
 * ```
 */
export const parseNVDFeedEntry = (nvdEntry: any): NVDFeedEntry => {
  return {
    cveId: nvdEntry.cve?.id || '',
    sourceIdentifier: nvdEntry.cve?.sourceIdentifier || '',
    published: new Date(nvdEntry.cve?.published || Date.now()),
    lastModified: new Date(nvdEntry.cve?.lastModified || Date.now()),
    vulnStatus: nvdEntry.cve?.vulnStatus || 'AWAITING_ANALYSIS',
    descriptions: nvdEntry.cve?.descriptions || [],
    metrics: nvdEntry.cve?.metrics || {},
    weaknesses: nvdEntry.cve?.weaknesses || [],
    configurations: nvdEntry.cve?.configurations || [],
    references: nvdEntry.cve?.references || [],
  };
};

/**
 * Queries NVD database with filters.
 *
 * @param {object} filters - Query filters
 * @returns {Promise<NVDFeedEntry[]>} Filtered NVD entries
 *
 * @example
 * ```typescript
 * const results = await queryNVDDatabase({
 *   startDate: new Date('2024-01-01'),
 *   endDate: new Date('2024-12-31'),
 *   severity: 'HIGH',
 *   keyword: 'remote code execution'
 * });
 * ```
 */
export const queryNVDDatabase = async (filters: {
  startDate?: Date;
  endDate?: Date;
  severity?: string;
  keyword?: string;
  cweId?: string;
}): Promise<NVDFeedEntry[]> => {
  // Mock implementation - in production, this would call NVD API
  const mockEntries: NVDFeedEntry[] = [
    {
      cveId: 'CVE-2024-1234',
      sourceIdentifier: 'nvd@nist.gov',
      published: new Date('2024-06-15'),
      lastModified: new Date('2024-06-16'),
      vulnStatus: 'ANALYZED',
      descriptions: [{ lang: 'en', value: 'Remote code execution vulnerability' }],
      metrics: {},
      weaknesses: [],
      configurations: [],
      references: [],
    },
  ];

  return mockEntries;
};

/**
 * Synchronizes local database with NVD feed.
 *
 * @param {Date} lastSync - Last synchronization timestamp
 * @returns {Promise<object>} Sync result
 *
 * @example
 * ```typescript
 * const syncResult = await syncNVDFeed(lastSyncDate);
 * // Result: { newEntries: 145, updatedEntries: 23, syncTime: Date }
 * ```
 */
export const syncNVDFeed = async (
  lastSync: Date,
): Promise<{ newEntries: number; updatedEntries: number; syncTime: Date }> => {
  // Mock implementation
  return {
    newEntries: 145,
    updatedEntries: 23,
    syncTime: new Date(),
  };
};

/**
 * Extracts CPE (Common Platform Enumeration) from NVD entry.
 *
 * @param {NVDFeedEntry} entry - NVD feed entry
 * @returns {string[]} CPE identifiers
 *
 * @example
 * ```typescript
 * const cpes = extractCPEFromNVD(nvdEntry);
 * // Result: ['cpe:2.3:a:vendor:product:1.0:*:*:*:*:*:*:*']
 * ```
 */
export const extractCPEFromNVD = (entry: NVDFeedEntry): string[] => {
  const cpes: string[] = [];

  entry.configurations.forEach((config: any) => {
    if (config.nodes) {
      config.nodes.forEach((node: any) => {
        if (node.cpeMatch) {
          node.cpeMatch.forEach((match: any) => {
            if (match.criteria) {
              cpes.push(match.criteria);
            }
          });
        }
      });
    }
  });

  return [...new Set(cpes)];
};

// ============================================================================
// INTELLIGENCE FEEDS
// ============================================================================

/**
 * Aggregates multiple intelligence feeds.
 *
 * @param {IntelligenceFeed[]} feeds - Intelligence feeds to aggregate
 * @returns {object} Aggregated intelligence
 *
 * @example
 * ```typescript
 * const aggregated = aggregateIntelligenceFeeds([nvdFeed, cisaFeed, exploitDbFeed]);
 * ```
 */
export const aggregateIntelligenceFeeds = (
  feeds: IntelligenceFeed[],
): { totalEntries: number; coverageMap: Record<string, number>; lastUpdate: Date } => {
  const totalEntries = feeds.reduce((sum, feed) => sum + feed.entriesCount, 0);

  const coverageMap: Record<string, number> = {};
  feeds.forEach(feed => {
    feed.coverage.forEach(area => {
      coverageMap[area] = (coverageMap[area] || 0) + 1;
    });
  });

  const lastUpdate = new Date(Math.max(...feeds.map(f => f.lastUpdated.getTime())));

  return { totalEntries, coverageMap, lastUpdate };
};

/**
 * Validates intelligence feed data quality.
 *
 * @param {IntelligenceFeed} feed - Intelligence feed to validate
 * @returns {object} Validation result
 *
 * @example
 * ```typescript
 * const validation = validateIntelligenceFeed(feed);
 * ```
 */
export const validateIntelligenceFeed = (
  feed: IntelligenceFeed,
): { isValid: boolean; score: number; issues: string[] } => {
  const issues: string[] = [];
  let score = 100;

  if (feed.dataQuality < 0.7) {
    issues.push('Data quality below acceptable threshold');
    score -= 20;
  }

  const hoursSinceUpdate = (Date.now() - feed.lastUpdated.getTime()) / (1000 * 60 * 60);
  if (hoursSinceUpdate > 48) {
    issues.push('Feed not updated in 48+ hours');
    score -= 15;
  }

  if (feed.entriesCount === 0) {
    issues.push('Feed contains no entries');
    score -= 30;
  }

  if (feed.reliability === 'UNCONFIRMED') {
    issues.push('Feed reliability is unconfirmed');
    score -= 10;
  }

  return {
    isValid: score >= 60,
    score: Math.max(0, score),
    issues,
  };
};

/**
 * Enriches vulnerability data with intelligence feeds.
 *
 * @param {string} cveId - CVE identifier
 * @param {IntelligenceFeed[]} feeds - Intelligence feeds
 * @returns {Promise<object>} Enriched vulnerability data
 *
 * @example
 * ```typescript
 * const enriched = await enrichVulnerabilityWithFeeds('CVE-2024-1234', intelligenceFeeds);
 * ```
 */
export const enrichVulnerabilityWithFeeds = async (
  cveId: string,
  feeds: IntelligenceFeed[],
): Promise<{ cveId: string; enrichments: Record<string, any>; sources: string[] }> => {
  const enrichments: Record<string, any> = {};
  const sources: string[] = [];

  // Mock enrichment from multiple feeds
  feeds.forEach(feed => {
    enrichments[feed.feedType] = {
      lastUpdated: feed.lastUpdated,
      reliability: feed.reliability,
      data: {},
    };
    sources.push(feed.feedName);
  });

  return { cveId, enrichments, sources };
};

// ============================================================================
// SEQUELIZE ASSOCIATIONS
// ============================================================================

/**
 * Generates Sequelize associations for vulnerability intelligence.
 *
 * @returns {string} Sequelize association code
 *
 * @example
 * ```typescript
 * const associations = generateVulnerabilityIntelligenceAssociations();
 * ```
 */
export const generateVulnerabilityIntelligenceAssociations = (): string => {
  return `
// CVE to Threat Intelligence associations
CVE.hasMany(ThreatCorrelation, { foreignKey: 'cveId', as: 'threatCorrelations' });
ThreatCorrelation.belongsTo(CVE, { foreignKey: 'cveId' });

// CVE to Exploit Prediction associations
CVE.hasOne(ExploitPrediction, { foreignKey: 'cveId', as: 'exploitPrediction' });
ExploitPrediction.belongsTo(CVE, { foreignKey: 'cveId' });

// Zero-Day to CVE associations (eventual linking)
ZeroDayVulnerability.belongsTo(CVE, { foreignKey: 'cveId', as: 'assignedCVE' });
CVE.hasOne(ZeroDayVulnerability, { foreignKey: 'cveId', as: 'zeroDay' });

// Exploit Kit to CVE associations (many-to-many)
ExploitKit.belongsToMany(CVE, { through: 'ExploitKitCVEs', as: 'targetedVulnerabilities' });
CVE.belongsToMany(ExploitKit, { through: 'ExploitKitCVEs', as: 'exploitKits' });

// Intelligence Feed to CVE associations
IntelligenceFeed.hasMany(CVE, { foreignKey: 'sourceFeedId', as: 'vulnerabilities' });
CVE.belongsTo(IntelligenceFeed, { foreignKey: 'sourceFeedId', as: 'sourceFeed' });
`.trim();
};

// ============================================================================
// NESTJS PROVIDERS
// ============================================================================

/**
 * Generates NestJS provider for intelligence services.
 *
 * @returns {string} NestJS provider code
 *
 * @example
 * ```typescript
 * const provider = generateIntelligenceServiceProvider();
 * ```
 */
export const generateIntelligenceServiceProvider = (): string => {
  return `
import { Injectable } from '@nestjs/common';
import { InjectModel } from '@nestjs/sequelize';
import { ExploitPrediction } from './models/exploit-prediction.model';
import { ZeroDayVulnerability } from './models/zero-day.model';
import { ThreatCorrelation } from './models/threat-correlation.model';

@Injectable()
export class VulnerabilityIntelligenceService {
  constructor(
    @InjectModel(ExploitPrediction) private exploitPredictionModel: typeof ExploitPrediction,
    @InjectModel(ZeroDayVulnerability) private zeroDayModel: typeof ZeroDayVulnerability,
    @InjectModel(ThreatCorrelation) private threatCorrelationModel: typeof ThreatCorrelation,
  ) {}

  async predictExploit(cveId: string): Promise<ExploitPrediction> {
    // Prediction logic
    return this.exploitPredictionModel.findOne({ where: { cveId } });
  }

  async trackZeroDay(id: string): Promise<ZeroDayVulnerability> {
    return this.zeroDayModel.findByPk(id);
  }

  async getThreats Correlated(cveId: string): Promise<ThreatCorrelation[]> {
    return this.threatCorrelationModel.findAll({ where: { cveId } });
  }

  async generateIntelligenceReport(period: { start: Date; end: Date }): Promise<any> {
    // Report generation logic
    return {};
  }
}
`.trim();
};

// ============================================================================
// API ENDPOINTS
// ============================================================================

/**
 * Generates OpenAPI specification for vulnerability intelligence API.
 *
 * @returns {string} OpenAPI YAML specification
 *
 * @example
 * ```typescript
 * const apiSpec = generateVulnerabilityIntelligenceAPISpec();
 * ```
 */
export const generateVulnerabilityIntelligenceAPISpec = (): string => {
  return `
openapi: 3.0.0
info:
  title: Vulnerability Intelligence API
  version: 1.0.0
  description: API for vulnerability intelligence, exploit prediction, and threat correlation

paths:
  /api/intelligence/predict-exploit/{cveId}:
    get:
      summary: Predict exploit likelihood
      parameters:
        - name: cveId
          in: path
          required: true
          schema:
            type: string
      responses:
        '200':
          description: Exploit prediction
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ExploitPrediction'

  /api/intelligence/zero-days:
    get:
      summary: List zero-day vulnerabilities
      responses:
        '200':
          description: Zero-day vulnerabilities
          content:
            application/json:
              schema:
                type: array
                items:
                  $ref: '#/components/schemas/ZeroDayVulnerability'

  /api/intelligence/trends:
    get:
      summary: Get vulnerability trends
      parameters:
        - name: startDate
          in: query
          schema:
            type: string
            format: date
        - name: endDate
          in: query
          schema:
            type: string
            format: date
      responses:
        '200':
          description: Vulnerability trends
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/VulnerabilityTrend'

  /api/intelligence/correlate/{cveId}:
    get:
      summary: Correlate vulnerability with threats
      parameters:
        - name: cveId
          in: path
          required: true
          schema:
            type: string
      responses:
        '200':
          description: Threat correlations
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ThreatCorrelation'

components:
  schemas:
    ExploitPrediction:
      type: object
      properties:
        cveId:
          type: string
        exploitProbability:
          type: number
        timeToExploit:
          type: integer
        predictedExploitDate:
          type: string
          format: date-time

    ZeroDayVulnerability:
      type: object
      properties:
        id:
          type: string
        discoveryDate:
          type: string
          format: date-time
        severity:
          type: string
          enum: [CRITICAL, HIGH, MEDIUM, LOW]
        exploitationStatus:
          type: string
          enum: [IN_THE_WILD, POC_AVAILABLE, THEORETICAL]
`.trim();
};

// ============================================================================
// EXPORTS
// ============================================================================

export default {
  // Exploit prediction
  predictExploitLikelihood,
  calculateEPSSScore,
  assessWeaponizationPotential,

  // Zero-day tracking
  registerZeroDayVulnerability,
  trackZeroDayDisclosure,
  identifyZeroDayIndicators,

  // Trend analysis
  analyzeVulnerabilityTrends,
  predictVulnerabilityTrends,
  compareVulnerabilityTrends,

  // Exploit kit detection
  detectExploitKit,
  profileExploitKitCapabilities,

  // Threat correlation
  correlateVulnerabilityWithThreats,
  mapVulnerabilityToMITREATTACK,

  // NVD integration
  parseNVDFeedEntry,
  queryNVDDatabase,
  syncNVDFeed,
  extractCPEFromNVD,

  // Intelligence feeds
  aggregateIntelligenceFeeds,
  validateIntelligenceFeed,
  enrichVulnerabilityWithFeeds,

  // Code generation
  generateVulnerabilityIntelligenceAssociations,
  generateIntelligenceServiceProvider,
  generateVulnerabilityIntelligenceAPISpec,
};
