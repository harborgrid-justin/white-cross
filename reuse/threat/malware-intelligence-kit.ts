/**
 * LOC: MLIK1234567
 * File: /reuse/threat/malware-intelligence-kit.ts
 *
 * UPSTREAM (imports from):
 *   - None (leaf node - reusable utilities)
 *
 * DOWNSTREAM (imported by):
 *   - Threat intelligence services
 *   - Malware intelligence controllers
 *   - Security analytics systems
 */

/**
 * File: /reuse/threat/malware-intelligence-kit.ts
 * Locator: WC-UTL-MLIK-001
 * Purpose: Comprehensive Malware Intelligence Utilities - Trend analysis, prevalence scoring, variant detection, C2 tracking
 *
 * Upstream: Independent utility module for malware intelligence and threat analytics
 * Downstream: ../backend/threat/*, intelligence services, analytics dashboards
 * Dependencies: TypeScript 5.x, Node 18+, NestJS 10.x, Swagger/OpenAPI, Sequelize 6.x
 * Exports: 40 utility functions for malware trend analysis, prevalence scoring, variant detection, C2 tracking, kill chain mapping
 *
 * LLM Context: Comprehensive malware intelligence utilities for implementing production-ready threat analytics in White Cross system.
 * Provides malware trend analysis, prevalence scoring, variant detection, signature generation, C2 tracking, distribution analysis,
 * kill chain mapping, and intelligence correlation. Essential for building advanced threat intelligence and security operations capabilities.
 */

// ============================================================================
// TYPE DEFINITIONS
// ============================================================================

interface MalwareTrend {
  familyName: string;
  timeWindow: TimeWindow;
  sampleCount: number;
  growthRate: number;
  peakDate: Date;
  currentPrevalence: number;
  trendDirection: 'rising' | 'falling' | 'stable';
  impactScore: number;
}

interface TimeWindow {
  startDate: Date;
  endDate: Date;
  intervalType: 'hour' | 'day' | 'week' | 'month';
}

interface PrevalenceScore {
  malwareId: string;
  globalPrevalence: number;
  regionalPrevalence: Record<string, number>;
  sectorPrevalence: Record<string, number>;
  detectionRate: number;
  infectionRate: number;
  score: number; // 0-100
  rank: number;
}

interface MalwareVariant {
  variantId: string;
  parentFamily: string;
  sha256: string;
  firstSeen: Date;
  lastSeen: Date;
  similarity: number; // 0-1
  mutations: VariantMutation[];
  isActive: boolean;
  prevalence: number;
}

interface VariantMutation {
  type: 'code' | 'packer' | 'obfuscation' | 'payload' | 'c2' | 'persistence';
  description: string;
  offset?: number;
  severity: 'low' | 'medium' | 'high';
}

interface MalwareSignature {
  signatureId: string;
  signatureType: 'yara' | 'snort' | 'clamav' | 'custom';
  name: string;
  content: string;
  malwareFamily: string;
  confidence: number;
  falsePositiveRate: number;
  createdDate: Date;
  lastUpdated: Date;
  detectionCount: number;
}

interface C2Infrastructure {
  c2Id: string;
  type: 'domain' | 'ip' | 'url' | 'tor';
  value: string;
  port?: number;
  protocol: 'http' | 'https' | 'dns' | 'tcp' | 'udp' | 'custom';
  malwareFamilies: string[];
  firstSeen: Date;
  lastSeen: Date;
  isActive: boolean;
  reputation: number; // 0-100 (higher = more malicious)
  geolocation?: GeoLocation;
  asn?: string;
  registrar?: string;
}

interface GeoLocation {
  country: string;
  countryCode: string;
  region?: string;
  city?: string;
  latitude?: number;
  longitude?: number;
}

interface DistributionVector {
  vectorType: 'email' | 'web' | 'exploit' | 'removable_media' | 'network' | 'supply_chain' | 'social_engineering';
  description: string;
  malwareFamily: string;
  firstObserved: Date;
  lastObserved: Date;
  victimCount: number;
  successRate: number;
  targetedSectors: string[];
  targetedRegions: string[];
}

interface KillChainStage {
  stage: 'reconnaissance' | 'weaponization' | 'delivery' | 'exploitation' | 'installation' | 'command_control' | 'actions_on_objective';
  techniques: string[];
  mitreAttackIds: string[];
  indicators: string[];
  timestamp?: Date;
}

interface MalwareCampaign {
  campaignId: string;
  name: string;
  malwareFamilies: string[];
  threatActor?: string;
  startDate: Date;
  endDate?: Date;
  isActive: boolean;
  targets: CampaignTarget[];
  killChain: KillChainStage[];
  c2Infrastructure: string[];
  victimCount: number;
  impactScore: number;
}

interface CampaignTarget {
  targetType: 'sector' | 'organization' | 'region' | 'individual';
  name: string;
  attackCount: number;
  successRate: number;
}

interface ThreatIntelligence {
  intelId: string;
  source: string;
  confidence: 'low' | 'medium' | 'high' | 'confirmed';
  tlpLevel: 'white' | 'green' | 'amber' | 'red';
  malwareFamily?: string;
  indicators: ThreatIndicator[];
  description: string;
  publishedDate: Date;
  expirationDate?: Date;
}

interface ThreatIndicator {
  type: 'hash' | 'ip' | 'domain' | 'url' | 'email' | 'file' | 'registry' | 'mutex';
  value: string;
  context?: string;
}

interface MalwareCorrelation {
  primaryMalware: string;
  relatedMalware: string[];
  correlationType: 'c2_sharing' | 'code_similarity' | 'campaign' | 'threat_actor' | 'infrastructure';
  confidenceScore: number;
  evidence: string[];
}

// ============================================================================
// MALWARE TREND ANALYSIS
// ============================================================================

/**
 * Analyzes malware trends over a time window.
 *
 * @param {string} familyName - Malware family name
 * @param {TimeWindow} timeWindow - Time window for analysis
 * @param {number[]} sampleCounts - Array of sample counts per interval
 * @returns {MalwareTrend} Trend analysis result
 *
 * @example
 * ```typescript
 * const trend = analyzeMalwareTrend('Emotet',
 *   { startDate: new Date('2025-01-01'), endDate: new Date('2025-01-31'), intervalType: 'day' },
 *   [100, 120, 150, 180, 200, ...]
 * );
 * // Result: { familyName: 'Emotet', growthRate: 0.15, trendDirection: 'rising', ... }
 * ```
 */
export const analyzeMalwareTrend = (
  familyName: string,
  timeWindow: TimeWindow,
  sampleCounts: number[],
): MalwareTrend => {
  const totalSamples = sampleCounts.reduce((sum, count) => sum + count, 0);
  const avgCount = totalSamples / sampleCounts.length;

  // Calculate growth rate
  const firstHalfAvg = sampleCounts.slice(0, Math.floor(sampleCounts.length / 2))
    .reduce((sum, count) => sum + count, 0) / Math.floor(sampleCounts.length / 2);
  const secondHalfAvg = sampleCounts.slice(Math.floor(sampleCounts.length / 2))
    .reduce((sum, count) => sum + count, 0) / Math.ceil(sampleCounts.length / 2);

  const growthRate = (secondHalfAvg - firstHalfAvg) / firstHalfAvg;

  // Determine trend direction
  let trendDirection: 'rising' | 'falling' | 'stable';
  if (growthRate > 0.1) {
    trendDirection = 'rising';
  } else if (growthRate < -0.1) {
    trendDirection = 'falling';
  } else {
    trendDirection = 'stable';
  }

  // Find peak date
  const peakIndex = sampleCounts.indexOf(Math.max(...sampleCounts));
  const peakDate = calculateDateForIndex(timeWindow, peakIndex);

  // Calculate impact score
  const impactScore = Math.min(100, Math.round(avgCount * (1 + Math.abs(growthRate)) * 0.5));

  return {
    familyName,
    timeWindow,
    sampleCount: totalSamples,
    growthRate: Math.round(growthRate * 100) / 100,
    peakDate,
    currentPrevalence: sampleCounts[sampleCounts.length - 1],
    trendDirection,
    impactScore,
  };
};

/**
 * Calculates date for a given index in a time window.
 *
 * @param {TimeWindow} timeWindow - Time window
 * @param {number} index - Index in the time window
 * @returns {Date} Calculated date
 */
const calculateDateForIndex = (timeWindow: TimeWindow, index: number): Date => {
  const millisecondsPerInterval = {
    hour: 3600000,
    day: 86400000,
    week: 604800000,
    month: 2592000000, // Approximate
  };

  const intervalMs = millisecondsPerInterval[timeWindow.intervalType];
  return new Date(timeWindow.startDate.getTime() + (index * intervalMs));
};

/**
 * Detects emerging malware families based on growth patterns.
 *
 * @param {MalwareTrend[]} trends - Array of malware trends
 * @param {number} [growthThreshold] - Minimum growth rate to be considered emerging (default: 0.5)
 * @returns {MalwareTrend[]} Emerging malware families
 *
 * @example
 * ```typescript
 * const emerging = detectEmergingMalware(trends, 0.5);
 * // Result: [{ familyName: 'NewTrojan', growthRate: 1.2, ... }, ...]
 * ```
 */
export const detectEmergingMalware = (
  trends: MalwareTrend[],
  growthThreshold: number = 0.5,
): MalwareTrend[] => {
  return trends
    .filter(trend => trend.growthRate >= growthThreshold && trend.trendDirection === 'rising')
    .sort((a, b) => b.growthRate - a.growthRate);
};

/**
 * Identifies declining malware families.
 *
 * @param {MalwareTrend[]} trends - Array of malware trends
 * @param {number} [declineThreshold] - Maximum growth rate to be considered declining (default: -0.3)
 * @returns {MalwareTrend[]} Declining malware families
 *
 * @example
 * ```typescript
 * const declining = identifyDecliningMalware(trends, -0.3);
 * // Result: [{ familyName: 'OldWorm', growthRate: -0.6, ... }, ...]
 * ```
 */
export const identifyDecliningMalware = (
  trends: MalwareTrend[],
  declineThreshold: number = -0.3,
): MalwareTrend[] => {
  return trends
    .filter(trend => trend.growthRate <= declineThreshold && trend.trendDirection === 'falling')
    .sort((a, b) => a.growthRate - b.growthRate);
};

/**
 * Compares malware trends across multiple families.
 *
 * @param {MalwareTrend[]} trends - Array of malware trends
 * @returns {Record<string, any>} Comparative analysis
 *
 * @example
 * ```typescript
 * const comparison = compareMalwareTrends(trends);
 * // Result: { topGrowing: 'Emotet', topDeclining: 'Zeus', avgGrowthRate: 0.15, ... }
 * ```
 */
export const compareMalwareTrends = (trends: MalwareTrend[]): Record<string, any> => {
  if (trends.length === 0) {
    return { topGrowing: null, topDeclining: null, avgGrowthRate: 0 };
  }

  const sorted = [...trends].sort((a, b) => b.growthRate - a.growthRate);
  const avgGrowthRate = trends.reduce((sum, t) => sum + t.growthRate, 0) / trends.length;
  const totalSamples = trends.reduce((sum, t) => sum + t.sampleCount, 0);

  return {
    topGrowing: sorted[0].familyName,
    topDeclining: sorted[sorted.length - 1].familyName,
    avgGrowthRate: Math.round(avgGrowthRate * 100) / 100,
    totalSamples,
    activeFamilies: trends.filter(t => t.trendDirection !== 'falling').length,
  };
};

// ============================================================================
// PREVALENCE SCORING
// ============================================================================

/**
 * Calculates malware prevalence score.
 *
 * @param {number} globalSamples - Global sample count
 * @param {number} totalGlobalMalware - Total global malware samples
 * @param {number} detectionRate - Detection rate (0-1)
 * @param {number} infectionRate - Infection rate (0-1)
 * @returns {PrevalenceScore} Prevalence score object
 *
 * @example
 * ```typescript
 * const score = calculatePrevalenceScore('malware123', 5000, 100000, 0.85, 0.15);
 * // Result: { malwareId: 'malware123', globalPrevalence: 5.0, score: 68, ... }
 * ```
 */
export const calculatePrevalenceScore = (
  malwareId: string,
  globalSamples: number,
  totalGlobalMalware: number,
  detectionRate: number,
  infectionRate: number,
): Partial<PrevalenceScore> => {
  const globalPrevalence = (globalSamples / totalGlobalMalware) * 100;

  // Calculate composite score
  const score = Math.min(100, Math.round(
    (globalPrevalence * 0.4) +
    (detectionRate * 100 * 0.3) +
    (infectionRate * 100 * 0.3)
  ));

  return {
    malwareId,
    globalPrevalence: Math.round(globalPrevalence * 100) / 100,
    detectionRate,
    infectionRate,
    score,
    regionalPrevalence: {},
    sectorPrevalence: {},
  };
};

/**
 * Ranks malware by prevalence scores.
 *
 * @param {PrevalenceScore[]} scores - Array of prevalence scores
 * @returns {PrevalenceScore[]} Ranked prevalence scores
 *
 * @example
 * ```typescript
 * const ranked = rankMalwareByPrevalence(scores);
 * // Result: [{ malwareId: 'a', rank: 1, score: 95, ... }, { malwareId: 'b', rank: 2, score: 82, ... }]
 * ```
 */
export const rankMalwareByPrevalence = (scores: PrevalenceScore[]): PrevalenceScore[] => {
  const sorted = [...scores].sort((a, b) => b.score - a.score);

  return sorted.map((score, index) => ({
    ...score,
    rank: index + 1,
  }));
};

/**
 * Calculates regional prevalence distribution.
 *
 * @param {Record<string, number>} regionalSamples - Regional sample counts
 * @param {number} totalSamples - Total sample count
 * @returns {Record<string, number>} Regional prevalence percentages
 *
 * @example
 * ```typescript
 * const distribution = calculateRegionalPrevalence(
 *   { 'North America': 5000, 'Europe': 3000, 'Asia': 2000 },
 *   10000
 * );
 * // Result: { 'North America': 50.0, 'Europe': 30.0, 'Asia': 20.0 }
 * ```
 */
export const calculateRegionalPrevalence = (
  regionalSamples: Record<string, number>,
  totalSamples: number,
): Record<string, number> => {
  const prevalence: Record<string, number> = {};

  for (const [region, samples] of Object.entries(regionalSamples)) {
    prevalence[region] = Math.round((samples / totalSamples) * 10000) / 100;
  }

  return prevalence;
};

/**
 * Calculates sector-specific prevalence distribution.
 *
 * @param {Record<string, number>} sectorSamples - Sector sample counts
 * @param {number} totalSamples - Total sample count
 * @returns {Record<string, number>} Sector prevalence percentages
 *
 * @example
 * ```typescript
 * const distribution = calculateSectorPrevalence(
 *   { 'Healthcare': 4000, 'Finance': 3500, 'Government': 2500 },
 *   10000
 * );
 * // Result: { 'Healthcare': 40.0, 'Finance': 35.0, 'Government': 25.0 }
 * ```
 */
export const calculateSectorPrevalence = (
  sectorSamples: Record<string, number>,
  totalSamples: number,
): Record<string, number> => {
  const prevalence: Record<string, number> = {};

  for (const [sector, samples] of Object.entries(sectorSamples)) {
    prevalence[sector] = Math.round((samples / totalSamples) * 10000) / 100;
  }

  return prevalence;
};

// ============================================================================
// VARIANT DETECTION
// ============================================================================

/**
 * Detects malware variants based on similarity threshold.
 *
 * @param {string} parentFamily - Parent malware family
 * @param {string} sha256 - SHA256 hash of potential variant
 * @param {number} similarity - Similarity score (0-1)
 * @param {VariantMutation[]} mutations - Array of detected mutations
 * @returns {MalwareVariant} Malware variant object
 *
 * @example
 * ```typescript
 * const variant = detectMalwareVariant('Emotet', 'abc123...', 0.85,
 *   [{ type: 'packer', description: 'Changed to UPX', severity: 'low' }]
 * );
 * ```
 */
export const detectMalwareVariant = (
  parentFamily: string,
  sha256: string,
  similarity: number,
  mutations: VariantMutation[],
): Partial<MalwareVariant> => {
  const variantId = `${parentFamily}_variant_${sha256.substring(0, 8)}`;

  return {
    variantId,
    parentFamily,
    sha256,
    firstSeen: new Date(),
    lastSeen: new Date(),
    similarity,
    mutations,
    isActive: true,
    prevalence: 0,
  };
};

/**
 * Calculates code similarity between two malware samples.
 *
 * @param {string} hash1 - First malware hash
 * @param {string} hash2 - Second malware hash
 * @param {string[]} commonStrings - Common strings found in both samples
 * @param {number} totalStrings - Total unique strings across both samples
 * @returns {number} Similarity score (0-1)
 *
 * @example
 * ```typescript
 * const similarity = calculateCodeSimilarity('hash1', 'hash2',
 *   ['malicious', 'encrypt', 'download'], 10
 * );
 * // Result: 0.30
 * ```
 */
export const calculateCodeSimilarity = (
  hash1: string,
  hash2: string,
  commonStrings: string[],
  totalStrings: number,
): number => {
  if (hash1 === hash2) return 1.0;
  if (totalStrings === 0) return 0.0;

  const similarity = commonStrings.length / totalStrings;
  return Math.round(similarity * 100) / 100;
};

/**
 * Identifies mutation types in malware variant.
 *
 * @param {string} originalHash - Original malware hash
 * @param {string} variantHash - Variant malware hash
 * @param {string[]} differences - Array of detected differences
 * @returns {VariantMutation[]} Array of identified mutations
 *
 * @example
 * ```typescript
 * const mutations = identifyVariantMutations('original', 'variant',
 *   ['packer changed', 'new C2 domain', 'obfuscation added']
 * );
 * // Result: [{ type: 'packer', description: 'packer changed', severity: 'low' }, ...]
 * ```
 */
export const identifyVariantMutations = (
  originalHash: string,
  variantHash: string,
  differences: string[],
): VariantMutation[] => {
  const mutations: VariantMutation[] = [];

  const mutationPatterns: Record<string, { type: VariantMutation['type']; severity: VariantMutation['severity'] }> = {
    'packer': { type: 'packer', severity: 'low' },
    'obfuscation': { type: 'obfuscation', severity: 'medium' },
    'c2': { type: 'c2', severity: 'high' },
    'payload': { type: 'payload', severity: 'high' },
    'persistence': { type: 'persistence', severity: 'medium' },
    'code': { type: 'code', severity: 'medium' },
  };

  for (const diff of differences) {
    const lowerDiff = diff.toLowerCase();

    for (const [pattern, mutation] of Object.entries(mutationPatterns)) {
      if (lowerDiff.includes(pattern)) {
        mutations.push({
          type: mutation.type,
          description: diff,
          severity: mutation.severity,
        });
        break;
      }
    }
  }

  return mutations;
};

/**
 * Groups malware variants by similarity clusters.
 *
 * @param {MalwareVariant[]} variants - Array of malware variants
 * @param {number} [similarityThreshold] - Minimum similarity for clustering (default: 0.7)
 * @returns {Record<string, MalwareVariant[]>} Clustered variants
 *
 * @example
 * ```typescript
 * const clusters = clusterMalwareVariants(variants, 0.7);
 * // Result: { 'cluster1': [variant1, variant2], 'cluster2': [variant3, variant4] }
 * ```
 */
export const clusterMalwareVariants = (
  variants: MalwareVariant[],
  similarityThreshold: number = 0.7,
): Record<string, MalwareVariant[]> => {
  const clusters: Record<string, MalwareVariant[]> = {};
  let clusterIndex = 0;

  for (const variant of variants) {
    let addedToCluster = false;

    for (const [clusterId, clusterVariants] of Object.entries(clusters)) {
      // Check if variant is similar to any variant in cluster
      const isSimilar = clusterVariants.some(cv => cv.similarity >= similarityThreshold);

      if (isSimilar) {
        clusters[clusterId].push(variant);
        addedToCluster = true;
        break;
      }
    }

    if (!addedToCluster) {
      const newClusterId = `cluster_${clusterIndex++}`;
      clusters[newClusterId] = [variant];
    }
  }

  return clusters;
};

// ============================================================================
// MALWARE SIGNATURE GENERATION
// ============================================================================

/**
 * Generates YARA signature from malware sample characteristics.
 *
 * @param {string} malwareFamily - Malware family name
 * @param {string[]} uniqueStrings - Unique strings found in malware
 * @param {string[]} hexPatterns - Hex patterns for detection
 * @returns {MalwareSignature} Generated malware signature
 *
 * @example
 * ```typescript
 * const signature = generateYaraSignature('Emotet',
 *   ['C2_connect', 'encrypt_payload'],
 *   ['4D5A', '504B0304']
 * );
 * ```
 */
export const generateYaraSignature = (
  malwareFamily: string,
  uniqueStrings: string[],
  hexPatterns: string[],
): Partial<MalwareSignature> => {
  const signatureId = `YARA_${malwareFamily}_${Date.now()}`;
  const ruleName = `${malwareFamily.replace(/\s+/g, '_')}_Detection`;

  let content = `rule ${ruleName} {\n`;
  content += `  meta:\n`;
  content += `    author = "Automated Signature Generation"\n`;
  content += `    description = "Detects ${malwareFamily} malware"\n`;
  content += `    date = "${new Date().toISOString().split('T')[0]}"\n`;
  content += `  strings:\n`;

  uniqueStrings.forEach((str, index) => {
    content += `    $str${index} = "${str}" ascii wide\n`;
  });

  hexPatterns.forEach((hex, index) => {
    content += `    $hex${index} = { ${hex} }\n`;
  });

  content += `  condition:\n`;
  content += `    any of them\n`;
  content += `}\n`;

  return {
    signatureId,
    signatureType: 'yara',
    name: ruleName,
    content,
    malwareFamily,
    confidence: 0.75,
    falsePositiveRate: 0.05,
    createdDate: new Date(),
    lastUpdated: new Date(),
    detectionCount: 0,
  };
};

/**
 * Validates malware signature effectiveness.
 *
 * @param {MalwareSignature} signature - Malware signature
 * @param {number} truePositives - True positive detections
 * @param {number} falsePositives - False positive detections
 * @param {number} totalSamples - Total samples tested
 * @returns {{ confidence: number; falsePositiveRate: number; isEffective: boolean }} Validation result
 *
 * @example
 * ```typescript
 * const validation = validateSignatureEffectiveness(signature, 95, 5, 100);
 * // Result: { confidence: 0.95, falsePositiveRate: 0.05, isEffective: true }
 * ```
 */
export const validateSignatureEffectiveness = (
  signature: MalwareSignature,
  truePositives: number,
  falsePositives: number,
  totalSamples: number,
): { confidence: number; falsePositiveRate: number; isEffective: boolean } => {
  const confidence = truePositives / totalSamples;
  const falsePositiveRate = falsePositives / totalSamples;

  return {
    confidence: Math.round(confidence * 100) / 100,
    falsePositiveRate: Math.round(falsePositiveRate * 100) / 100,
    isEffective: confidence >= 0.8 && falsePositiveRate <= 0.1,
  };
};

/**
 * Updates signature detection statistics.
 *
 * @param {MalwareSignature} signature - Malware signature
 * @param {number} newDetections - Number of new detections
 * @returns {MalwareSignature} Updated signature
 *
 * @example
 * ```typescript
 * const updated = updateSignatureDetectionCount(signature, 25);
 * // Increments detection count and updates lastUpdated
 * ```
 */
export const updateSignatureDetectionCount = (
  signature: MalwareSignature,
  newDetections: number,
): MalwareSignature => {
  return {
    ...signature,
    detectionCount: signature.detectionCount + newDetections,
    lastUpdated: new Date(),
  };
};

// ============================================================================
// C2 INFRASTRUCTURE TRACKING
// ============================================================================

/**
 * Creates C2 infrastructure record.
 *
 * @param {string} type - C2 type (domain, IP, URL, tor)
 * @param {string} value - C2 value
 * @param {string[]} malwareFamilies - Associated malware families
 * @param {number} reputation - Reputation score (0-100)
 * @returns {Partial<C2Infrastructure>} C2 infrastructure object
 *
 * @example
 * ```typescript
 * const c2 = createC2Infrastructure('domain', 'evil.com', ['Emotet', 'TrickBot'], 95);
 * ```
 */
export const createC2Infrastructure = (
  type: 'domain' | 'ip' | 'url' | 'tor',
  value: string,
  malwareFamilies: string[],
  reputation: number,
): Partial<C2Infrastructure> => {
  const c2Id = `c2_${type}_${value.replace(/[^a-zA-Z0-9]/g, '_')}`;

  return {
    c2Id,
    type,
    value,
    protocol: 'https',
    malwareFamilies,
    firstSeen: new Date(),
    lastSeen: new Date(),
    isActive: true,
    reputation: Math.min(100, Math.max(0, reputation)),
  };
};

/**
 * Tracks C2 communication patterns.
 *
 * @param {string} c2Id - C2 infrastructure ID
 * @param {number[]} communicationTimestamps - Array of communication timestamps (ms)
 * @returns {{ beaconInterval: number; regularity: number; isBeaconing: boolean }} Pattern analysis
 *
 * @example
 * ```typescript
 * const pattern = trackC2Communication('c2_123', [1000, 2000, 3000, 4000]);
 * // Result: { beaconInterval: 1000, regularity: 1.0, isBeaconing: true }
 * ```
 */
export const trackC2Communication = (
  c2Id: string,
  communicationTimestamps: number[],
): { beaconInterval: number; regularity: number; isBeaconing: boolean } => {
  if (communicationTimestamps.length < 2) {
    return { beaconInterval: 0, regularity: 0, isBeaconing: false };
  }

  const intervals: number[] = [];
  for (let i = 1; i < communicationTimestamps.length; i++) {
    intervals.push(communicationTimestamps[i] - communicationTimestamps[i - 1]);
  }

  const avgInterval = intervals.reduce((sum, interval) => sum + interval, 0) / intervals.length;
  const variance = intervals.reduce((sum, interval) => sum + Math.pow(interval - avgInterval, 2), 0) / intervals.length;
  const stdDev = Math.sqrt(variance);

  const regularity = 1 - Math.min(1, stdDev / avgInterval);
  const isBeaconing = regularity >= 0.8;

  return {
    beaconInterval: Math.round(avgInterval),
    regularity: Math.round(regularity * 100) / 100,
    isBeaconing,
  };
};

/**
 * Identifies shared C2 infrastructure across malware families.
 *
 * @param {C2Infrastructure[]} c2List - Array of C2 infrastructure
 * @returns {Record<string, string[]>} Map of C2 IDs to malware families
 *
 * @example
 * ```typescript
 * const shared = identifySharedC2Infrastructure(c2List);
 * // Result: { 'c2_1': ['Emotet', 'TrickBot'], 'c2_2': ['Zeus', 'Dridex'] }
 * ```
 */
export const identifySharedC2Infrastructure = (
  c2List: C2Infrastructure[],
): Record<string, string[]> => {
  const sharedC2: Record<string, string[]> = {};

  for (const c2 of c2List) {
    if (c2.malwareFamilies.length > 1) {
      sharedC2[c2.c2Id] = c2.malwareFamilies;
    }
  }

  return sharedC2;
};

/**
 * Calculates C2 reputation score based on malicious activity.
 *
 * @param {number} malwareFamilyCount - Number of associated malware families
 * @param {number} infectionCount - Number of infections attributed to C2
 * @param {number} ageInDays - Age of C2 in days
 * @returns {number} Reputation score (0-100, higher = more malicious)
 *
 * @example
 * ```typescript
 * const reputation = calculateC2Reputation(5, 1000, 30);
 * // Result: 92
 * ```
 */
export const calculateC2Reputation = (
  malwareFamilyCount: number,
  infectionCount: number,
  ageInDays: number,
): number => {
  let score = 0;

  score += Math.min(40, malwareFamilyCount * 8);
  score += Math.min(40, Math.log10(infectionCount + 1) * 10);
  score += Math.min(20, ageInDays * 0.5);

  return Math.min(100, Math.round(score));
};

// ============================================================================
// DISTRIBUTION ANALYSIS
// ============================================================================

/**
 * Analyzes malware distribution vectors.
 *
 * @param {DistributionVector[]} vectors - Array of distribution vectors
 * @returns {Record<string, any>} Distribution analysis
 *
 * @example
 * ```typescript
 * const analysis = analyzeDistributionVectors(vectors);
 * // Result: { mostCommon: 'email', totalVictims: 5000, avgSuccessRate: 0.35, ... }
 * ```
 */
export const analyzeDistributionVectors = (
  vectors: DistributionVector[],
): Record<string, any> => {
  if (vectors.length === 0) {
    return { mostCommon: null, totalVictims: 0, avgSuccessRate: 0 };
  }

  const vectorCounts: Record<string, number> = {};
  const totalVictims = vectors.reduce((sum, v) => sum + v.victimCount, 0);
  const avgSuccessRate = vectors.reduce((sum, v) => sum + v.successRate, 0) / vectors.length;

  for (const vector of vectors) {
    vectorCounts[vector.vectorType] = (vectorCounts[vector.vectorType] || 0) + 1;
  }

  const mostCommon = Object.entries(vectorCounts)
    .sort(([, a], [, b]) => b - a)[0][0];

  return {
    mostCommon,
    totalVictims,
    avgSuccessRate: Math.round(avgSuccessRate * 100) / 100,
    vectorDistribution: vectorCounts,
  };
};

/**
 * Identifies targeted sectors from distribution data.
 *
 * @param {DistributionVector[]} vectors - Array of distribution vectors
 * @returns {Record<string, number>} Sector targeting frequency
 *
 * @example
 * ```typescript
 * const sectors = identifyTargetedSectors(vectors);
 * // Result: { 'Healthcare': 150, 'Finance': 120, 'Government': 80 }
 * ```
 */
export const identifyTargetedSectors = (
  vectors: DistributionVector[],
): Record<string, number> => {
  const sectorCounts: Record<string, number> = {};

  for (const vector of vectors) {
    for (const sector of vector.targetedSectors) {
      sectorCounts[sector] = (sectorCounts[sector] || 0) + 1;
    }
  }

  return sectorCounts;
};

/**
 * Calculates distribution effectiveness score.
 *
 * @param {number} victimCount - Number of victims
 * @param {number} attemptCount - Number of distribution attempts
 * @param {number} successRate - Success rate (0-1)
 * @returns {number} Effectiveness score (0-100)
 *
 * @example
 * ```typescript
 * const effectiveness = calculateDistributionEffectiveness(500, 1000, 0.5);
 * // Result: 75
 * ```
 */
export const calculateDistributionEffectiveness = (
  victimCount: number,
  attemptCount: number,
  successRate: number,
): number => {
  const conversionRate = victimCount / attemptCount;
  const score = (conversionRate * 50) + (successRate * 50);

  return Math.min(100, Math.round(score));
};

// ============================================================================
// KILL CHAIN MAPPING
// ============================================================================

/**
 * Maps malware behavior to cyber kill chain stages.
 *
 * @param {string[]} techniques - Array of observed techniques
 * @param {string[]} mitreAttackIds - Array of MITRE ATT&CK IDs
 * @returns {KillChainStage[]} Array of kill chain stages
 *
 * @example
 * ```typescript
 * const stages = mapToKillChain(
 *   ['Spear Phishing', 'Exploit Public-Facing Application', 'Command and Control'],
 *   ['T1566.001', 'T1190', 'T1071']
 * );
 * // Result: [{ stage: 'delivery', techniques: [...], ... }, ...]
 * ```
 */
export const mapToKillChain = (
  techniques: string[],
  mitreAttackIds: string[],
): KillChainStage[] => {
  const stageMapping: Record<string, KillChainStage['stage']> = {
    'reconnaissance': 'reconnaissance',
    'weaponization': 'weaponization',
    'phishing': 'delivery',
    'delivery': 'delivery',
    'exploit': 'exploitation',
    'execution': 'exploitation',
    'installation': 'installation',
    'persistence': 'installation',
    'command': 'command_control',
    'control': 'command_control',
    'exfiltration': 'actions_on_objective',
    'impact': 'actions_on_objective',
  };

  const stages: Map<KillChainStage['stage'], KillChainStage> = new Map();

  for (let i = 0; i < techniques.length; i++) {
    const technique = techniques[i];
    const lowerTechnique = technique.toLowerCase();

    for (const [keyword, stage] of Object.entries(stageMapping)) {
      if (lowerTechnique.includes(keyword)) {
        const existing = stages.get(stage) || {
          stage,
          techniques: [],
          mitreAttackIds: [],
          indicators: [],
        };

        existing.techniques.push(technique);
        if (i < mitreAttackIds.length) {
          existing.mitreAttackIds.push(mitreAttackIds[i]);
        }

        stages.set(stage, existing);
        break;
      }
    }
  }

  return Array.from(stages.values());
};

/**
 * Analyzes kill chain completeness for malware campaign.
 *
 * @param {KillChainStage[]} stages - Array of kill chain stages
 * @returns {{ completeness: number; missingStages: string[]; coverage: number }} Analysis result
 *
 * @example
 * ```typescript
 * const analysis = analyzeKillChainCompleteness(stages);
 * // Result: { completeness: 0.85, missingStages: ['reconnaissance'], coverage: 6 }
 * ```
 */
export const analyzeKillChainCompleteness = (
  stages: KillChainStage[],
): { completeness: number; missingStages: string[]; coverage: number } => {
  const allStages: KillChainStage['stage'][] = [
    'reconnaissance',
    'weaponization',
    'delivery',
    'exploitation',
    'installation',
    'command_control',
    'actions_on_objective',
  ];

  const presentStages = new Set(stages.map(s => s.stage));
  const missingStages = allStages.filter(s => !presentStages.has(s));

  const completeness = presentStages.size / allStages.length;
  const coverage = presentStages.size;

  return {
    completeness: Math.round(completeness * 100) / 100,
    missingStages,
    coverage,
  };
};

/**
 * Generates kill chain visualization data.
 *
 * @param {KillChainStage[]} stages - Array of kill chain stages
 * @returns {Record<string, any>} Visualization data
 *
 * @example
 * ```typescript
 * const vizData = generateKillChainVisualization(stages);
 * // Result: { stages: [...], connections: [...], techniqueCount: 15 }
 * ```
 */
export const generateKillChainVisualization = (
  stages: KillChainStage[],
): Record<string, any> => {
  const techniqueCount = stages.reduce((sum, s) => sum + s.techniques.length, 0);
  const stageNames = stages.map(s => s.stage);

  return {
    stages: stages.map(s => ({
      name: s.stage,
      techniqueCount: s.techniques.length,
      mitreCount: s.mitreAttackIds.length,
    })),
    connections: stageNames.slice(0, -1).map((stage, i) => ({
      from: stage,
      to: stageNames[i + 1],
    })),
    techniqueCount,
  };
};

// ============================================================================
// MALWARE CAMPAIGN TRACKING
// ============================================================================

/**
 * Creates malware campaign record.
 *
 * @param {string} name - Campaign name
 * @param {string[]} malwareFamilies - Associated malware families
 * @param {CampaignTarget[]} targets - Campaign targets
 * @returns {Partial<MalwareCampaign>} Campaign object
 *
 * @example
 * ```typescript
 * const campaign = createMalwareCampaign('Operation X',
 *   ['Emotet', 'TrickBot'],
 *   [{ targetType: 'sector', name: 'Healthcare', attackCount: 50, successRate: 0.4 }]
 * );
 * ```
 */
export const createMalwareCampaign = (
  name: string,
  malwareFamilies: string[],
  targets: CampaignTarget[],
): Partial<MalwareCampaign> => {
  const campaignId = `campaign_${name.replace(/\s+/g, '_')}_${Date.now()}`;

  return {
    campaignId,
    name,
    malwareFamilies,
    startDate: new Date(),
    isActive: true,
    targets,
    killChain: [],
    c2Infrastructure: [],
    victimCount: 0,
    impactScore: 0,
  };
};

/**
 * Calculates campaign impact score.
 *
 * @param {number} victimCount - Number of victims
 * @param {CampaignTarget[]} targets - Campaign targets
 * @param {number} duration - Campaign duration in days
 * @returns {number} Impact score (0-100)
 *
 * @example
 * ```typescript
 * const impact = calculateCampaignImpact(1000, targets, 30);
 * // Result: 78
 * ```
 */
export const calculateCampaignImpact = (
  victimCount: number,
  targets: CampaignTarget[],
  duration: number,
): number => {
  let score = 0;

  // Victim count impact (max 40 points)
  score += Math.min(40, Math.log10(victimCount + 1) * 10);

  // Target diversity (max 30 points)
  score += Math.min(30, targets.length * 5);

  // Campaign persistence (max 30 points)
  score += Math.min(30, duration * 0.5);

  return Math.min(100, Math.round(score));
};

/**
 * Correlates multiple malware families in campaigns.
 *
 * @param {string} primaryMalware - Primary malware family
 * @param {string[]} relatedMalware - Related malware families
 * @param {'c2_sharing' | 'code_similarity' | 'campaign' | 'threat_actor' | 'infrastructure'} correlationType - Type of correlation
 * @param {string[]} evidence - Evidence of correlation
 * @returns {MalwareCorrelation} Correlation object
 *
 * @example
 * ```typescript
 * const correlation = correlateMalwareFamilies('Emotet', ['TrickBot', 'Ryuk'],
 *   'campaign', ['Shared C2 infrastructure', 'Sequential deployment']
 * );
 * ```
 */
export const correlateMalwareFamilies = (
  primaryMalware: string,
  relatedMalware: string[],
  correlationType: 'c2_sharing' | 'code_similarity' | 'campaign' | 'threat_actor' | 'infrastructure',
  evidence: string[],
): MalwareCorrelation => {
  const confidenceScore = Math.min(1.0, evidence.length * 0.2);

  return {
    primaryMalware,
    relatedMalware,
    correlationType,
    confidenceScore: Math.round(confidenceScore * 100) / 100,
    evidence,
  };
};

// ============================================================================
// THREAT INTELLIGENCE INTEGRATION
// ============================================================================

/**
 * Creates threat intelligence report.
 *
 * @param {string} source - Intelligence source
 * @param {'low' | 'medium' | 'high' | 'confirmed'} confidence - Confidence level
 * @param {'white' | 'green' | 'amber' | 'red'} tlpLevel - Traffic Light Protocol level
 * @param {ThreatIndicator[]} indicators - Threat indicators
 * @param {string} description - Report description
 * @returns {Partial<ThreatIntelligence>} Threat intelligence object
 *
 * @example
 * ```typescript
 * const intel = createThreatIntelReport('OSINT', 'high', 'amber',
 *   [{ type: 'hash', value: 'abc123...', context: 'Malware sample' }],
 *   'New Emotet campaign detected'
 * );
 * ```
 */
export const createThreatIntelReport = (
  source: string,
  confidence: 'low' | 'medium' | 'high' | 'confirmed',
  tlpLevel: 'white' | 'green' | 'amber' | 'red',
  indicators: ThreatIndicator[],
  description: string,
): Partial<ThreatIntelligence> => {
  const intelId = `intel_${source}_${Date.now()}`;

  return {
    intelId,
    source,
    confidence,
    tlpLevel,
    indicators,
    description,
    publishedDate: new Date(),
  };
};

/**
 * Validates threat intelligence freshness.
 *
 * @param {ThreatIntelligence} intel - Threat intelligence object
 * @param {number} [maxAgeInDays] - Maximum age in days (default: 90)
 * @returns {boolean} True if intelligence is fresh
 *
 * @example
 * ```typescript
 * const isFresh = validateIntelligenceFreshness(intel, 90);
 * // Result: true or false
 * ```
 */
export const validateIntelligenceFreshness = (
  intel: ThreatIntelligence,
  maxAgeInDays: number = 90,
): boolean => {
  const ageInMs = Date.now() - intel.publishedDate.getTime();
  const ageInDays = ageInMs / (1000 * 60 * 60 * 24);

  if (intel.expirationDate && Date.now() > intel.expirationDate.getTime()) {
    return false;
  }

  return ageInDays <= maxAgeInDays;
};

/**
 * Enriches malware data with threat intelligence.
 *
 * @param {string} malwareHash - Malware hash
 * @param {ThreatIntelligence[]} intelReports - Array of threat intelligence reports
 * @returns {Record<string, any>} Enriched malware data
 *
 * @example
 * ```typescript
 * const enriched = enrichMalwareWithIntelligence('abc123...', intelReports);
 * // Result: { hash: 'abc123...', intelMatches: 3, highConfidenceMatches: 2, ... }
 * ```
 */
export const enrichMalwareWithIntelligence = (
  malwareHash: string,
  intelReports: ThreatIntelligence[],
): Record<string, any> => {
  const matches = intelReports.filter(report =>
    report.indicators.some(indicator =>
      indicator.type === 'hash' && indicator.value === malwareHash
    )
  );

  const highConfidenceMatches = matches.filter(m => m.confidence === 'high' || m.confidence === 'confirmed');

  return {
    hash: malwareHash,
    intelMatches: matches.length,
    highConfidenceMatches: highConfidenceMatches.length,
    sources: [...new Set(matches.map(m => m.source))],
    malwareFamilies: [...new Set(matches.map(m => m.malwareFamily).filter(Boolean))],
  };
};

// ============================================================================
// SEQUELIZE QUERY UTILITIES
// ============================================================================

/**
 * Creates Sequelize query for malware trend analysis.
 *
 * @param {string} familyName - Malware family name
 * @param {Date} startDate - Start date
 * @param {Date} endDate - End date
 * @returns {Record<string, any>} Sequelize query
 *
 * @example
 * ```typescript
 * const query = createMalwareTrendQuery('Emotet', new Date('2025-01-01'), new Date('2025-01-31'));
 * const samples = await MalwareSample.findAll({ where: query });
 * ```
 */
export const createMalwareTrendQuery = (
  familyName: string,
  startDate: Date,
  endDate: Date,
): Record<string, any> => {
  return {
    malwareFamily: familyName,
    firstSeen: {
      $gte: startDate,
      $lte: endDate,
    },
  };
};

/**
 * Creates Sequelize query for C2 infrastructure search.
 *
 * @param {string} [type] - C2 type filter
 * @param {boolean} [activeOnly] - Filter only active C2
 * @param {number} [minReputation] - Minimum reputation score
 * @returns {Record<string, any>} Sequelize query
 *
 * @example
 * ```typescript
 * const query = createC2InfrastructureQuery('domain', true, 80);
 * const c2List = await C2Infrastructure.findAll({ where: query });
 * ```
 */
export const createC2InfrastructureQuery = (
  type?: string,
  activeOnly?: boolean,
  minReputation?: number,
): Record<string, any> => {
  const where: Record<string, any> = {};

  if (type) where.type = type;
  if (activeOnly) where.isActive = true;
  if (minReputation !== undefined) {
    where.reputation = { $gte: minReputation };
  }

  return where;
};

/**
 * Creates Sequelize query for malware campaign search.
 *
 * @param {boolean} [activeOnly] - Filter only active campaigns
 * @param {string} [threatActor] - Threat actor filter
 * @returns {Record<string, any>} Sequelize query
 *
 * @example
 * ```typescript
 * const query = createMalwareCampaignQuery(true, 'APT28');
 * const campaigns = await MalwareCampaign.findAll({ where: query });
 * ```
 */
export const createMalwareCampaignQuery = (
  activeOnly?: boolean,
  threatActor?: string,
): Record<string, any> => {
  const where: Record<string, any> = {};

  if (activeOnly) where.isActive = true;
  if (threatActor) where.threatActor = threatActor;

  return where;
};

// ============================================================================
// NESTJS PROVIDER UTILITIES
// ============================================================================

/**
 * Creates NestJS provider for malware intelligence analytics.
 *
 * @param {MalwareTrend[]} trends - Array of malware trends
 * @returns {Record<string, any>} Analytics dashboard data
 *
 * @example
 * ```typescript
 * // In NestJS provider:
 * async getIntelligenceDashboard(): Promise<Record<string, any>> {
 *   const trends = await this.getTrends();
 *   return await provideIntelligenceAnalytics(trends);
 * }
 * ```
 */
export const provideIntelligenceAnalytics = async (
  trends: MalwareTrend[],
): Promise<Record<string, any>> => {
  const emerging = detectEmergingMalware(trends);
  const declining = identifyDecliningMalware(trends);
  const comparison = compareMalwareTrends(trends);

  return {
    totalFamilies: trends.length,
    emergingThreats: emerging.length,
    decliningThreats: declining.length,
    topGrowing: comparison.topGrowing,
    topDeclining: comparison.topDeclining,
    avgGrowthRate: comparison.avgGrowthRate,
    trends: trends.slice(0, 10), // Top 10 trends
  };
};

/**
 * Creates NestJS provider for C2 infrastructure monitoring.
 *
 * @param {C2Infrastructure[]} c2List - Array of C2 infrastructure
 * @returns {Record<string, any>} C2 monitoring data
 *
 * @example
 * ```typescript
 * // In NestJS provider:
 * async getC2Monitoring(): Promise<Record<string, any>> {
 *   const c2List = await this.getC2Infrastructure();
 *   return await provideC2Monitoring(c2List);
 * }
 * ```
 */
export const provideC2Monitoring = async (
  c2List: C2Infrastructure[],
): Promise<Record<string, any>> => {
  const activeC2 = c2List.filter(c2 => c2.isActive);
  const sharedC2 = identifySharedC2Infrastructure(c2List);
  const avgReputation = c2List.reduce((sum, c2) => sum + c2.reputation, 0) / c2List.length;

  return {
    totalC2: c2List.length,
    activeC2: activeC2.length,
    sharedInfrastructure: Object.keys(sharedC2).length,
    avgReputation: Math.round(avgReputation * 100) / 100,
    highRiskC2: c2List.filter(c2 => c2.reputation >= 80).length,
  };
};

/**
 * Creates NestJS provider for threat intelligence correlation.
 *
 * @param {string} malwareHash - Malware hash
 * @param {ThreatIntelligence[]} intelReports - Threat intelligence reports
 * @param {C2Infrastructure[]} c2List - C2 infrastructure list
 * @returns {Promise<Record<string, any>>} Correlated intelligence data
 *
 * @example
 * ```typescript
 * // In NestJS provider:
 * async getCorrelatedIntelligence(hash: string): Promise<Record<string, any>> {
 *   return await provideThreatCorrelation(hash, intelReports, c2List);
 * }
 * ```
 */
export const provideThreatCorrelation = async (
  malwareHash: string,
  intelReports: ThreatIntelligence[],
  c2List: C2Infrastructure[],
): Promise<Record<string, any>> => {
  const enriched = enrichMalwareWithIntelligence(malwareHash, intelReports);

  // Find related C2 infrastructure
  const relatedC2 = c2List.filter(c2 =>
    enriched.malwareFamilies.some(family => c2.malwareFamilies.includes(family))
  );

  return {
    ...enriched,
    relatedC2: relatedC2.length,
    c2Domains: relatedC2.filter(c2 => c2.type === 'domain').map(c2 => c2.value),
    c2IPs: relatedC2.filter(c2 => c2.type === 'ip').map(c2 => c2.value),
  };
};

// ============================================================================
// API ENDPOINT HELPERS
// ============================================================================

/**
 * Creates API endpoint response for malware trends.
 *
 * @param {MalwareTrend[]} trends - Array of malware trends
 * @param {number} page - Page number
 * @param {number} limit - Items per page
 * @returns {Record<string, any>} Paginated API response
 *
 * @example
 * ```typescript
 * @Get('/intelligence/trends')
 * async getTrends(@Query('page') page: number, @Query('limit') limit: number) {
 *   const trends = await this.getTrendData();
 *   return createTrendsApiResponse(trends, page, limit);
 * }
 * ```
 */
export const createTrendsApiResponse = (
  trends: MalwareTrend[],
  page: number = 1,
  limit: number = 20,
): Record<string, any> => {
  const startIndex = (page - 1) * limit;
  const endIndex = startIndex + limit;
  const paginatedTrends = trends.slice(startIndex, endIndex);

  return {
    success: true,
    data: paginatedTrends,
    pagination: {
      currentPage: page,
      pageSize: limit,
      totalItems: trends.length,
      totalPages: Math.ceil(trends.length / limit),
      hasNextPage: endIndex < trends.length,
      hasPreviousPage: page > 1,
    },
  };
};

/**
 * Creates API endpoint response for C2 infrastructure.
 *
 * @param {C2Infrastructure[]} c2List - Array of C2 infrastructure
 * @param {Record<string, any>} [filters] - Applied filters
 * @returns {Record<string, any>} API response
 *
 * @example
 * ```typescript
 * @Get('/intelligence/c2')
 * async getC2Infrastructure(@Query() filters: Record<string, any>) {
 *   const c2List = await this.getC2Data(filters);
 *   return createC2ApiResponse(c2List, filters);
 * }
 * ```
 */
export const createC2ApiResponse = (
  c2List: C2Infrastructure[],
  filters?: Record<string, any>,
): Record<string, any> => {
  const monitoring = provideC2Monitoring(c2List);

  return {
    success: true,
    data: c2List,
    filters: filters || {},
    summary: monitoring,
  };
};

/**
 * Creates Swagger API documentation for threat intelligence endpoint.
 *
 * @returns {Record<string, any>} Swagger API specification
 *
 * @example
 * ```typescript
 * @ApiOperation(createThreatIntelligenceApiDoc())
 * @Get('/intelligence/threats')
 * async getThreatIntelligence() { ... }
 * ```
 */
export const createThreatIntelligenceApiDoc = (): Record<string, any> => {
  return {
    summary: 'Get threat intelligence reports',
    description: 'Retrieves current threat intelligence reports with confidence levels',
    parameters: [
      {
        name: 'confidence',
        in: 'query',
        required: false,
        description: 'Minimum confidence level',
        schema: { type: 'string', enum: ['low', 'medium', 'high', 'confirmed'] },
      },
      {
        name: 'tlp',
        in: 'query',
        required: false,
        description: 'Traffic Light Protocol level',
        schema: { type: 'string', enum: ['white', 'green', 'amber', 'red'] },
      },
    ],
    responses: {
      200: {
        description: 'Threat intelligence retrieved',
        schema: {
          type: 'object',
          properties: {
            success: { type: 'boolean' },
            data: { type: 'array', items: { type: 'object' } },
            count: { type: 'integer' },
          },
        },
      },
      500: { description: 'Internal server error' },
    },
  };
};

/**
 * Creates Swagger API documentation for malware trends endpoint.
 *
 * @returns {Record<string, any>} Swagger API specification
 *
 * @example
 * ```typescript
 * @ApiOperation(createMalwareTrendsApiDoc())
 * @Get('/intelligence/trends')
 * async getMalwareTrends() { ... }
 * ```
 */
export const createMalwareTrendsApiDoc = (): Record<string, any> => {
  return {
    summary: 'Get malware trend analysis',
    description: 'Retrieves malware trend analysis over specified time window',
    parameters: [
      {
        name: 'family',
        in: 'query',
        required: false,
        description: 'Filter by malware family',
        schema: { type: 'string' },
      },
      {
        name: 'startDate',
        in: 'query',
        required: false,
        description: 'Start date for trend analysis',
        schema: { type: 'string', format: 'date' },
      },
      {
        name: 'endDate',
        in: 'query',
        required: false,
        description: 'End date for trend analysis',
        schema: { type: 'string', format: 'date' },
      },
    ],
    responses: {
      200: {
        description: 'Malware trends retrieved',
        schema: {
          type: 'object',
          properties: {
            success: { type: 'boolean' },
            data: { type: 'array', items: { type: 'object' } },
            summary: {
              type: 'object',
              properties: {
                emerging: { type: 'integer' },
                declining: { type: 'integer' },
                avgGrowthRate: { type: 'number' },
              },
            },
          },
        },
      },
      400: { description: 'Invalid date range' },
      500: { description: 'Internal server error' },
    },
  };
};

/**
 * Validates threat intelligence report input.
 *
 * @param {Partial<ThreatIntelligence>} report - Threat intelligence report
 * @returns {{ isValid: boolean; errors: string[] }} Validation result
 *
 * @example
 * ```typescript
 * const validation = validateThreatIntelReport(report);
 * if (!validation.isValid) throw new BadRequestException(validation.errors);
 * ```
 */
export const validateThreatIntelReport = (
  report: Partial<ThreatIntelligence>,
): { isValid: boolean; errors: string[] } => {
  const errors: string[] = [];

  if (!report.source || report.source.trim().length === 0) {
    errors.push('Source is required');
  }

  if (!report.confidence) {
    errors.push('Confidence level is required');
  }

  if (!report.tlpLevel) {
    errors.push('TLP level is required');
  }

  if (!report.indicators || report.indicators.length === 0) {
    errors.push('At least one indicator is required');
  }

  if (!report.description || report.description.trim().length === 0) {
    errors.push('Description is required');
  }

  return {
    isValid: errors.length === 0,
    errors,
  };
};

/**
 * Aggregates malware statistics over time period.
 *
 * @param {MalwareTrend[]} trends - Array of malware trends
 * @param {Date} startDate - Start date
 * @param {Date} endDate - End date
 * @returns {Record<string, any>} Aggregated statistics
 *
 * @example
 * ```typescript
 * const stats = aggregateMalwareStatistics(trends, new Date('2025-01-01'), new Date('2025-01-31'));
 * // Result: { totalSamples: 10000, uniqueFamilies: 150, avgGrowthRate: 0.15, ... }
 * ```
 */
export const aggregateMalwareStatistics = (
  trends: MalwareTrend[],
  startDate: Date,
  endDate: Date,
): Record<string, any> => {
  const filteredTrends = trends.filter(t =>
    t.timeWindow.startDate >= startDate && t.timeWindow.endDate <= endDate
  );

  const totalSamples = filteredTrends.reduce((sum, t) => sum + t.sampleCount, 0);
  const uniqueFamilies = new Set(filteredTrends.map(t => t.familyName)).size;
  const avgGrowthRate = filteredTrends.reduce((sum, t) => sum + t.growthRate, 0) / filteredTrends.length || 0;
  const avgImpact = filteredTrends.reduce((sum, t) => sum + t.impactScore, 0) / filteredTrends.length || 0;

  return {
    period: { startDate, endDate },
    totalSamples,
    uniqueFamilies,
    avgGrowthRate: Math.round(avgGrowthRate * 100) / 100,
    avgImpact: Math.round(avgImpact * 100) / 100,
    trendCount: filteredTrends.length,
  };
};

/**
 * Generates intelligence report in structured format.
 *
 * @param {ThreatIntelligence[]} intelReports - Array of threat intelligence
 * @param {MalwareTrend[]} trends - Array of malware trends
 * @param {C2Infrastructure[]} c2List - Array of C2 infrastructure
 * @returns {Record<string, any>} Comprehensive intelligence report
 *
 * @example
 * ```typescript
 * const report = generateIntelligenceReport(intelReports, trends, c2List);
 * // Result: { executive Summary: '...', threats: [...], c2Infrastructure: [...], ... }
 * ```
 */
export const generateIntelligenceReport = (
  intelReports: ThreatIntelligence[],
  trends: MalwareTrend[],
  c2List: C2Infrastructure[],
): Record<string, any> => {
  const highConfidenceIntel = intelReports.filter(i => i.confidence === 'high' || i.confidence === 'confirmed');
  const emergingThreats = detectEmergingMalware(trends);
  const activeC2 = c2List.filter(c2 => c2.isActive && c2.reputation >= 70);

  return {
    reportDate: new Date().toISOString(),
    executiveSummary: {
      totalIntelReports: intelReports.length,
      highConfidenceReports: highConfidenceIntel.length,
      emergingThreats: emergingThreats.length,
      activeC2Infrastructure: activeC2.length,
    },
    threats: emergingThreats.slice(0, 10),
    intelligence: highConfidenceIntel.slice(0, 20),
    c2Infrastructure: activeC2.slice(0, 15),
    recommendations: generateThreatRecommendations(emergingThreats, activeC2),
  };
};

/**
 * Generates threat mitigation recommendations.
 *
 * @param {MalwareTrend[]} emergingThreats - Emerging malware threats
 * @param {C2Infrastructure[]} activeC2 - Active C2 infrastructure
 * @returns {string[]} Array of recommendations
 *
 * @example
 * ```typescript
 * const recommendations = generateThreatRecommendations(emerging, c2List);
 * // Result: ['Block domains: evil.com, bad.com', 'Monitor for Emotet indicators', ...]
 * ```
 */
export const generateThreatRecommendations = (
  emergingThreats: MalwareTrend[],
  activeC2: C2Infrastructure[],
): string[] => {
  const recommendations: string[] = [];

  if (emergingThreats.length > 0) {
    recommendations.push(`Monitor for emerging threats: ${emergingThreats.slice(0, 5).map(t => t.familyName).join(', ')}`);
  }

  const c2Domains = activeC2.filter(c2 => c2.type === 'domain').map(c2 => c2.value);
  if (c2Domains.length > 0) {
    recommendations.push(`Block malicious domains: ${c2Domains.slice(0, 10).join(', ')}`);
  }

  const c2IPs = activeC2.filter(c2 => c2.type === 'ip').map(c2 => c2.value);
  if (c2IPs.length > 0) {
    recommendations.push(`Block malicious IPs: ${c2IPs.slice(0, 10).join(', ')}`);
  }

  if (emergingThreats.some(t => t.growthRate > 1.0)) {
    recommendations.push('Increase monitoring frequency for rapidly growing threats');
  }

  recommendations.push('Update threat intelligence feeds and YARA rules');
  recommendations.push('Review and update endpoint protection signatures');

  return recommendations;
};

/**
 * Calculates threat intelligence coverage score.
 *
 * @param {ThreatIntelligence[]} intelReports - Array of threat intelligence
 * @param {MalwareTrend[]} trends - Array of malware trends
 * @returns {{ coverageScore: number; coveredFamilies: string[]; gaps: string[] }} Coverage analysis
 *
 * @example
 * ```typescript
 * const coverage = calculateIntelligenceCoverage(intelReports, trends);
 * // Result: { coverageScore: 75, coveredFamilies: ['Emotet', ...], gaps: ['NewTrojan', ...] }
 * ```
 */
export const calculateIntelligenceCoverage = (
  intelReports: ThreatIntelligence[],
  trends: MalwareTrend[],
): { coverageScore: number; coveredFamilies: string[]; gaps: string[] } => {
  const malwareFamilies = new Set(trends.map(t => t.familyName));
  const coveredFamilies = new Set(
    intelReports
      .filter(i => i.malwareFamily)
      .map(i => i.malwareFamily as string)
  );

  const covered = Array.from(malwareFamilies).filter(family => coveredFamilies.has(family));
  const gaps = Array.from(malwareFamilies).filter(family => !coveredFamilies.has(family));

  const coverageScore = Math.round((covered.length / malwareFamilies.size) * 100);

  return {
    coverageScore,
    coveredFamilies: covered,
    gaps,
  };
};

/**
 * Exports malware intelligence data in CSV format.
 *
 * @param {MalwareTrend[]} trends - Array of malware trends
 * @returns {string} CSV formatted data
 *
 * @example
 * ```typescript
 * const csv = exportIntelligenceToCSV(trends);
 * // Result: "Family,Sample Count,Growth Rate,Trend Direction,Impact Score\nEmotet,1000,0.25,rising,85\n..."
 * ```
 */
export const exportIntelligenceToCSV = (trends: MalwareTrend[]): string => {
  const headers = ['Family', 'Sample Count', 'Growth Rate', 'Trend Direction', 'Impact Score', 'Peak Date'];
  const rows = trends.map(t => [
    t.familyName,
    t.sampleCount.toString(),
    t.growthRate.toString(),
    t.trendDirection,
    t.impactScore.toString(),
    t.peakDate.toISOString().split('T')[0],
  ]);

  const csvContent = [
    headers.join(','),
    ...rows.map(row => row.join(',')),
  ].join('\n');

  return csvContent;
};

// ============================================================================
// EXPORTS
// ============================================================================

export default {
  // Trend analysis
  analyzeMalwareTrend,
  detectEmergingMalware,
  identifyDecliningMalware,
  compareMalwareTrends,

  // Prevalence scoring
  calculatePrevalenceScore,
  rankMalwareByPrevalence,
  calculateRegionalPrevalence,
  calculateSectorPrevalence,

  // Variant detection
  detectMalwareVariant,
  calculateCodeSimilarity,
  identifyVariantMutations,
  clusterMalwareVariants,

  // Signature generation
  generateYaraSignature,
  validateSignatureEffectiveness,
  updateSignatureDetectionCount,

  // C2 tracking
  createC2Infrastructure,
  trackC2Communication,
  identifySharedC2Infrastructure,
  calculateC2Reputation,

  // Distribution analysis
  analyzeDistributionVectors,
  identifyTargetedSectors,
  calculateDistributionEffectiveness,

  // Kill chain mapping
  mapToKillChain,
  analyzeKillChainCompleteness,
  generateKillChainVisualization,

  // Campaign tracking
  createMalwareCampaign,
  calculateCampaignImpact,
  correlateMalwareFamilies,

  // Threat intelligence
  createThreatIntelReport,
  validateIntelligenceFreshness,
  enrichMalwareWithIntelligence,

  // Sequelize queries
  createMalwareTrendQuery,
  createC2InfrastructureQuery,
  createMalwareCampaignQuery,

  // NestJS providers
  provideIntelligenceAnalytics,
  provideC2Monitoring,
  provideThreatCorrelation,

  // API endpoints
  createTrendsApiResponse,
  createC2ApiResponse,
  createThreatIntelligenceApiDoc,
  createMalwareTrendsApiDoc,
  validateThreatIntelReport,

  // Analytics and reporting
  aggregateMalwareStatistics,
  generateIntelligenceReport,
  generateThreatRecommendations,
  calculateIntelligenceCoverage,
  exportIntelligenceToCSV,
};
