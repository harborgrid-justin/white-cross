"use strict";
/**
 * LOC: MALK1234567
 * File: /reuse/threat/malware-analysis-kit.ts
 *
 * UPSTREAM (imports from):
 *   - None (leaf node - reusable utilities)
 *
 * DOWNSTREAM (imported by):
 *   - Threat intelligence services
 *   - Malware analysis controllers
 *   - Security monitoring systems
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateSandboxConfig = exports.createBatchAnalysisJob = exports.compareMalwareSamples = exports.generateAnalysisSummary = exports.extractMalwareMetadata = exports.createMalwareSearchDto = exports.validateMalwareUpload = exports.createYaraRuleSchema = exports.createMalwareSampleSchema = exports.createMalwareAnalysisApiDoc = exports.createMalwareUploadApiDoc = exports.retrieveMalwareByHash = exports.submitMalwareToSandbox = exports.performStaticAnalysis = exports.createMalwareFamilyQuery = exports.createMalwareHashQuery = exports.createMalwareSampleModel = exports.parseMachOHeader = exports.parseELFHeader = exports.extractPESections = exports.parsePEHeader = exports.generateSandboxVerdict = exports.validateSandboxResult = exports.createSandboxConfig = exports.calculateMaliciousScore = exports.analyzeRegistryBehavior = exports.analyzeNetworkBehavior = exports.analyzeProcessBehavior = exports.identifyPackers = exports.detectStringType = exports.extractStringsFromBuffer = exports.isFilePacked = exports.calculateFileEntropy = exports.updateFamilyPrevalence = exports.classifyMalwareByBehavior = exports.determineDangerLevel = exports.createMalwareFamily = exports.validateYaraRule = exports.parseYaraMatch = exports.formatYaraRule = exports.createYaraRule = exports.validateFileType = exports.extractMagicNumber = exports.detectFileSignature = exports.normalizeHash = exports.validateHashFormat = exports.computeAllHashes = exports.computeSHA256Hash = exports.computeSHA1Hash = exports.computeMD5Hash = void 0;
exports.generateMalwareJsonReport = void 0;
/**
 * File: /reuse/threat/malware-analysis-kit.ts
 * Locator: WC-UTL-MALK-001
 * Purpose: Comprehensive Malware Analysis Utilities - Hash analysis, file signatures, YARA rules, behavioral analysis
 *
 * Upstream: Independent utility module for malware analysis and detection
 * Downstream: ../backend/threat/*, security services, malware sandbox integrations
 * Dependencies: TypeScript 5.x, Node 18+, NestJS 10.x, Swagger/OpenAPI, Sequelize 6.x
 * Exports: 48 utility functions for malware hash analysis, file parsing, YARA matching, sandbox integration, behavior analysis
 *
 * LLM Context: Comprehensive malware analysis utilities for implementing production-ready threat detection in White Cross system.
 * Provides hash analysis (MD5, SHA1, SHA256), file signature detection, YARA rule matching, malware family classification,
 * static/dynamic analysis helpers, PE/ELF/Mach-O parsing, sandbox integration, and behavior analysis. Essential for building
 * robust security and threat intelligence capabilities.
 */
const crypto = __importStar(require("crypto"));
// ============================================================================
// HASH ANALYSIS UTILITIES
// ============================================================================
/**
 * Computes MD5 hash of file buffer.
 *
 * @param {Buffer} fileBuffer - File buffer to hash
 * @returns {string} MD5 hash (lowercase hex)
 *
 * @example
 * ```typescript
 * const buffer = fs.readFileSync('suspicious.exe');
 * const md5 = computeMD5Hash(buffer);
 * // Result: 'a1b2c3d4e5f6...'
 * ```
 */
const computeMD5Hash = (fileBuffer) => {
    return crypto.createHash('md5').update(fileBuffer).digest('hex').toLowerCase();
};
exports.computeMD5Hash = computeMD5Hash;
/**
 * Computes SHA1 hash of file buffer.
 *
 * @param {Buffer} fileBuffer - File buffer to hash
 * @returns {string} SHA1 hash (lowercase hex)
 *
 * @example
 * ```typescript
 * const buffer = fs.readFileSync('malware.dll');
 * const sha1 = computeSHA1Hash(buffer);
 * // Result: '9f3c8e1b7a4d...'
 * ```
 */
const computeSHA1Hash = (fileBuffer) => {
    return crypto.createHash('sha1').update(fileBuffer).digest('hex').toLowerCase();
};
exports.computeSHA1Hash = computeSHA1Hash;
/**
 * Computes SHA256 hash of file buffer.
 *
 * @param {Buffer} fileBuffer - File buffer to hash
 * @returns {string} SHA256 hash (lowercase hex)
 *
 * @example
 * ```typescript
 * const buffer = fs.readFileSync('trojan.exe');
 * const sha256 = computeSHA256Hash(buffer);
 * // Result: '7f8e9d0a1b2c...'
 * ```
 */
const computeSHA256Hash = (fileBuffer) => {
    return crypto.createHash('sha256').update(fileBuffer).digest('hex').toLowerCase();
};
exports.computeSHA256Hash = computeSHA256Hash;
/**
 * Computes all standard hashes (MD5, SHA1, SHA256, SHA512) for a file.
 *
 * @param {Buffer} fileBuffer - File buffer to hash
 * @returns {MalwareHash} Object containing all hash values
 *
 * @example
 * ```typescript
 * const buffer = fs.readFileSync('sample.bin');
 * const hashes = computeAllHashes(buffer);
 * // Result: { md5: '...', sha1: '...', sha256: '...', sha512: '...' }
 * ```
 */
const computeAllHashes = (fileBuffer) => {
    return {
        md5: (0, exports.computeMD5Hash)(fileBuffer),
        sha1: (0, exports.computeSHA1Hash)(fileBuffer),
        sha256: (0, exports.computeSHA256Hash)(fileBuffer),
        sha512: crypto.createHash('sha512').update(fileBuffer).digest('hex').toLowerCase(),
    };
};
exports.computeAllHashes = computeAllHashes;
/**
 * Validates hash format (supports MD5, SHA1, SHA256).
 *
 * @param {string} hash - Hash string to validate
 * @param {'md5' | 'sha1' | 'sha256' | 'sha512'} type - Expected hash type
 * @returns {boolean} True if hash format is valid
 *
 * @example
 * ```typescript
 * const isValid = validateHashFormat('a1b2c3d4...', 'md5');
 * // Result: true or false
 * ```
 */
const validateHashFormat = (hash, type) => {
    const patterns = {
        md5: /^[a-f0-9]{32}$/i,
        sha1: /^[a-f0-9]{40}$/i,
        sha256: /^[a-f0-9]{64}$/i,
        sha512: /^[a-f0-9]{128}$/i,
    };
    return patterns[type].test(hash);
};
exports.validateHashFormat = validateHashFormat;
/**
 * Normalizes hash string to lowercase and removes whitespace.
 *
 * @param {string} hash - Hash string to normalize
 * @returns {string} Normalized hash
 *
 * @example
 * ```typescript
 * const normalized = normalizeHash('  A1B2C3D4  ');
 * // Result: 'a1b2c3d4'
 * ```
 */
const normalizeHash = (hash) => {
    return hash.trim().toLowerCase();
};
exports.normalizeHash = normalizeHash;
// ============================================================================
// FILE SIGNATURE DETECTION
// ============================================================================
/**
 * Detects file type from magic number (file signature).
 *
 * @param {Buffer} fileBuffer - File buffer (at least first 512 bytes)
 * @returns {FileSignature | null} File signature information or null
 *
 * @example
 * ```typescript
 * const buffer = fs.readFileSync('unknown.bin');
 * const signature = detectFileSignature(buffer);
 * // Result: { magicNumber: '4D5A', fileType: 'PE', mimeType: 'application/x-dosexec', ... }
 * ```
 */
const detectFileSignature = (fileBuffer) => {
    const signatures = [
        { magic: '4D5A', type: 'PE', mime: 'application/x-dosexec', ext: 'exe' },
        { magic: '7F454C46', type: 'ELF', mime: 'application/x-elf', ext: 'elf' },
        { magic: 'CAFEBABE', type: 'Mach-O', mime: 'application/x-mach-binary', ext: 'macho' },
        { magic: 'CEFAEDFE', type: 'Mach-O-64', mime: 'application/x-mach-binary', ext: 'macho' },
        { magic: '504B0304', type: 'ZIP', mime: 'application/zip', ext: 'zip' },
        { magic: '504B0506', type: 'ZIP-Empty', mime: 'application/zip', ext: 'zip' },
        { magic: '504B0708', type: 'ZIP-Spanned', mime: 'application/zip', ext: 'zip' },
        { magic: '52617221', type: 'RAR', mime: 'application/x-rar-compressed', ext: 'rar' },
        { magic: '1F8B08', type: 'GZIP', mime: 'application/gzip', ext: 'gz' },
        { magic: '425A68', type: 'BZIP2', mime: 'application/x-bzip2', ext: 'bz2' },
        { magic: 'D0CF11E0', type: 'OLE', mime: 'application/x-ole-storage', ext: 'ole' },
        { magic: '25504446', type: 'PDF', mime: 'application/pdf', ext: 'pdf' },
    ];
    const magicBytes = fileBuffer.slice(0, 8).toString('hex').toUpperCase();
    for (const sig of signatures) {
        if (magicBytes.startsWith(sig.magic)) {
            return {
                magicNumber: sig.magic,
                fileType: sig.type,
                mimeType: sig.mime,
                extension: sig.ext,
                confidence: 1.0,
            };
        }
    }
    return null;
};
exports.detectFileSignature = detectFileSignature;
/**
 * Extracts magic number from file buffer.
 *
 * @param {Buffer} fileBuffer - File buffer
 * @param {number} [length] - Number of bytes to extract (default: 8)
 * @returns {string} Magic number as hex string
 *
 * @example
 * ```typescript
 * const buffer = fs.readFileSync('file.exe');
 * const magic = extractMagicNumber(buffer, 4);
 * // Result: '4D5A9000'
 * ```
 */
const extractMagicNumber = (fileBuffer, length = 8) => {
    return fileBuffer.slice(0, length).toString('hex').toUpperCase();
};
exports.extractMagicNumber = extractMagicNumber;
/**
 * Validates if file matches expected type based on magic number.
 *
 * @param {Buffer} fileBuffer - File buffer
 * @param {string} expectedType - Expected file type (e.g., 'PE', 'ELF')
 * @returns {boolean} True if file type matches
 *
 * @example
 * ```typescript
 * const buffer = fs.readFileSync('file.exe');
 * const isPE = validateFileType(buffer, 'PE');
 * // Result: true
 * ```
 */
const validateFileType = (fileBuffer, expectedType) => {
    const signature = (0, exports.detectFileSignature)(fileBuffer);
    return signature !== null && signature.fileType === expectedType;
};
exports.validateFileType = validateFileType;
// ============================================================================
// YARA RULE UTILITIES
// ============================================================================
/**
 * Creates a YARA rule object from components.
 *
 * @param {string} ruleName - Rule name
 * @param {YaraString[]} strings - Array of YARA strings
 * @param {string} condition - YARA condition
 * @param {Record<string, string>} [meta] - Metadata
 * @param {string[]} [tags] - Tags
 * @returns {YaraRule} YARA rule object
 *
 * @example
 * ```typescript
 * const rule = createYaraRule('MalwareDetection',
 *   [{ identifier: '$malware', type: 'text', value: 'malicious' }],
 *   'any of them',
 *   { author: 'Security Team', description: 'Detects malware' },
 *   ['malware', 'trojan']
 * );
 * ```
 */
const createYaraRule = (ruleName, strings, condition, meta, tags) => {
    return {
        ruleName,
        tags: tags || [],
        meta: meta || {},
        strings,
        condition,
    };
};
exports.createYaraRule = createYaraRule;
/**
 * Formats YARA rule as string for file export.
 *
 * @param {YaraRule} rule - YARA rule object
 * @returns {string} Formatted YARA rule string
 *
 * @example
 * ```typescript
 * const ruleString = formatYaraRule(rule);
 * // Result: 'rule MalwareDetection : malware trojan { meta: ... strings: ... condition: ... }'
 * ```
 */
const formatYaraRule = (rule) => {
    let output = `rule ${rule.ruleName}`;
    if (rule.tags.length > 0) {
        output += ` : ${rule.tags.join(' ')}`;
    }
    output += ' {\n';
    if (Object.keys(rule.meta).length > 0) {
        output += '  meta:\n';
        Object.entries(rule.meta).forEach(([key, value]) => {
            output += `    ${key} = "${value}"\n`;
        });
    }
    if (rule.strings.length > 0) {
        output += '  strings:\n';
        rule.strings.forEach((str) => {
            let strValue = str.value;
            if (str.type === 'text') {
                strValue = `"${str.value}"`;
            }
            else if (str.type === 'hex') {
                strValue = `{ ${str.value} }`;
            }
            else if (str.type === 'regex') {
                strValue = `/${str.value}/`;
            }
            output += `    ${str.identifier} = ${strValue}`;
            if (str.modifiers && str.modifiers.length > 0) {
                output += ` ${str.modifiers.join(' ')}`;
            }
            output += '\n';
        });
    }
    output += '  condition:\n';
    output += `    ${rule.condition}\n`;
    output += '}\n';
    return output;
};
exports.formatYaraRule = formatYaraRule;
/**
 * Parses YARA match result with severity assessment.
 *
 * @param {string} ruleName - Matched rule name
 * @param {MatchedString[]} matchedStrings - Matched strings with offsets
 * @param {Record<string, string>} metadata - Rule metadata
 * @returns {YaraMatch} YARA match result
 *
 * @example
 * ```typescript
 * const match = parseYaraMatch('Ransomware',
 *   [{ identifier: '$encrypt', offset: 1024, data: 'AES256' }],
 *   { author: 'Team', severity: 'critical' }
 * );
 * ```
 */
const parseYaraMatch = (ruleName, matchedStrings, metadata) => {
    const severityMap = {
        low: 'low',
        medium: 'medium',
        high: 'high',
        critical: 'critical',
    };
    const severity = severityMap[metadata.severity?.toLowerCase()] || 'medium';
    return {
        ruleName,
        tags: metadata.tags ? metadata.tags.split(',') : [],
        matchedStrings,
        metadata,
        severity,
    };
};
exports.parseYaraMatch = parseYaraMatch;
/**
 * Validates YARA rule syntax and structure.
 *
 * @param {YaraRule} rule - YARA rule to validate
 * @returns {boolean} True if rule is valid
 *
 * @example
 * ```typescript
 * const isValid = validateYaraRule(rule);
 * // Result: true or false
 * ```
 */
const validateYaraRule = (rule) => {
    if (!rule.ruleName || rule.ruleName.trim().length === 0) {
        return false;
    }
    if (!rule.condition || rule.condition.trim().length === 0) {
        return false;
    }
    if (rule.strings.length === 0) {
        return false;
    }
    return true;
};
exports.validateYaraRule = validateYaraRule;
// ============================================================================
// MALWARE FAMILY CLASSIFICATION
// ============================================================================
/**
 * Creates malware family classification record.
 *
 * @param {string} familyName - Malware family name
 * @param {MalwareType} type - Type of malware
 * @param {string[]} [aliases] - Known aliases
 * @returns {Partial<MalwareFamily>} Malware family object
 *
 * @example
 * ```typescript
 * const family = createMalwareFamily('WannaCry', 'ransomware', ['WCry', 'WanaCrypt0r']);
 * ```
 */
const createMalwareFamily = (familyName, type, aliases) => {
    return {
        familyName,
        aliases: aliases || [],
        type,
        firstSeen: new Date(),
        lastSeen: new Date(),
        prevalence: 0,
    };
};
exports.createMalwareFamily = createMalwareFamily;
/**
 * Determines malware danger level based on type and characteristics.
 *
 * @param {MalwareType} type - Malware type
 * @param {number} prevalence - Prevalence score (0-100)
 * @returns {'low' | 'medium' | 'high' | 'critical'} Danger level
 *
 * @example
 * ```typescript
 * const danger = determineDangerLevel('ransomware', 85);
 * // Result: 'critical'
 * ```
 */
const determineDangerLevel = (type, prevalence) => {
    const criticalTypes = ['ransomware', 'apt', 'rootkit'];
    const highTypes = ['trojan', 'backdoor', 'botnet'];
    if (criticalTypes.includes(type) || prevalence >= 80) {
        return 'critical';
    }
    if (highTypes.includes(type) || prevalence >= 60) {
        return 'high';
    }
    if (prevalence >= 30) {
        return 'medium';
    }
    return 'low';
};
exports.determineDangerLevel = determineDangerLevel;
/**
 * Classifies malware by analyzing behavioral patterns.
 *
 * @param {BehaviorIndicator[]} behaviors - Array of behavior indicators
 * @returns {MalwareType} Classified malware type
 *
 * @example
 * ```typescript
 * const behaviors = [
 *   { category: 'impact', technique: 'Data Encrypted', ... },
 *   { category: 'command_control', technique: 'C2 Communication', ... }
 * ];
 * const type = classifyMalwareByBehavior(behaviors);
 * // Result: 'ransomware'
 * ```
 */
const classifyMalwareByBehavior = (behaviors) => {
    const encryptionCount = behaviors.filter(b => b.technique.toLowerCase().includes('encrypt') ||
        b.category === 'impact').length;
    const persistenceCount = behaviors.filter(b => b.category === 'persistence').length;
    const c2Count = behaviors.filter(b => b.category === 'command_control').length;
    const credentialCount = behaviors.filter(b => b.category === 'credential_access').length;
    if (encryptionCount >= 2 && c2Count >= 1) {
        return 'ransomware';
    }
    if (persistenceCount >= 2 && c2Count >= 1) {
        return 'backdoor';
    }
    if (credentialCount >= 2) {
        return 'spyware';
    }
    if (c2Count >= 2) {
        return 'botnet';
    }
    return 'trojan';
};
exports.classifyMalwareByBehavior = classifyMalwareByBehavior;
/**
 * Updates malware family prevalence statistics.
 *
 * @param {MalwareFamily} family - Malware family object
 * @param {number} newSamples - Number of new samples detected
 * @returns {MalwareFamily} Updated malware family
 *
 * @example
 * ```typescript
 * const updated = updateFamilyPrevalence(family, 25);
 * // Increments prevalence and updates lastSeen timestamp
 * ```
 */
const updateFamilyPrevalence = (family, newSamples) => {
    return {
        ...family,
        prevalence: family.prevalence + newSamples,
        lastSeen: new Date(),
    };
};
exports.updateFamilyPrevalence = updateFamilyPrevalence;
// ============================================================================
// STATIC ANALYSIS HELPERS
// ============================================================================
/**
 * Calculates Shannon entropy of file buffer (0-8, higher = more random/packed).
 *
 * @param {Buffer} buffer - File buffer
 * @returns {number} Entropy value
 *
 * @example
 * ```typescript
 * const buffer = fs.readFileSync('packed.exe');
 * const entropy = calculateFileEntropy(buffer);
 * // Result: 7.85 (likely packed/encrypted)
 * ```
 */
const calculateFileEntropy = (buffer) => {
    if (buffer.length === 0)
        return 0;
    const frequencies = new Array(256).fill(0);
    for (let i = 0; i < buffer.length; i++) {
        frequencies[buffer[i]]++;
    }
    let entropy = 0;
    const length = buffer.length;
    for (let i = 0; i < 256; i++) {
        if (frequencies[i] > 0) {
            const probability = frequencies[i] / length;
            entropy -= probability * Math.log2(probability);
        }
    }
    return Math.round(entropy * 100) / 100;
};
exports.calculateFileEntropy = calculateFileEntropy;
/**
 * Detects if file is likely packed/compressed based on entropy.
 *
 * @param {number} entropy - File entropy value
 * @param {number} [threshold] - Entropy threshold (default: 7.0)
 * @returns {boolean} True if likely packed
 *
 * @example
 * ```typescript
 * const isPacked = isFilePacked(7.85);
 * // Result: true
 * ```
 */
const isFilePacked = (entropy, threshold = 7.0) => {
    return entropy >= threshold;
};
exports.isFilePacked = isFilePacked;
/**
 * Extracts strings from binary buffer (ASCII and Unicode).
 *
 * @param {Buffer} buffer - File buffer
 * @param {number} [minLength] - Minimum string length (default: 4)
 * @returns {ExtractedString[]} Array of extracted strings
 *
 * @example
 * ```typescript
 * const buffer = fs.readFileSync('malware.exe');
 * const strings = extractStringsFromBuffer(buffer, 5);
 * // Result: [{ value: 'http://evil.com', offset: 1024, type: 'url', ... }, ...]
 * ```
 */
const extractStringsFromBuffer = (buffer, minLength = 4) => {
    const strings = [];
    const asciiPattern = /[\x20-\x7E]{4,}/g;
    const unicodePattern = /(?:[\x20-\x7E]\x00){4,}/g;
    // ASCII strings
    const asciiMatches = buffer.toString('binary').matchAll(asciiPattern);
    for (const match of asciiMatches) {
        if (match.index !== undefined && match[0].length >= minLength) {
            const value = match[0];
            strings.push({
                value,
                offset: match.index,
                type: (0, exports.detectStringType)(value),
                encoding: 'ascii',
            });
        }
    }
    // Unicode strings
    const unicodeMatches = buffer.toString('binary').matchAll(unicodePattern);
    for (const match of unicodeMatches) {
        if (match.index !== undefined) {
            const value = match[0].replace(/\x00/g, '');
            if (value.length >= minLength) {
                strings.push({
                    value,
                    offset: match.index,
                    type: (0, exports.detectStringType)(value),
                    encoding: 'unicode',
                });
            }
        }
    }
    return strings;
};
exports.extractStringsFromBuffer = extractStringsFromBuffer;
/**
 * Detects type of extracted string (URL, IP, email, etc.).
 *
 * @param {string} str - String to analyze
 * @returns {'ascii' | 'unicode' | 'url' | 'ip' | 'email' | 'filepath' | 'registry'} String type
 *
 * @example
 * ```typescript
 * const type = detectStringType('http://malicious.com');
 * // Result: 'url'
 * ```
 */
const detectStringType = (str) => {
    const patterns = {
        url: /^https?:\/\//i,
        ip: /^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/,
        email: /^[^\s@]+@[^\s@]+\.[^\s@]+$/,
        filepath: /^[a-z]:\\|^\//i,
        registry: /^HKEY_/i,
    };
    for (const [type, pattern] of Object.entries(patterns)) {
        if (pattern.test(str)) {
            return type;
        }
    }
    return 'ascii';
};
exports.detectStringType = detectStringType;
/**
 * Identifies common packers from file signatures and sections.
 *
 * @param {Buffer} buffer - File buffer
 * @param {FileSection[]} sections - File sections
 * @returns {string[]} Array of detected packer names
 *
 * @example
 * ```typescript
 * const packers = identifyPackers(buffer, sections);
 * // Result: ['UPX', 'Themida']
 * ```
 */
const identifyPackers = (buffer, sections) => {
    const packers = [];
    const bufferStr = buffer.toString('binary');
    const packerSignatures = {
        'UPX': 'UPX!',
        'Themida': 'Themida',
        'VMProtect': 'VMProtect',
        'Armadillo': 'Armadillo',
        'ASPack': 'ASPack',
        'PECompact': 'PECompact',
        'MPRESS': 'MPRESS',
    };
    for (const [packer, signature] of Object.entries(packerSignatures)) {
        if (bufferStr.includes(signature)) {
            packers.push(packer);
        }
    }
    // Check section names for packer indicators
    const packerSections = {
        'UPX': 'UPX',
        'ASPack': '.aspack',
        'PECompact': '.pec',
    };
    for (const section of sections) {
        for (const [packer, sectionName] of Object.entries(packerSections)) {
            if (section.name.toLowerCase().includes(sectionName.toLowerCase())) {
                if (!packers.includes(packer)) {
                    packers.push(packer);
                }
            }
        }
    }
    return packers;
};
exports.identifyPackers = identifyPackers;
// ============================================================================
// DYNAMIC ANALYSIS HELPERS
// ============================================================================
/**
 * Analyzes process creation patterns for suspicious behavior.
 *
 * @param {ProcessInfo[]} processes - Array of process information
 * @returns {BehaviorIndicator[]} Detected suspicious behaviors
 *
 * @example
 * ```typescript
 * const behaviors = analyzeProcessBehavior(processes);
 * // Result: [{ category: 'defense_evasion', technique: 'Process Injection', ... }]
 * ```
 */
const analyzeProcessBehavior = (processes) => {
    const behaviors = [];
    // Check for suspicious process relationships
    const systemProcesses = processes.filter(p => ['cmd.exe', 'powershell.exe', 'wscript.exe', 'cscript.exe'].includes(p.name.toLowerCase()));
    if (systemProcesses.length >= 3) {
        behaviors.push({
            category: 'defense_evasion',
            technique: 'Scripting',
            mitreAttackId: 'T1059',
            description: 'Multiple scripting processes detected',
            severity: 'high',
            confidence: 0.85,
        });
    }
    // Check for process injection indicators
    const suspiciousParents = processes.filter(p => p.commandLine.toLowerCase().includes('inject') ||
        p.commandLine.toLowerCase().includes('hollowing'));
    if (suspiciousParents.length > 0) {
        behaviors.push({
            category: 'defense_evasion',
            technique: 'Process Injection',
            mitreAttackId: 'T1055',
            description: 'Potential process injection detected',
            severity: 'critical',
            confidence: 0.90,
        });
    }
    return behaviors;
};
exports.analyzeProcessBehavior = analyzeProcessBehavior;
/**
 * Analyzes network connections for C2 communication patterns.
 *
 * @param {NetworkConnection[]} connections - Array of network connections
 * @returns {BehaviorIndicator[]} Detected C2 behaviors
 *
 * @example
 * ```typescript
 * const c2Behaviors = analyzeNetworkBehavior(connections);
 * // Result: [{ category: 'command_control', technique: 'C2 Communication', ... }]
 * ```
 */
const analyzeNetworkBehavior = (connections) => {
    const behaviors = [];
    // Check for suspicious ports
    const suspiciousPorts = [4444, 5555, 6666, 7777, 8888, 31337];
    const suspiciousConnections = connections.filter(c => suspiciousPorts.includes(c.destinationPort));
    if (suspiciousConnections.length > 0) {
        behaviors.push({
            category: 'command_control',
            technique: 'Non-Standard Port',
            mitreAttackId: 'T1571',
            description: 'Communication on suspicious ports detected',
            severity: 'high',
            confidence: 0.75,
        });
    }
    // Check for beaconing behavior (regular intervals)
    if (connections.length >= 5) {
        const intervals = [];
        for (let i = 1; i < connections.length; i++) {
            const interval = connections[i].timestamp.getTime() - connections[i - 1].timestamp.getTime();
            intervals.push(interval);
        }
        const avgInterval = intervals.reduce((a, b) => a + b, 0) / intervals.length;
        const variance = intervals.reduce((sum, interval) => sum + Math.pow(interval - avgInterval, 2), 0) / intervals.length;
        if (variance < 1000) { // Low variance = regular beaconing
            behaviors.push({
                category: 'command_control',
                technique: 'C2 Beaconing',
                mitreAttackId: 'T1071',
                description: 'Regular C2 beaconing pattern detected',
                severity: 'critical',
                confidence: 0.88,
            });
        }
    }
    return behaviors;
};
exports.analyzeNetworkBehavior = analyzeNetworkBehavior;
/**
 * Analyzes registry modifications for persistence mechanisms.
 *
 * @param {RegistryChange[]} changes - Array of registry changes
 * @returns {BehaviorIndicator[]} Detected persistence behaviors
 *
 * @example
 * ```typescript
 * const persistenceBehaviors = analyzeRegistryBehavior(changes);
 * // Result: [{ category: 'persistence', technique: 'Registry Run Keys', ... }]
 * ```
 */
const analyzeRegistryBehavior = (changes) => {
    const behaviors = [];
    const persistenceKeys = [
        'SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run',
        'SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\RunOnce',
        'SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\RunServices',
    ];
    const persistenceChanges = changes.filter(c => persistenceKeys.some(key => c.keyPath.toLowerCase().includes(key.toLowerCase())));
    if (persistenceChanges.length > 0) {
        behaviors.push({
            category: 'persistence',
            technique: 'Registry Run Keys',
            mitreAttackId: 'T1547.001',
            description: 'Persistence via registry run keys detected',
            severity: 'high',
            confidence: 0.92,
        });
    }
    return behaviors;
};
exports.analyzeRegistryBehavior = analyzeRegistryBehavior;
/**
 * Calculates overall malicious score from dynamic analysis results.
 *
 * @param {DynamicAnalysisResult} result - Dynamic analysis results
 * @returns {number} Malicious score (0-100)
 *
 * @example
 * ```typescript
 * const score = calculateMaliciousScore(dynamicResult);
 * // Result: 85 (highly malicious)
 * ```
 */
const calculateMaliciousScore = (result) => {
    let score = 0;
    // Weight different indicators
    score += result.behaviors.filter(b => b.severity === 'critical').length * 25;
    score += result.behaviors.filter(b => b.severity === 'high').length * 15;
    score += result.behaviors.filter(b => b.severity === 'medium').length * 8;
    score += result.behaviors.filter(b => b.severity === 'low').length * 3;
    // Additional factors
    if (result.networkConnections.length > 10)
        score += 10;
    if (result.filesModified.length > 20)
        score += 10;
    if (result.registryModified.length > 15)
        score += 10;
    if (result.processCreated.length > 10)
        score += 10;
    return Math.min(100, score);
};
exports.calculateMaliciousScore = calculateMaliciousScore;
// ============================================================================
// MALWARE SANDBOX INTEGRATION
// ============================================================================
/**
 * Creates sandbox configuration for malware analysis.
 *
 * @param {Partial<SandboxConfig>} overrides - Configuration overrides
 * @returns {SandboxConfig} Complete sandbox configuration
 *
 * @example
 * ```typescript
 * const config = createSandboxConfig({
 *   timeout: 300000,
 *   vmType: 'windows',
 *   enableNetwork: true
 * });
 * ```
 */
const createSandboxConfig = (overrides) => {
    return {
        timeout: 180000, // 3 minutes
        vmType: 'windows',
        vmVersion: 'Windows 10',
        enableNetwork: true,
        enableInternet: false,
        captureTraffic: true,
        captureScreenshots: true,
        memoryDumpOnExit: false,
        ...overrides,
    };
};
exports.createSandboxConfig = createSandboxConfig;
/**
 * Validates sandbox result for completeness and integrity.
 *
 * @param {SandboxResult} result - Sandbox analysis result
 * @returns {boolean} True if result is valid
 *
 * @example
 * ```typescript
 * const isValid = validateSandboxResult(result);
 * // Result: true or false
 * ```
 */
const validateSandboxResult = (result) => {
    if (!result.analysisId || !result.startTime || !result.endTime) {
        return false;
    }
    if (!result.staticAnalysis || !result.dynamicAnalysis) {
        return false;
    }
    if (result.status !== 'completed' && result.status !== 'timeout') {
        return false;
    }
    return true;
};
exports.validateSandboxResult = validateSandboxResult;
/**
 * Generates sandbox verdict from analysis results.
 *
 * @param {StaticAnalysisResult} staticResult - Static analysis results
 * @param {DynamicAnalysisResult} dynamicResult - Dynamic analysis results
 * @returns {{ verdict: 'benign' | 'suspicious' | 'malicious'; score: number }} Verdict and score
 *
 * @example
 * ```typescript
 * const { verdict, score } = generateSandboxVerdict(staticResult, dynamicResult);
 * // Result: { verdict: 'malicious', score: 92 }
 * ```
 */
const generateSandboxVerdict = (staticResult, dynamicResult) => {
    let score = 0;
    // Static analysis factors
    if (staticResult.isSuspicious)
        score += 20;
    score += staticResult.suspicionReasons.length * 5;
    if (staticResult.entropy > 7.0)
        score += 15;
    score += staticResult.packers.length * 10;
    // Dynamic analysis factors
    const dynamicScore = (0, exports.calculateMaliciousScore)(dynamicResult);
    score += dynamicScore * 0.6;
    score = Math.min(100, Math.round(score));
    let verdict;
    if (score >= 70) {
        verdict = 'malicious';
    }
    else if (score >= 40) {
        verdict = 'suspicious';
    }
    else {
        verdict = 'benign';
    }
    return { verdict, score };
};
exports.generateSandboxVerdict = generateSandboxVerdict;
// ============================================================================
// PE FILE PARSING
// ============================================================================
/**
 * Parses PE file header from buffer.
 *
 * @param {Buffer} buffer - PE file buffer
 * @returns {PEFileHeader | null} Parsed PE header or null
 * @throws {Error} If buffer is not a valid PE file
 *
 * @example
 * ```typescript
 * const buffer = fs.readFileSync('malware.exe');
 * const peHeader = parsePEHeader(buffer);
 * // Result: { machineType: 'x86', numberOfSections: 5, ... }
 * ```
 */
const parsePEHeader = (buffer) => {
    // Check DOS signature
    if (buffer.length < 64 || buffer.readUInt16LE(0) !== 0x5A4D) {
        throw new Error('Invalid PE file: DOS signature not found');
    }
    // Get PE header offset
    const peOffset = buffer.readUInt32LE(60);
    if (buffer.length < peOffset + 24) {
        throw new Error('Invalid PE file: insufficient data for PE header');
    }
    // Check PE signature
    if (buffer.readUInt32LE(peOffset) !== 0x00004550) {
        throw new Error('Invalid PE file: PE signature not found');
    }
    const coffOffset = peOffset + 4;
    const machineType = buffer.readUInt16LE(coffOffset);
    const numberOfSections = buffer.readUInt16LE(coffOffset + 2);
    const timeDateStamp = new Date(buffer.readUInt32LE(coffOffset + 4) * 1000);
    const characteristics = buffer.readUInt16LE(coffOffset + 18);
    const optionalHeaderOffset = coffOffset + 20;
    const optionalHeaderMagic = buffer.readUInt16LE(optionalHeaderOffset);
    const entryPoint = buffer.readUInt32LE(optionalHeaderOffset + 16);
    const imageBase = buffer.readUInt32LE(optionalHeaderOffset + 28);
    const subsystem = buffer.readUInt16LE(optionalHeaderOffset + 68);
    const machineTypes = {
        0x014c: 'x86',
        0x8664: 'x64',
        0x0200: 'Intel Itanium',
        0x01c0: 'ARM',
        0xaa64: 'ARM64',
    };
    return {
        machineType: machineTypes[machineType] || `Unknown (0x${machineType.toString(16)})`,
        numberOfSections,
        timeDateStamp,
        characteristics: parseCharacteristics(characteristics),
        optionalHeaderMagic: optionalHeaderMagic === 0x010B ? 'PE32' : optionalHeaderMagic === 0x020B ? 'PE32+' : 'Unknown',
        entryPoint,
        imageBase,
        subsystem: parseSubsystem(subsystem),
    };
};
exports.parsePEHeader = parsePEHeader;
/**
 * Extracts sections from PE file.
 *
 * @param {Buffer} buffer - PE file buffer
 * @returns {FileSection[]} Array of file sections
 *
 * @example
 * ```typescript
 * const sections = extractPESections(buffer);
 * // Result: [{ name: '.text', virtualAddress: 0x1000, ... }, ...]
 * ```
 */
const extractPESections = (buffer) => {
    const sections = [];
    const peOffset = buffer.readUInt32LE(60);
    const coffOffset = peOffset + 4;
    const numberOfSections = buffer.readUInt16LE(coffOffset + 2);
    const sizeOfOptionalHeader = buffer.readUInt16LE(coffOffset + 16);
    let sectionOffset = coffOffset + 20 + sizeOfOptionalHeader;
    for (let i = 0; i < numberOfSections; i++) {
        const nameBuffer = buffer.slice(sectionOffset, sectionOffset + 8);
        const name = nameBuffer.toString('ascii').replace(/\0/g, '');
        const virtualSize = buffer.readUInt32LE(sectionOffset + 8);
        const virtualAddress = buffer.readUInt32LE(sectionOffset + 12);
        const rawSize = buffer.readUInt32LE(sectionOffset + 16);
        const characteristics = buffer.readUInt32LE(sectionOffset + 36);
        const sectionData = buffer.slice(buffer.readUInt32LE(sectionOffset + 20), buffer.readUInt32LE(sectionOffset + 20) + rawSize);
        const entropy = (0, exports.calculateFileEntropy)(sectionData);
        sections.push({
            name,
            virtualAddress,
            virtualSize,
            rawSize,
            entropy,
            characteristics: parseSectionCharacteristics(characteristics),
        });
        sectionOffset += 40;
    }
    return sections;
};
exports.extractPESections = extractPESections;
/**
 * Helper function to parse PE characteristics flags.
 *
 * @param {number} characteristics - Characteristics value
 * @returns {string[]} Array of characteristic names
 */
const parseCharacteristics = (characteristics) => {
    const flags = [];
    const characteristicMap = {
        0x0001: 'RELOCS_STRIPPED',
        0x0002: 'EXECUTABLE_IMAGE',
        0x0004: 'LINE_NUMS_STRIPPED',
        0x0008: 'LOCAL_SYMS_STRIPPED',
        0x0020: 'LARGE_ADDRESS_AWARE',
        0x0100: '32BIT_MACHINE',
        0x0200: 'DEBUG_STRIPPED',
        0x1000: 'SYSTEM',
        0x2000: 'DLL',
    };
    for (const [flag, name] of Object.entries(characteristicMap)) {
        if (characteristics & parseInt(flag)) {
            flags.push(name);
        }
    }
    return flags;
};
/**
 * Helper function to parse PE subsystem.
 *
 * @param {number} subsystem - Subsystem value
 * @returns {string} Subsystem name
 */
const parseSubsystem = (subsystem) => {
    const subsystems = {
        1: 'NATIVE',
        2: 'WINDOWS_GUI',
        3: 'WINDOWS_CUI',
        7: 'POSIX_CUI',
        9: 'WINDOWS_CE_GUI',
        10: 'EFI_APPLICATION',
        11: 'EFI_BOOT_SERVICE_DRIVER',
        12: 'EFI_RUNTIME_DRIVER',
    };
    return subsystems[subsystem] || `Unknown (${subsystem})`;
};
/**
 * Helper function to parse section characteristics.
 *
 * @param {number} characteristics - Section characteristics value
 * @returns {string[]} Array of characteristic names
 */
const parseSectionCharacteristics = (characteristics) => {
    const flags = [];
    const characteristicMap = {
        0x00000020: 'CODE',
        0x00000040: 'INITIALIZED_DATA',
        0x00000080: 'UNINITIALIZED_DATA',
        0x20000000: 'EXECUTABLE',
        0x40000000: 'READABLE',
        0x80000000: 'WRITABLE',
    };
    for (const [flag, name] of Object.entries(characteristicMap)) {
        if (characteristics & parseInt(flag)) {
            flags.push(name);
        }
    }
    return flags;
};
// ============================================================================
// ELF FILE PARSING
// ============================================================================
/**
 * Parses ELF file header from buffer.
 *
 * @param {Buffer} buffer - ELF file buffer
 * @returns {ELFFileHeader | null} Parsed ELF header or null
 * @throws {Error} If buffer is not a valid ELF file
 *
 * @example
 * ```typescript
 * const buffer = fs.readFileSync('malware.elf');
 * const elfHeader = parseELFHeader(buffer);
 * // Result: { class: 'ELF64', data: 'little-endian', ... }
 * ```
 */
const parseELFHeader = (buffer) => {
    // Check ELF magic number
    if (buffer.length < 64 || buffer.readUInt32BE(0) !== 0x7F454C46) {
        throw new Error('Invalid ELF file: magic number not found');
    }
    const elfClass = buffer.readUInt8(4) === 1 ? 'ELF32' : 'ELF64';
    const elfData = buffer.readUInt8(5) === 1 ? 'little-endian' : 'big-endian';
    const version = buffer.readUInt8(6);
    const osAbi = buffer.readUInt8(7);
    const type = buffer.readUInt16LE(16);
    const machine = buffer.readUInt16LE(18);
    const entryPoint = elfClass === 'ELF32' ? buffer.readUInt32LE(24) : Number(buffer.readBigUInt64LE(24));
    const typeMap = {
        2: 'executable',
        3: 'shared_object',
        4: 'core',
    };
    const machineMap = {
        3: 'x86',
        62: 'x86-64',
        40: 'ARM',
        183: 'ARM64',
    };
    const osAbiMap = {
        0: 'UNIX System V',
        1: 'HP-UX',
        2: 'NetBSD',
        3: 'Linux',
        6: 'Solaris',
        9: 'FreeBSD',
    };
    return {
        class: elfClass,
        data: elfData,
        version,
        osAbi: osAbiMap[osAbi] || `Unknown (${osAbi})`,
        type: typeMap[type] || 'executable',
        machine: machineMap[machine] || `Unknown (${machine})`,
        entryPoint,
    };
};
exports.parseELFHeader = parseELFHeader;
// ============================================================================
// MACH-O FILE PARSING
// ============================================================================
/**
 * Parses Mach-O file header from buffer.
 *
 * @param {Buffer} buffer - Mach-O file buffer
 * @returns {MachOFileHeader | null} Parsed Mach-O header or null
 * @throws {Error} If buffer is not a valid Mach-O file
 *
 * @example
 * ```typescript
 * const buffer = fs.readFileSync('malware.macho');
 * const machoHeader = parseMachOHeader(buffer);
 * // Result: { magic: 'MH_MAGIC_64', cpuType: 'x86_64', ... }
 * ```
 */
const parseMachOHeader = (buffer) => {
    const magic = buffer.readUInt32BE(0);
    const validMagic = [0xFEEDFACE, 0xFEEDFACF, 0xCAFEBABE, 0xCEFAEDFE, 0xCFFAEDFE];
    if (!validMagic.includes(magic)) {
        throw new Error('Invalid Mach-O file: magic number not found');
    }
    const is64Bit = magic === 0xFEEDFACF || magic === 0xCFFAEDFE;
    const cpuType = buffer.readUInt32LE(4);
    const cpuSubtype = buffer.readUInt32LE(8);
    const fileType = buffer.readUInt32LE(12);
    const numberOfCommands = buffer.readUInt32LE(16);
    const flags = buffer.readUInt32LE(24);
    const cpuTypeMap = {
        7: 'x86',
        16777223: 'x86_64',
        12: 'ARM',
        16777228: 'ARM64',
    };
    const fileTypeMap = {
        2: 'executable',
        6: 'dylib',
        8: 'bundle',
    };
    return {
        magic: is64Bit ? 'MH_MAGIC_64' : 'MH_MAGIC',
        cpuType: cpuTypeMap[cpuType] || `Unknown (${cpuType})`,
        cpuSubtype: cpuSubtype.toString(),
        fileType: fileTypeMap[fileType] || 'executable',
        numberOfCommands,
        flags: parseMachOFlags(flags),
    };
};
exports.parseMachOHeader = parseMachOHeader;
/**
 * Helper function to parse Mach-O flags.
 *
 * @param {number} flags - Flags value
 * @returns {string[]} Array of flag names
 */
const parseMachOFlags = (flags) => {
    const flagNames = [];
    const flagMap = {
        0x1: 'NOUNDEFS',
        0x2: 'INCRLINK',
        0x4: 'DYLDLINK',
        0x8: 'BINDATLOAD',
        0x10: 'PREBOUND',
        0x200: 'PIE',
    };
    for (const [flag, name] of Object.entries(flagMap)) {
        if (flags & parseInt(flag)) {
            flagNames.push(name);
        }
    }
    return flagNames;
};
// ============================================================================
// SEQUELIZE MODEL UTILITIES
// ============================================================================
/**
 * Creates Sequelize model definition for malware samples.
 *
 * @returns {Record<string, any>} Sequelize model attributes
 *
 * @example
 * ```typescript
 * const MalwareSampleModel = sequelize.define('MalwareSample', createMalwareSampleModel());
 * ```
 */
const createMalwareSampleModel = () => {
    return {
        id: {
            type: 'UUID',
            defaultValue: 'UUIDV4',
            primaryKey: true,
        },
        md5: {
            type: 'STRING(32)',
            allowNull: false,
            unique: true,
        },
        sha1: {
            type: 'STRING(40)',
            allowNull: false,
            unique: true,
        },
        sha256: {
            type: 'STRING(64)',
            allowNull: false,
            unique: true,
        },
        fileSize: {
            type: 'INTEGER',
            allowNull: false,
        },
        fileType: {
            type: 'STRING(50)',
            allowNull: true,
        },
        firstSeen: {
            type: 'DATE',
            allowNull: false,
            defaultValue: 'NOW',
        },
        lastSeen: {
            type: 'DATE',
            allowNull: false,
            defaultValue: 'NOW',
        },
        malwareFamily: {
            type: 'STRING(100)',
            allowNull: true,
        },
        malwareType: {
            type: 'STRING(50)',
            allowNull: true,
        },
        isMalicious: {
            type: 'BOOLEAN',
            defaultValue: false,
        },
        analysisStatus: {
            type: 'STRING(20)',
            defaultValue: 'pending',
        },
    };
};
exports.createMalwareSampleModel = createMalwareSampleModel;
/**
 * Creates Sequelize query for finding malware by hash.
 *
 * @param {string} hash - Hash value (MD5, SHA1, or SHA256)
 * @returns {Record<string, any>} Sequelize where clause
 *
 * @example
 * ```typescript
 * const where = createMalwareHashQuery('abc123...');
 * const malware = await MalwareSample.findOne({ where });
 * ```
 */
const createMalwareHashQuery = (hash) => {
    const normalizedHash = (0, exports.normalizeHash)(hash);
    if ((0, exports.validateHashFormat)(normalizedHash, 'md5')) {
        return { md5: normalizedHash };
    }
    else if ((0, exports.validateHashFormat)(normalizedHash, 'sha1')) {
        return { sha1: normalizedHash };
    }
    else if ((0, exports.validateHashFormat)(normalizedHash, 'sha256')) {
        return { sha256: normalizedHash };
    }
    throw new Error('Invalid hash format');
};
exports.createMalwareHashQuery = createMalwareHashQuery;
/**
 * Creates Sequelize query for malware family search.
 *
 * @param {string} familyName - Malware family name
 * @param {Date} [startDate] - Start date filter
 * @param {Date} [endDate] - End date filter
 * @returns {Record<string, any>} Sequelize where clause
 *
 * @example
 * ```typescript
 * const where = createMalwareFamilyQuery('Emotet', new Date('2025-01-01'));
 * const samples = await MalwareSample.findAll({ where });
 * ```
 */
const createMalwareFamilyQuery = (familyName, startDate, endDate) => {
    const where = {
        malwareFamily: familyName,
    };
    if (startDate || endDate) {
        where.firstSeen = {};
        if (startDate)
            where.firstSeen.$gte = startDate;
        if (endDate)
            where.firstSeen.$lte = endDate;
    }
    return where;
};
exports.createMalwareFamilyQuery = createMalwareFamilyQuery;
// ============================================================================
// NESTJS SERVICE UTILITIES
// ============================================================================
/**
 * Creates NestJS service method for malware analysis.
 *
 * @param {Buffer} fileBuffer - File buffer to analyze
 * @returns {Promise<StaticAnalysisResult>} Static analysis result
 *
 * @example
 * ```typescript
 * // In NestJS service:
 * async analyzeFile(fileBuffer: Buffer): Promise<StaticAnalysisResult> {
 *   return await performStaticAnalysis(fileBuffer);
 * }
 * ```
 */
const performStaticAnalysis = async (fileBuffer) => {
    const hashes = (0, exports.computeAllHashes)(fileBuffer);
    const fileSignature = (0, exports.detectFileSignature)(fileBuffer);
    const entropy = (0, exports.calculateFileEntropy)(fileBuffer);
    const strings = (0, exports.extractStringsFromBuffer)(fileBuffer);
    let sections = [];
    let packers = [];
    try {
        if (fileSignature?.fileType === 'PE') {
            sections = (0, exports.extractPESections)(fileBuffer);
        }
        packers = (0, exports.identifyPackers)(fileBuffer, sections);
    }
    catch (error) {
        // Non-PE file or parsing error
    }
    const isSuspicious = entropy > 7.0 || packers.length > 0;
    const suspicionReasons = [];
    if (entropy > 7.0)
        suspicionReasons.push('High entropy (likely packed/encrypted)');
    if (packers.length > 0)
        suspicionReasons.push(`Packer detected: ${packers.join(', ')}`);
    return {
        hashes,
        fileSignature: fileSignature || { magicNumber: '', fileType: 'unknown', mimeType: '', extension: '', confidence: 0 },
        fileSize: fileBuffer.length,
        entropy,
        packers,
        imports: [],
        exports: [],
        sections,
        strings,
        isSuspicious,
        suspicionReasons,
    };
};
exports.performStaticAnalysis = performStaticAnalysis;
/**
 * Creates NestJS service method for sandbox submission.
 *
 * @param {string} sha256 - Malware SHA256 hash
 * @param {SandboxConfig} config - Sandbox configuration
 * @returns {Promise<string>} Sandbox analysis ID
 *
 * @example
 * ```typescript
 * // In NestJS service:
 * async submitToSandbox(sha256: string, config: SandboxConfig): Promise<string> {
 *   return await submitMalwareToSandbox(sha256, config);
 * }
 * ```
 */
const submitMalwareToSandbox = async (sha256, config) => {
    const analysisId = `analysis_${sha256.substring(0, 16)}_${Date.now()}`;
    // This would integrate with actual sandbox API
    return analysisId;
};
exports.submitMalwareToSandbox = submitMalwareToSandbox;
/**
 * Creates NestJS service method for retrieving malware by hash.
 *
 * @param {string} hash - Malware hash
 * @returns {Promise<MalwareSample | null>} Malware sample or null
 *
 * @example
 * ```typescript
 * // In NestJS service:
 * async getMalwareByHash(hash: string): Promise<MalwareSample | null> {
 *   return await retrieveMalwareByHash(hash);
 * }
 * ```
 */
const retrieveMalwareByHash = async (hash) => {
    const normalizedHash = (0, exports.normalizeHash)(hash);
    // This would query the database using Sequelize
    // For now, return a mock response
    return {
        sha256: normalizedHash,
        md5: '',
        sha1: '',
        fileSize: 0,
        fileType: 'unknown',
        firstSeen: new Date(),
        lastSeen: new Date(),
        isMalicious: false,
        analysisStatus: 'pending',
    };
};
exports.retrieveMalwareByHash = retrieveMalwareByHash;
// ============================================================================
// SWAGGER/OPENAPI DEFINITIONS
// ============================================================================
/**
 * Creates Swagger API documentation for malware upload endpoint.
 *
 * @returns {Record<string, any>} Swagger API specification
 *
 * @example
 * ```typescript
 * @ApiOperation(createMalwareUploadApiDoc())
 * @Post('/malware/upload')
 * async uploadMalware(@UploadedFile() file: Express.Multer.File) { ... }
 * ```
 */
const createMalwareUploadApiDoc = () => {
    return {
        summary: 'Upload malware sample for analysis',
        description: 'Uploads a malware sample file and initiates static and dynamic analysis',
        consumes: ['multipart/form-data'],
        requestBody: {
            content: {
                'multipart/form-data': {
                    schema: {
                        type: 'object',
                        properties: {
                            file: {
                                type: 'string',
                                format: 'binary',
                                description: 'Malware sample file',
                            },
                        },
                    },
                },
            },
        },
        responses: {
            201: {
                description: 'Malware uploaded and analysis initiated',
                schema: {
                    type: 'object',
                    properties: {
                        sha256: { type: 'string' },
                        analysisId: { type: 'string' },
                        status: { type: 'string' },
                    },
                },
            },
            400: { description: 'Invalid file upload' },
            500: { description: 'Internal server error' },
        },
    };
};
exports.createMalwareUploadApiDoc = createMalwareUploadApiDoc;
/**
 * Creates Swagger API documentation for malware analysis endpoint.
 *
 * @returns {Record<string, any>} Swagger API specification
 *
 * @example
 * ```typescript
 * @ApiOperation(createMalwareAnalysisApiDoc())
 * @Get('/malware/:hash/analysis')
 * async getMalwareAnalysis(@Param('hash') hash: string) { ... }
 * ```
 */
const createMalwareAnalysisApiDoc = () => {
    return {
        summary: 'Get malware analysis results',
        description: 'Retrieves static and dynamic analysis results for a malware sample',
        parameters: [
            {
                name: 'hash',
                in: 'path',
                required: true,
                description: 'Malware hash (MD5, SHA1, or SHA256)',
                schema: { type: 'string' },
            },
        ],
        responses: {
            200: {
                description: 'Analysis results retrieved',
                schema: {
                    type: 'object',
                    properties: {
                        hashes: { type: 'object' },
                        staticAnalysis: { type: 'object' },
                        dynamicAnalysis: { type: 'object' },
                        verdict: { type: 'string', enum: ['benign', 'suspicious', 'malicious'] },
                    },
                },
            },
            404: { description: 'Malware not found' },
            500: { description: 'Internal server error' },
        },
    };
};
exports.createMalwareAnalysisApiDoc = createMalwareAnalysisApiDoc;
/**
 * Creates Swagger schema for malware sample response.
 *
 * @returns {Record<string, any>} Swagger schema definition
 *
 * @example
 * ```typescript
 * @ApiResponse({ schema: createMalwareSampleSchema() })
 * ```
 */
const createMalwareSampleSchema = () => {
    return {
        type: 'object',
        properties: {
            id: { type: 'string', format: 'uuid' },
            md5: { type: 'string', pattern: '^[a-f0-9]{32}$' },
            sha1: { type: 'string', pattern: '^[a-f0-9]{40}$' },
            sha256: { type: 'string', pattern: '^[a-f0-9]{64}$' },
            fileSize: { type: 'integer' },
            fileType: { type: 'string' },
            malwareFamily: { type: 'string', nullable: true },
            malwareType: {
                type: 'string',
                enum: ['trojan', 'ransomware', 'worm', 'virus', 'rootkit', 'spyware', 'adware', 'backdoor', 'botnet', 'keylogger', 'cryptominer', 'downloader', 'dropper', 'apt', 'unknown'],
                nullable: true,
            },
            isMalicious: { type: 'boolean' },
            analysisStatus: {
                type: 'string',
                enum: ['pending', 'analyzing', 'completed', 'failed'],
            },
            firstSeen: { type: 'string', format: 'date-time' },
            lastSeen: { type: 'string', format: 'date-time' },
        },
        required: ['id', 'md5', 'sha1', 'sha256', 'fileSize', 'isMalicious', 'analysisStatus'],
    };
};
exports.createMalwareSampleSchema = createMalwareSampleSchema;
/**
 * Creates Swagger schema for YARA rule response.
 *
 * @returns {Record<string, any>} Swagger schema definition
 *
 * @example
 * ```typescript
 * @ApiResponse({ schema: createYaraRuleSchema() })
 * ```
 */
const createYaraRuleSchema = () => {
    return {
        type: 'object',
        properties: {
            ruleName: { type: 'string' },
            namespace: { type: 'string', nullable: true },
            tags: { type: 'array', items: { type: 'string' } },
            meta: { type: 'object', additionalProperties: { type: 'string' } },
            strings: {
                type: 'array',
                items: {
                    type: 'object',
                    properties: {
                        identifier: { type: 'string' },
                        type: { type: 'string', enum: ['text', 'hex', 'regex'] },
                        value: { type: 'string' },
                        modifiers: { type: 'array', items: { type: 'string' } },
                    },
                },
            },
            condition: { type: 'string' },
        },
        required: ['ruleName', 'tags', 'meta', 'strings', 'condition'],
    };
};
exports.createYaraRuleSchema = createYaraRuleSchema;
/**
 * Validates malware upload file constraints.
 *
 * @param {Express.Multer.File} file - Uploaded file
 * @param {number} [maxSizeBytes] - Maximum file size (default: 100MB)
 * @returns {{ isValid: boolean; error?: string }} Validation result
 *
 * @example
 * ```typescript
 * const validation = validateMalwareUpload(file, 104857600);
 * if (!validation.isValid) throw new Error(validation.error);
 * ```
 */
const validateMalwareUpload = (file, maxSizeBytes = 104857600) => {
    if (!file) {
        return { isValid: false, error: 'No file provided' };
    }
    if (file.size > maxSizeBytes) {
        return { isValid: false, error: `File size exceeds maximum allowed (${maxSizeBytes} bytes)` };
    }
    if (file.size === 0) {
        return { isValid: false, error: 'File is empty' };
    }
    return { isValid: true };
};
exports.validateMalwareUpload = validateMalwareUpload;
/**
 * Creates NestJS DTO for malware search query.
 *
 * @param {string} [hash] - Hash filter
 * @param {string} [family] - Malware family filter
 * @param {string} [type] - Malware type filter
 * @param {boolean} [maliciousOnly] - Filter only malicious samples
 * @returns {Record<string, any>} Query DTO
 *
 * @example
 * ```typescript
 * const dto = createMalwareSearchDto(undefined, 'Emotet', 'trojan', true);
 * // Use in controller query
 * ```
 */
const createMalwareSearchDto = (hash, family, type, maliciousOnly) => {
    const dto = {};
    if (hash)
        dto.hash = (0, exports.normalizeHash)(hash);
    if (family)
        dto.malwareFamily = family;
    if (type)
        dto.malwareType = type;
    if (maliciousOnly !== undefined)
        dto.isMalicious = maliciousOnly;
    return dto;
};
exports.createMalwareSearchDto = createMalwareSearchDto;
/**
 * Extracts metadata from malware sample for indexing.
 *
 * @param {Buffer} fileBuffer - File buffer
 * @param {StaticAnalysisResult} analysis - Static analysis result
 * @returns {Record<string, any>} Malware metadata
 *
 * @example
 * ```typescript
 * const metadata = extractMalwareMetadata(buffer, staticAnalysis);
 * // Result: { fileSize: 1024, entropy: 7.5, isPacked: true, ... }
 * ```
 */
const extractMalwareMetadata = (fileBuffer, analysis) => {
    return {
        fileSize: fileBuffer.length,
        entropy: analysis.entropy,
        isPacked: analysis.packers.length > 0,
        packers: analysis.packers,
        fileType: analysis.fileSignature.fileType,
        isSuspicious: analysis.isSuspicious,
        suspicionReasons: analysis.suspicionReasons,
        stringCount: analysis.strings.length,
        sectionCount: analysis.sections.length,
    };
};
exports.extractMalwareMetadata = extractMalwareMetadata;
/**
 * Generates malware analysis report summary.
 *
 * @param {SandboxResult} result - Sandbox analysis result
 * @returns {string} Human-readable analysis summary
 *
 * @example
 * ```typescript
 * const summary = generateAnalysisSummary(sandboxResult);
 * // Result: "Malicious: Detected ransomware behavior with C2 communication..."
 * ```
 */
const generateAnalysisSummary = (result) => {
    const verdictText = result.verdict.toUpperCase();
    const score = result.score;
    let summary = `${verdictText} (Score: ${score}/100)\n\n`;
    if (result.staticAnalysis.isSuspicious) {
        summary += `Static Analysis: ${result.staticAnalysis.suspicionReasons.join(', ')}\n`;
    }
    if (result.dynamicAnalysis.behaviors.length > 0) {
        summary += `\nDetected Behaviors:\n`;
        result.dynamicAnalysis.behaviors.forEach(behavior => {
            summary += `- [${behavior.severity.toUpperCase()}] ${behavior.technique}: ${behavior.description}\n`;
        });
    }
    if (result.dynamicAnalysis.networkConnections.length > 0) {
        summary += `\nNetwork Activity: ${result.dynamicAnalysis.networkConnections.length} connections detected\n`;
    }
    return summary;
};
exports.generateAnalysisSummary = generateAnalysisSummary;
/**
 * Compares two malware samples for similarity.
 *
 * @param {MalwareHash} hash1 - First malware hashes
 * @param {MalwareHash} hash2 - Second malware hashes
 * @returns {{ isSame: boolean; similarity: number }} Comparison result
 *
 * @example
 * ```typescript
 * const comparison = compareMalwareSamples(hashes1, hashes2);
 * // Result: { isSame: false, similarity: 0.0 }
 * ```
 */
const compareMalwareSamples = (hash1, hash2) => {
    if (hash1.sha256 === hash2.sha256) {
        return { isSame: true, similarity: 1.0 };
    }
    if (hash1.md5 === hash2.md5 || hash1.sha1 === hash2.sha1) {
        return { isSame: true, similarity: 1.0 };
    }
    // If ssdeep hashes are available, calculate fuzzy similarity
    if (hash1.ssdeep && hash2.ssdeep) {
        // Simplified fuzzy comparison (in real implementation, use ssdeep library)
        const similarity = hash1.ssdeep === hash2.ssdeep ? 1.0 : 0.0;
        return { isSame: false, similarity };
    }
    return { isSame: false, similarity: 0.0 };
};
exports.compareMalwareSamples = compareMalwareSamples;
/**
 * Creates batch analysis job configuration.
 *
 * @param {string[]} hashes - Array of malware hashes to analyze
 * @param {SandboxConfig} config - Sandbox configuration
 * @returns {Record<string, any>} Batch job configuration
 *
 * @example
 * ```typescript
 * const batchJob = createBatchAnalysisJob(['hash1', 'hash2', 'hash3'], sandboxConfig);
 * // Result: { jobId: 'batch_...', totalSamples: 3, config: {...} }
 * ```
 */
const createBatchAnalysisJob = (hashes, config) => {
    const jobId = `batch_${Date.now()}_${hashes.length}`;
    return {
        jobId,
        totalSamples: hashes.length,
        hashes,
        config,
        status: 'pending',
        createdAt: new Date().toISOString(),
        estimatedDuration: hashes.length * config.timeout,
    };
};
exports.createBatchAnalysisJob = createBatchAnalysisJob;
/**
 * Validates sandbox configuration parameters.
 *
 * @param {SandboxConfig} config - Sandbox configuration
 * @returns {{ isValid: boolean; errors: string[] }} Validation result
 *
 * @example
 * ```typescript
 * const validation = validateSandboxConfig(config);
 * if (!validation.isValid) throw new Error(validation.errors.join(', '));
 * ```
 */
const validateSandboxConfig = (config) => {
    const errors = [];
    if (config.timeout < 30000 || config.timeout > 3600000) {
        errors.push('Timeout must be between 30 seconds and 1 hour');
    }
    if (!['windows', 'linux', 'macos'].includes(config.vmType)) {
        errors.push('Invalid VM type');
    }
    if (config.enableInternet && !config.enableNetwork) {
        errors.push('Internet requires network to be enabled');
    }
    return {
        isValid: errors.length === 0,
        errors,
    };
};
exports.validateSandboxConfig = validateSandboxConfig;
/**
 * Generates malware report in JSON format for API response.
 *
 * @param {MalwareSample} sample - Malware sample
 * @param {SandboxResult} [sandboxResult] - Optional sandbox analysis result
 * @returns {Record<string, any>} JSON report
 *
 * @example
 * ```typescript
 * const jsonReport = generateMalwareJsonReport(sample, sandboxResult);
 * // Result: { sample: {...}, analysis: {...}, timestamp: '...' }
 * ```
 */
const generateMalwareJsonReport = (sample, sandboxResult) => {
    const report = {
        sample: {
            id: sample.id,
            md5: sample.md5,
            sha1: sample.sha1,
            sha256: sample.sha256,
            fileSize: sample.fileSize,
            fileType: sample.fileType,
            malwareFamily: sample.malwareFamily,
            malwareType: sample.malwareType,
            isMalicious: sample.isMalicious,
            firstSeen: sample.firstSeen,
            lastSeen: sample.lastSeen,
        },
        timestamp: new Date().toISOString(),
    };
    if (sandboxResult) {
        report.analysis = {
            verdict: sandboxResult.verdict,
            score: sandboxResult.score,
            status: sandboxResult.status,
            staticAnalysis: {
                entropy: sandboxResult.staticAnalysis.entropy,
                packers: sandboxResult.staticAnalysis.packers,
                isSuspicious: sandboxResult.staticAnalysis.isSuspicious,
            },
            dynamicAnalysis: {
                processCount: sandboxResult.dynamicAnalysis.processCreated.length,
                networkConnections: sandboxResult.dynamicAnalysis.networkConnections.length,
                behaviors: sandboxResult.dynamicAnalysis.behaviors.length,
                isMalicious: sandboxResult.dynamicAnalysis.isMalicious,
            },
        };
    }
    return report;
};
exports.generateMalwareJsonReport = generateMalwareJsonReport;
// ============================================================================
// EXPORTS
// ============================================================================
exports.default = {
    // Hash analysis
    computeMD5Hash: exports.computeMD5Hash,
    computeSHA1Hash: exports.computeSHA1Hash,
    computeSHA256Hash: exports.computeSHA256Hash,
    computeAllHashes: exports.computeAllHashes,
    validateHashFormat: exports.validateHashFormat,
    normalizeHash: exports.normalizeHash,
    // File signatures
    detectFileSignature: exports.detectFileSignature,
    extractMagicNumber: exports.extractMagicNumber,
    validateFileType: exports.validateFileType,
    // YARA rules
    createYaraRule: exports.createYaraRule,
    formatYaraRule: exports.formatYaraRule,
    parseYaraMatch: exports.parseYaraMatch,
    validateYaraRule: exports.validateYaraRule,
    // Malware family
    createMalwareFamily: exports.createMalwareFamily,
    determineDangerLevel: exports.determineDangerLevel,
    classifyMalwareByBehavior: exports.classifyMalwareByBehavior,
    updateFamilyPrevalence: exports.updateFamilyPrevalence,
    // Static analysis
    calculateFileEntropy: exports.calculateFileEntropy,
    isFilePacked: exports.isFilePacked,
    extractStringsFromBuffer: exports.extractStringsFromBuffer,
    detectStringType: exports.detectStringType,
    identifyPackers: exports.identifyPackers,
    // Dynamic analysis
    analyzeProcessBehavior: exports.analyzeProcessBehavior,
    analyzeNetworkBehavior: exports.analyzeNetworkBehavior,
    analyzeRegistryBehavior: exports.analyzeRegistryBehavior,
    calculateMaliciousScore: exports.calculateMaliciousScore,
    // Sandbox
    createSandboxConfig: exports.createSandboxConfig,
    validateSandboxResult: exports.validateSandboxResult,
    generateSandboxVerdict: exports.generateSandboxVerdict,
    // File parsing
    parsePEHeader: exports.parsePEHeader,
    extractPESections: exports.extractPESections,
    parseELFHeader: exports.parseELFHeader,
    parseMachOHeader: exports.parseMachOHeader,
    // Sequelize models
    createMalwareSampleModel: exports.createMalwareSampleModel,
    createMalwareHashQuery: exports.createMalwareHashQuery,
    createMalwareFamilyQuery: exports.createMalwareFamilyQuery,
    // NestJS services
    performStaticAnalysis: exports.performStaticAnalysis,
    submitMalwareToSandbox: exports.submitMalwareToSandbox,
    retrieveMalwareByHash: exports.retrieveMalwareByHash,
    // Swagger/OpenAPI
    createMalwareUploadApiDoc: exports.createMalwareUploadApiDoc,
    createMalwareAnalysisApiDoc: exports.createMalwareAnalysisApiDoc,
    createMalwareSampleSchema: exports.createMalwareSampleSchema,
    createYaraRuleSchema: exports.createYaraRuleSchema,
    validateMalwareUpload: exports.validateMalwareUpload,
    createMalwareSearchDto: exports.createMalwareSearchDto,
    // Additional utilities
    extractMalwareMetadata: exports.extractMalwareMetadata,
    generateAnalysisSummary: exports.generateAnalysisSummary,
    compareMalwareSamples: exports.compareMalwareSamples,
    createBatchAnalysisJob: exports.createBatchAnalysisJob,
    validateSandboxConfig: exports.validateSandboxConfig,
    generateMalwareJsonReport: exports.generateMalwareJsonReport,
};
//# sourceMappingURL=malware-analysis-kit.js.map