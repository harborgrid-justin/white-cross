"use strict";
/**
 * LOC: VUIN1234567
 * File: /reuse/threat/vulnerability-intelligence-kit.ts
 *
 * UPSTREAM (imports from):
 *   - None (leaf node - reusable utilities)
 *
 * DOWNSTREAM (imported by):
 *   - Threat intelligence services
 *   - Vulnerability analytics controllers
 *   - Security intelligence platforms
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateVulnerabilityIntelligenceAPISpec = exports.generateIntelligenceServiceProvider = exports.generateVulnerabilityIntelligenceAssociations = exports.enrichVulnerabilityWithFeeds = exports.validateIntelligenceFeed = exports.aggregateIntelligenceFeeds = exports.extractCPEFromNVD = exports.syncNVDFeed = exports.queryNVDDatabase = exports.parseNVDFeedEntry = exports.mapVulnerabilityToMITREATTACK = exports.correlateVulnerabilityWithThreats = exports.profileExploitKitCapabilities = exports.detectExploitKit = exports.compareVulnerabilityTrends = exports.predictVulnerabilityTrends = exports.analyzeVulnerabilityTrends = exports.identifyZeroDayIndicators = exports.trackZeroDayDisclosure = exports.registerZeroDayVulnerability = exports.assessWeaponizationPotential = exports.calculateEPSSScore = exports.predictExploitLikelihood = void 0;
correlation;
Score: number;
evidenceLinks: string[];
firstObserved: Date;
lastObserved: Date;
[];
attackPatterns: string[];
victimology: {
    sectors: string[];
    regions: string[];
    organizationSizes: string[];
}
;
recommendedActions: string[];
// ============================================================================
// EXPLOIT PREDICTION
// ============================================================================
/**
 * Predicts exploit likelihood for a vulnerability using ML-like heuristics.
 *
 * @param {string} cveId - CVE identifier
 * @param {object} features - Feature set for prediction
 * @returns {ExploitPrediction} Exploit prediction result
 *
 * @example
 * ```typescript
 * const prediction = predictExploitLikelihood('CVE-2024-1234', {
 *   cvssScore: 9.8,
 *   attackComplexity: 'LOW',
 *   publicDisclosure: true,
 *   vendorPatchAvailable: false,
 *   affectedProductPopularity: 0.95
 * });
 * // Result: { exploitProbability: 0.87, timeToExploit: 14, ... }
 * ```
 */
const predictExploitLikelihood = (cveId, features) => {
    const { cvssScore, attackComplexity, publicDisclosure, vendorPatchAvailable, affectedProductPopularity } = features;
    // Feature scoring (0-1 scale)
    const technicalComplexity = attackComplexity === 'LOW' ? 0.8 : 0.3;
    const attackSurfaceSize = affectedProductPopularity;
    const vendorResponseTime = vendorPatchAvailable ? 0.3 : 0.9;
    const publicInterest = publicDisclosure ? 0.7 : 0.2;
    const darkWebChatter = (features.socialMediaMentions || 0) / 1000;
    // Weighted probability calculation
    const exploitProbability = Math.min((cvssScore / 10) * 0.3 +
        technicalComplexity * 0.25 +
        attackSurfaceSize * 0.2 +
        vendorResponseTime * 0.15 +
        publicInterest * 0.1, 1.0);
    // Time to exploit estimation (days)
    const baseTime = 30;
    const complexityFactor = attackComplexity === 'LOW' ? 0.5 : 1.5;
    const disclosureFactor = publicDisclosure ? 0.6 : 1.2;
    const timeToExploit = Math.round(baseTime * complexityFactor * disclosureFactor * (1 - exploitProbability));
    const reasoning = [
        `CVSS score ${cvssScore} indicates ${cvssScore >= 7 ? 'high' : 'moderate'} severity`,
        `Attack complexity is ${attackComplexity}`,
        `Patch ${vendorPatchAvailable ? 'is' : 'is not'} available`,
        `${publicDisclosure ? 'Public' : 'Limited'} disclosure increases attention`,
    ];
    return {
        cveId,
        exploitProbability: Math.round(exploitProbability * 100) / 100,
        timeToExploit,
        predictionConfidence: 0.78,
        riskFactors: {
            technicalComplexity,
            attackSurfaceSize,
            vendorResponseTime,
            publicInterest,
            darkWebChatter: Math.min(darkWebChatter, 1),
        },
        predictedExploitDate: new Date(Date.now() + timeToExploit * 24 * 60 * 60 * 1000),
        reasoning,
    };
};
exports.predictExploitLikelihood = predictExploitLikelihood;
/**
 * Calculates EPSS (Exploit Prediction Scoring System) score.
 *
 * @param {object} vulnerability - Vulnerability metadata
 * @returns {number} EPSS score (0.0 - 1.0)
 *
 * @example
 * ```typescript
 * const epss = calculateEPSSScore({
 *   cveAge: 30,
 *   cvssScore: 9.1,
 *   references: 15,
 *   exploitCodeMaturity: 'FUNCTIONAL'
 * });
 * // Result: 0.64
 * ```
 */
const calculateEPSSScore = (vulnerability) => {
    const maturityScore = {
        UNPROVEN: 0.1,
        POC: 0.4,
        FUNCTIONAL: 0.7,
        HIGH: 0.95,
    }[vulnerability.exploitCodeMaturity];
    const ageWeight = Math.min(vulnerability.cveAge / 365, 1);
    const cvssWeight = vulnerability.cvssScore / 10;
    const referencesWeight = Math.min(vulnerability.references / 50, 1);
    const epss = maturityScore * 0.4 +
        cvssWeight * 0.3 +
        ageWeight * 0.2 +
        referencesWeight * 0.1;
    return Math.round(epss * 100) / 100;
};
exports.calculateEPSSScore = calculateEPSSScore;
/**
 * Assesses weaponization potential of a vulnerability.
 *
 * @param {string} cveId - CVE identifier
 * @param {object} characteristics - Vulnerability characteristics
 * @returns {object} Weaponization assessment
 *
 * @example
 * ```typescript
 * const assessment = assessWeaponizationPotential('CVE-2024-5678', {
 *   remoteExploitable: true,
 *   requiresAuth: false,
 *   impactScope: 'SYSTEM',
 *   exploitReliability: 0.95
 * });
 * ```
 */
const assessWeaponizationPotential = (cveId, characteristics) => {
    let score = 0;
    const factors = [];
    if (characteristics.remoteExploitable) {
        score += 40;
        factors.push('Remotely exploitable');
    }
    if (!characteristics.requiresAuth) {
        score += 30;
        factors.push('No authentication required');
    }
    if (characteristics.impactScope === 'SYSTEM') {
        score += 20;
        factors.push('System-level impact');
    }
    else if (characteristics.impactScope === 'APPLICATION') {
        score += 10;
    }
    score += characteristics.exploitReliability * 10;
    factors.push(`Reliability: ${(characteristics.exploitReliability * 100).toFixed(0)}%`);
    let potential;
    if (score >= 85)
        potential = 'VERY_HIGH';
    else if (score >= 65)
        potential = 'HIGH';
    else if (score >= 40)
        potential = 'MEDIUM';
    else
        potential = 'LOW';
    return { potential, score, factors };
};
exports.assessWeaponizationPotential = assessWeaponizationPotential;
// ============================================================================
// ZERO-DAY TRACKING
// ============================================================================
/**
 * Registers a new zero-day vulnerability discovery.
 *
 * @param {Partial<ZeroDayVulnerability>} zeroDay - Zero-day vulnerability data
 * @returns {ZeroDayVulnerability} Registered zero-day vulnerability
 *
 * @example
 * ```typescript
 * const zeroDay = registerZeroDayVulnerability({
 *   affectedProducts: [{ vendor: 'Microsoft', product: 'Exchange', versions: ['2019', '2016'] }],
 *   severity: 'CRITICAL',
 *   exploitationStatus: 'IN_THE_WILD'
 * });
 * ```
 */
const registerZeroDayVulnerability = (zeroDay) => {
    return {
        id: zeroDay.id || `ZERO-${Date.now()}`,
        discoveryDate: zeroDay.discoveryDate || new Date(),
        affectedProducts: zeroDay.affectedProducts || [],
        severity: zeroDay.severity || 'HIGH',
        exploitationStatus: zeroDay.exploitationStatus || 'THEORETICAL',
        ...zeroDay,
    };
};
exports.registerZeroDayVulnerability = registerZeroDayVulnerability;
/**
 * Tracks zero-day disclosure timeline.
 *
 * @param {ZeroDayVulnerability} zeroDay - Zero-day vulnerability
 * @returns {object} Disclosure timeline analysis
 *
 * @example
 * ```typescript
 * const timeline = trackZeroDayDisclosure(zeroDay);
 * // Result: { daysSinceDiscovery: 45, daysToVendorNotification: 3, daysToPublicDisclosure: 30 }
 * ```
 */
const trackZeroDayDisclosure = (zeroDay) => {
    const now = new Date();
    const daysSinceDiscovery = Math.floor((now.getTime() - zeroDay.discoveryDate.getTime()) / (1000 * 60 * 60 * 24));
    const daysToVendorNotification = zeroDay.vendorNotificationDate
        ? Math.floor((zeroDay.vendorNotificationDate.getTime() - zeroDay.discoveryDate.getTime()) / (1000 * 60 * 60 * 24))
        : undefined;
    const daysToPublicDisclosure = zeroDay.disclosureDate
        ? Math.floor((zeroDay.disclosureDate.getTime() - zeroDay.discoveryDate.getTime()) / (1000 * 60 * 60 * 24))
        : undefined;
    const isStillZeroDay = !zeroDay.disclosureDate;
    return {
        daysSinceDiscovery,
        daysToVendorNotification,
        daysToPublicDisclosure,
        isStillZeroDay,
    };
};
exports.trackZeroDayDisclosure = trackZeroDayDisclosure;
/**
 * Identifies potential zero-day indicators from vulnerability data.
 *
 * @param {object} vulnerability - Vulnerability data to analyze
 * @returns {object} Zero-day indicators
 *
 * @example
 * ```typescript
 * const indicators = identifyZeroDayIndicators({
 *   exploitInTheWild: true,
 *   vendorAwareness: false,
 *   publicCVE: false,
 *   unusualAttackPattern: true
 * });
 * ```
 */
const identifyZeroDayIndicators = (vulnerability) => {
    const indicators = [];
    let score = 0;
    if (vulnerability.exploitInTheWild && !vulnerability.publicCVE) {
        score += 40;
        indicators.push('Active exploitation without public CVE');
    }
    if (!vulnerability.vendorAwareness) {
        score += 30;
        indicators.push('Vendor appears unaware of vulnerability');
    }
    if (vulnerability.unusualAttackPattern) {
        score += 15;
        indicators.push('Novel attack pattern detected');
    }
    if (vulnerability.targetedAttacks) {
        score += 15;
        indicators.push('Targeted attacks observed');
    }
    return {
        isLikelyZeroDay: score >= 60,
        confidence: Math.min(score, 100) / 100,
        indicators,
    };
};
exports.identifyZeroDayIndicators = identifyZeroDayIndicators;
// ============================================================================
// VULNERABILITY TREND ANALYSIS
// ============================================================================
/**
 * Analyzes vulnerability trends over a time period.
 *
 * @param {Date} startDate - Analysis start date
 * @param {Date} endDate - Analysis end date
 * @param {any[]} vulnerabilities - Vulnerability dataset
 * @returns {VulnerabilityTrend} Trend analysis result
 *
 * @example
 * ```typescript
 * const trends = analyzeVulnerabilityTrends(
 *   new Date('2024-01-01'),
 *   new Date('2024-12-31'),
 *   vulnerabilityData
 * );
 * ```
 */
const analyzeVulnerabilityTrends = (startDate, endDate, vulnerabilities) => {
    const totalVulnerabilities = vulnerabilities.length;
    const severityDistribution = vulnerabilities.reduce((acc, v) => {
        const severity = (v.severity || 'LOW').toLowerCase();
        acc[severity] = (acc[severity] || 0) + 1;
        return acc;
    }, { critical: 0, high: 0, medium: 0, low: 0 });
    const vendorCounts = vulnerabilities.reduce((acc, v) => {
        const vendor = v.vendor || 'Unknown';
        acc[vendor] = (acc[vendor] || 0) + 1;
        return acc;
    }, {});
    const topVendors = Object.entries(vendorCounts)
        .map(([vendor, count]) => ({ vendor, count: count }))
        .sort((a, b) => b.count - a.count)
        .slice(0, 10);
    const cweCounts = vulnerabilities.reduce((acc, v) => {
        (v.cweIds || []).forEach((cwe) => {
            acc[cwe] = (acc[cwe] || 0) + 1;
        });
        return acc;
    }, {});
    const topCWEs = Object.entries(cweCounts)
        .map(([cweId, count]) => ({ cweId, count: count, description: `CWE ${cweId}` }))
        .sort((a, b) => b.count - a.count)
        .slice(0, 10);
    const exploitsPublished = vulnerabilities.filter(v => v.exploitAvailable).length;
    const zeroDay = vulnerabilities.filter(v => v.isZeroDay).length;
    const weaponized = vulnerabilities.filter(v => v.weaponized).length;
    const daysDiff = Math.ceil((endDate.getTime() - startDate.getTime()) / (1000 * 60 * 60 * 24));
    const period = daysDiff <= 7 ? 'daily' : daysDiff <= 31 ? 'weekly' : daysDiff <= 365 ? 'monthly' : 'yearly';
    return {
        period,
        startDate,
        endDate,
        totalVulnerabilities,
        severityDistribution,
        topVendors,
        topCWEs,
        exploitTrends: {
            exploitsPublished,
            zeroDay,
            weaponized,
        },
        growthRate: 0.12, // Placeholder
    };
};
exports.analyzeVulnerabilityTrends = analyzeVulnerabilityTrends;
/**
 * Predicts future vulnerability trends using historical data.
 *
 * @param {VulnerabilityTrend[]} historicalTrends - Historical trend data
 * @returns {object} Trend prediction
 *
 * @example
 * ```typescript
 * const forecast = predictVulnerabilityTrends(pastYearTrends);
 * // Result: { nextMonth: 450, confidence: 0.78, trendDirection: 'INCREASING' }
 * ```
 */
const predictVulnerabilityTrends = (historicalTrends) => {
    if (historicalTrends.length < 2) {
        return { nextPeriod: 0, confidence: 0, trendDirection: 'STABLE' };
    }
    const counts = historicalTrends.map(t => t.totalVulnerabilities);
    const avgGrowth = counts.slice(1).reduce((acc, val, idx) => acc + (val - counts[idx]), 0) / (counts.length - 1);
    const lastCount = counts[counts.length - 1];
    const nextPeriod = Math.max(0, Math.round(lastCount + avgGrowth));
    let trendDirection;
    if (avgGrowth > 5)
        trendDirection = 'INCREASING';
    else if (avgGrowth < -5)
        trendDirection = 'DECREASING';
    else
        trendDirection = 'STABLE';
    return {
        nextPeriod,
        confidence: 0.72,
        trendDirection,
    };
};
exports.predictVulnerabilityTrends = predictVulnerabilityTrends;
/**
 * Compares vulnerability trends across different time periods.
 *
 * @param {VulnerabilityTrend} current - Current period trend
 * @param {VulnerabilityTrend} previous - Previous period trend
 * @returns {object} Comparison result
 *
 * @example
 * ```typescript
 * const comparison = compareVulnerabilityTrends(thisMonthTrend, lastMonthTrend);
 * ```
 */
const compareVulnerabilityTrends = (current, previous) => {
    const volumeChange = ((current.totalVulnerabilities - previous.totalVulnerabilities) / previous.totalVulnerabilities) * 100;
    const severityShift = {
        critical: current.severityDistribution.critical - previous.severityDistribution.critical,
        high: current.severityDistribution.high - previous.severityDistribution.high,
        medium: current.severityDistribution.medium - previous.severityDistribution.medium,
        low: current.severityDistribution.low - previous.severityDistribution.low,
    };
    const topChanges = [
        `Total vulnerabilities ${volumeChange >= 0 ? 'increased' : 'decreased'} by ${Math.abs(volumeChange).toFixed(1)}%`,
        `Critical vulnerabilities changed by ${severityShift.critical}`,
    ];
    return { volumeChange, severityShift, topChanges };
};
exports.compareVulnerabilityTrends = compareVulnerabilityTrends;
// ============================================================================
// EXPLOIT KIT DETECTION
// ============================================================================
/**
 * Detects exploit kit signatures in attack data.
 *
 * @param {object} attackData - Attack data to analyze
 * @returns {object} Exploit kit detection result
 *
 * @example
 * ```typescript
 * const detection = detectExploitKit({
 *   payloadSignatures: ['signature1', 'signature2'],
 *   deliveryMethod: 'malvertising',
 *   targetedCVEs: ['CVE-2024-1234']
 * });
 * ```
 */
const detectExploitKit = (attackData) => {
    const knownKits = {
        'Angler': { signatures: ['sig_angler_1', 'sig_angler_2'], cves: ['CVE-2015-5119', 'CVE-2016-0189'] },
        'RIG': { signatures: ['sig_rig_1', 'sig_rig_2'], cves: ['CVE-2018-8174', 'CVE-2019-0752'] },
        'Magnitude': { signatures: ['sig_mag_1'], cves: ['CVE-2021-26411'] },
    };
    for (const [kitName, kitData] of Object.entries(knownKits)) {
        const matchedSignatures = attackData.payloadSignatures.filter(s => kitData.signatures.includes(s));
        const matchedCVEs = attackData.targetedCVEs.filter(c => kitData.cves.includes(c));
        if (matchedSignatures.length > 0 || matchedCVEs.length > 0) {
            const confidence = (matchedSignatures.length + matchedCVEs.length) / (kitData.signatures.length + kitData.cves.length);
            return {
                detected: true,
                kitName,
                confidence: Math.min(confidence, 1),
                matchedSignatures,
            };
        }
    }
    return { detected: false, confidence: 0, matchedSignatures: [] };
};
exports.detectExploitKit = detectExploitKit;
/**
 * Profiles exploit kit capabilities and behavior.
 *
 * @param {ExploitKit} kit - Exploit kit to profile
 * @returns {object} Capability profile
 *
 * @example
 * ```typescript
 * const profile = profileExploitKitCapabilities(exploitKit);
 * ```
 */
const profileExploitKitCapabilities = (kit) => {
    const capabilities = [
        `Targets ${kit.targetedVulnerabilities.length} known vulnerabilities`,
        `Uses ${kit.deliveryMethods.join(', ')} for delivery`,
        `Delivers ${kit.payloadTypes.join(', ')} payloads`,
    ];
    let threatLevel;
    if (kit.prevalence === 'WIDESPREAD' && kit.sophistication === 'ADVANCED') {
        threatLevel = 'CRITICAL';
    }
    else if (kit.prevalence === 'WIDESPREAD' || kit.sophistication === 'ADVANCED') {
        threatLevel = 'HIGH';
    }
    else if (kit.prevalence === 'MODERATE') {
        threatLevel = 'MEDIUM';
    }
    else {
        threatLevel = 'LOW';
    }
    const recommendations = [
        'Deploy signatures to IDS/IPS systems',
        'Block known delivery domains',
        'Patch targeted vulnerabilities immediately',
    ];
    return { threatLevel, capabilities, recommendations };
};
exports.profileExploitKitCapabilities = profileExploitKitCapabilities;
// ============================================================================
// THREAT CORRELATION
// ============================================================================
/**
 * Correlates vulnerability with threat intelligence.
 *
 * @param {string} cveId - CVE identifier
 * @param {any[]} threatIntelligence - Threat intelligence data
 * @returns {ThreatCorrelation} Correlation result
 *
 * @example
 * ```typescript
 * const correlation = correlateVulnerabilityWithThreats('CVE-2024-1234', threatData);
 * ```
 */
const correlateVulnerabilityWithThreats = (cveId, threatIntelligence) => {
    const correlatedThreats = threatIntelligence
        .filter(threat => threat.targetedCVEs?.includes(cveId))
        .map(threat => ({
        threatId: threat.id,
        threatType: threat.type || 'MALWARE',
        correlationScore: 0.85,
        evidenceLinks: threat.references || [],
        firstObserved: new Date(threat.firstSeen || Date.now()),
        lastObserved: new Date(threat.lastSeen || Date.now()),
    }));
    const attackPatterns = [...new Set(threatIntelligence.flatMap(t => t.attackPatterns || []))];
    const sectors = [...new Set(threatIntelligence.flatMap(t => t.targetSectors || []))];
    const regions = [...new Set(threatIntelligence.flatMap(t => t.targetRegions || []))];
    return {
        cveId,
        correlatedThreats,
        attackPatterns,
        victimology: {
            sectors,
            regions,
            organizationSizes: ['LARGE', 'MEDIUM'],
        },
        recommendedActions: [
            'Monitor for indicators of compromise',
            'Implement additional detection rules',
            'Prioritize patching for this CVE',
        ],
    };
};
exports.correlateVulnerabilityWithThreats = correlateVulnerabilityWithThreats;
/**
 * Maps vulnerability to MITRE ATT&CK techniques.
 *
 * @param {string} cveId - CVE identifier
 * @param {object} exploitCharacteristics - Exploit characteristics
 * @returns {object} MITRE ATT&CK mapping
 *
 * @example
 * ```typescript
 * const mapping = mapVulnerabilityToMITREATTACK('CVE-2024-1234', {
 *   exploitType: 'remote_code_execution',
 *   targetComponent: 'web_application'
 * });
 * ```
 */
const mapVulnerabilityToMITREATTACK = (cveId, exploitCharacteristics) => {
    const techniqueMap = {
        remote_code_execution: [
            { id: 'T1190', name: 'Exploit Public-Facing Application', tactic: 'Initial Access' },
            { id: 'T1203', name: 'Exploitation for Client Execution', tactic: 'Execution' },
        ],
        privilege_escalation: [
            { id: 'T1068', name: 'Exploitation for Privilege Escalation', tactic: 'Privilege Escalation' },
        ],
        sql_injection: [
            { id: 'T1190', name: 'Exploit Public-Facing Application', tactic: 'Initial Access' },
            { id: 'T1213', name: 'Data from Information Repositories', tactic: 'Collection' },
        ],
    };
    const techniques = techniqueMap[exploitCharacteristics.exploitType] || [];
    const tactics = [...new Set(techniques.map(t => t.tactic))];
    return { tactics, techniques };
};
exports.mapVulnerabilityToMITREATTACK = mapVulnerabilityToMITREATTACK;
// ============================================================================
// NVD INTEGRATION
// ============================================================================
/**
 * Parses NVD JSON feed entry.
 *
 * @param {any} nvdEntry - Raw NVD JSON entry
 * @returns {NVDFeedEntry} Parsed NVD entry
 *
 * @example
 * ```typescript
 * const parsed = parseNVDFeedEntry(rawNVDData);
 * ```
 */
const parseNVDFeedEntry = (nvdEntry) => {
    return {
        cveId: nvdEntry.cve?.id || '',
        sourceIdentifier: nvdEntry.cve?.sourceIdentifier || '',
        published: new Date(nvdEntry.cve?.published || Date.now()),
        lastModified: new Date(nvdEntry.cve?.lastModified || Date.now()),
        vulnStatus: nvdEntry.cve?.vulnStatus || 'AWAITING_ANALYSIS',
        descriptions: nvdEntry.cve?.descriptions || [],
        metrics: nvdEntry.cve?.metrics || {},
        weaknesses: nvdEntry.cve?.weaknesses || [],
        configurations: nvdEntry.cve?.configurations || [],
        references: nvdEntry.cve?.references || [],
    };
};
exports.parseNVDFeedEntry = parseNVDFeedEntry;
/**
 * Queries NVD database with filters.
 *
 * @param {object} filters - Query filters
 * @returns {Promise<NVDFeedEntry[]>} Filtered NVD entries
 *
 * @example
 * ```typescript
 * const results = await queryNVDDatabase({
 *   startDate: new Date('2024-01-01'),
 *   endDate: new Date('2024-12-31'),
 *   severity: 'HIGH',
 *   keyword: 'remote code execution'
 * });
 * ```
 */
const queryNVDDatabase = async (filters) => {
    // Mock implementation - in production, this would call NVD API
    const mockEntries = [
        {
            cveId: 'CVE-2024-1234',
            sourceIdentifier: 'nvd@nist.gov',
            published: new Date('2024-06-15'),
            lastModified: new Date('2024-06-16'),
            vulnStatus: 'ANALYZED',
            descriptions: [{ lang: 'en', value: 'Remote code execution vulnerability' }],
            metrics: {},
            weaknesses: [],
            configurations: [],
            references: [],
        },
    ];
    return mockEntries;
};
exports.queryNVDDatabase = queryNVDDatabase;
/**
 * Synchronizes local database with NVD feed.
 *
 * @param {Date} lastSync - Last synchronization timestamp
 * @returns {Promise<object>} Sync result
 *
 * @example
 * ```typescript
 * const syncResult = await syncNVDFeed(lastSyncDate);
 * // Result: { newEntries: 145, updatedEntries: 23, syncTime: Date }
 * ```
 */
const syncNVDFeed = async (lastSync) => {
    // Mock implementation
    return {
        newEntries: 145,
        updatedEntries: 23,
        syncTime: new Date(),
    };
};
exports.syncNVDFeed = syncNVDFeed;
/**
 * Extracts CPE (Common Platform Enumeration) from NVD entry.
 *
 * @param {NVDFeedEntry} entry - NVD feed entry
 * @returns {string[]} CPE identifiers
 *
 * @example
 * ```typescript
 * const cpes = extractCPEFromNVD(nvdEntry);
 * // Result: ['cpe:2.3:a:vendor:product:1.0:*:*:*:*:*:*:*']
 * ```
 */
const extractCPEFromNVD = (entry) => {
    const cpes = [];
    entry.configurations.forEach((config) => {
        if (config.nodes) {
            config.nodes.forEach((node) => {
                if (node.cpeMatch) {
                    node.cpeMatch.forEach((match) => {
                        if (match.criteria) {
                            cpes.push(match.criteria);
                        }
                    });
                }
            });
        }
    });
    return [...new Set(cpes)];
};
exports.extractCPEFromNVD = extractCPEFromNVD;
// ============================================================================
// INTELLIGENCE FEEDS
// ============================================================================
/**
 * Aggregates multiple intelligence feeds.
 *
 * @param {IntelligenceFeed[]} feeds - Intelligence feeds to aggregate
 * @returns {object} Aggregated intelligence
 *
 * @example
 * ```typescript
 * const aggregated = aggregateIntelligenceFeeds([nvdFeed, cisaFeed, exploitDbFeed]);
 * ```
 */
const aggregateIntelligenceFeeds = (feeds) => {
    const totalEntries = feeds.reduce((sum, feed) => sum + feed.entriesCount, 0);
    const coverageMap = {};
    feeds.forEach(feed => {
        feed.coverage.forEach(area => {
            coverageMap[area] = (coverageMap[area] || 0) + 1;
        });
    });
    const lastUpdate = new Date(Math.max(...feeds.map(f => f.lastUpdated.getTime())));
    return { totalEntries, coverageMap, lastUpdate };
};
exports.aggregateIntelligenceFeeds = aggregateIntelligenceFeeds;
/**
 * Validates intelligence feed data quality.
 *
 * @param {IntelligenceFeed} feed - Intelligence feed to validate
 * @returns {object} Validation result
 *
 * @example
 * ```typescript
 * const validation = validateIntelligenceFeed(feed);
 * ```
 */
const validateIntelligenceFeed = (feed) => {
    const issues = [];
    let score = 100;
    if (feed.dataQuality < 0.7) {
        issues.push('Data quality below acceptable threshold');
        score -= 20;
    }
    const hoursSinceUpdate = (Date.now() - feed.lastUpdated.getTime()) / (1000 * 60 * 60);
    if (hoursSinceUpdate > 48) {
        issues.push('Feed not updated in 48+ hours');
        score -= 15;
    }
    if (feed.entriesCount === 0) {
        issues.push('Feed contains no entries');
        score -= 30;
    }
    if (feed.reliability === 'UNCONFIRMED') {
        issues.push('Feed reliability is unconfirmed');
        score -= 10;
    }
    return {
        isValid: score >= 60,
        score: Math.max(0, score),
        issues,
    };
};
exports.validateIntelligenceFeed = validateIntelligenceFeed;
/**
 * Enriches vulnerability data with intelligence feeds.
 *
 * @param {string} cveId - CVE identifier
 * @param {IntelligenceFeed[]} feeds - Intelligence feeds
 * @returns {Promise<object>} Enriched vulnerability data
 *
 * @example
 * ```typescript
 * const enriched = await enrichVulnerabilityWithFeeds('CVE-2024-1234', intelligenceFeeds);
 * ```
 */
const enrichVulnerabilityWithFeeds = async (cveId, feeds) => {
    const enrichments = {};
    const sources = [];
    // Mock enrichment from multiple feeds
    feeds.forEach(feed => {
        enrichments[feed.feedType] = {
            lastUpdated: feed.lastUpdated,
            reliability: feed.reliability,
            data: {},
        };
        sources.push(feed.feedName);
    });
    return { cveId, enrichments, sources };
};
exports.enrichVulnerabilityWithFeeds = enrichVulnerabilityWithFeeds;
// ============================================================================
// SEQUELIZE ASSOCIATIONS
// ============================================================================
/**
 * Generates Sequelize associations for vulnerability intelligence.
 *
 * @returns {string} Sequelize association code
 *
 * @example
 * ```typescript
 * const associations = generateVulnerabilityIntelligenceAssociations();
 * ```
 */
const generateVulnerabilityIntelligenceAssociations = () => {
    return `
// CVE to Threat Intelligence associations
CVE.hasMany(ThreatCorrelation, { foreignKey: 'cveId', as: 'threatCorrelations' });
ThreatCorrelation.belongsTo(CVE, { foreignKey: 'cveId' });

// CVE to Exploit Prediction associations
CVE.hasOne(ExploitPrediction, { foreignKey: 'cveId', as: 'exploitPrediction' });
ExploitPrediction.belongsTo(CVE, { foreignKey: 'cveId' });

// Zero-Day to CVE associations (eventual linking)
ZeroDayVulnerability.belongsTo(CVE, { foreignKey: 'cveId', as: 'assignedCVE' });
CVE.hasOne(ZeroDayVulnerability, { foreignKey: 'cveId', as: 'zeroDay' });

// Exploit Kit to CVE associations (many-to-many)
ExploitKit.belongsToMany(CVE, { through: 'ExploitKitCVEs', as: 'targetedVulnerabilities' });
CVE.belongsToMany(ExploitKit, { through: 'ExploitKitCVEs', as: 'exploitKits' });

// Intelligence Feed to CVE associations
IntelligenceFeed.hasMany(CVE, { foreignKey: 'sourceFeedId', as: 'vulnerabilities' });
CVE.belongsTo(IntelligenceFeed, { foreignKey: 'sourceFeedId', as: 'sourceFeed' });
`.trim();
};
exports.generateVulnerabilityIntelligenceAssociations = generateVulnerabilityIntelligenceAssociations;
// ============================================================================
// NESTJS PROVIDERS
// ============================================================================
/**
 * Generates NestJS provider for intelligence services.
 *
 * @returns {string} NestJS provider code
 *
 * @example
 * ```typescript
 * const provider = generateIntelligenceServiceProvider();
 * ```
 */
const generateIntelligenceServiceProvider = () => {
    return `
import { Injectable } from '@nestjs/common';
import { InjectModel } from '@nestjs/sequelize';
import { ExploitPrediction } from './models/exploit-prediction.model';
import { ZeroDayVulnerability } from './models/zero-day.model';
import { ThreatCorrelation } from './models/threat-correlation.model';

@Injectable()
export class VulnerabilityIntelligenceService {
  constructor(
    @InjectModel(ExploitPrediction) private exploitPredictionModel: typeof ExploitPrediction,
    @InjectModel(ZeroDayVulnerability) private zeroDayModel: typeof ZeroDayVulnerability,
    @InjectModel(ThreatCorrelation) private threatCorrelationModel: typeof ThreatCorrelation,
  ) {}

  async predictExploit(cveId: string): Promise<ExploitPrediction> {
    // Prediction logic
    return this.exploitPredictionModel.findOne({ where: { cveId } });
  }

  async trackZeroDay(id: string): Promise<ZeroDayVulnerability> {
    return this.zeroDayModel.findByPk(id);
  }

  async getThreats Correlated(cveId: string): Promise<ThreatCorrelation[]> {
    return this.threatCorrelationModel.findAll({ where: { cveId } });
  }

  async generateIntelligenceReport(period: { start: Date; end: Date }): Promise<any> {
    // Report generation logic
    return {};
  }
}
`.trim();
};
exports.generateIntelligenceServiceProvider = generateIntelligenceServiceProvider;
// ============================================================================
// API ENDPOINTS
// ============================================================================
/**
 * Generates OpenAPI specification for vulnerability intelligence API.
 *
 * @returns {string} OpenAPI YAML specification
 *
 * @example
 * ```typescript
 * const apiSpec = generateVulnerabilityIntelligenceAPISpec();
 * ```
 */
const generateVulnerabilityIntelligenceAPISpec = () => {
    return `
openapi: 3.0.0
info:
  title: Vulnerability Intelligence API
  version: 1.0.0
  description: API for vulnerability intelligence, exploit prediction, and threat correlation

paths:
  /api/intelligence/predict-exploit/{cveId}:
    get:
      summary: Predict exploit likelihood
      parameters:
        - name: cveId
          in: path
          required: true
          schema:
            type: string
      responses:
        '200':
          description: Exploit prediction
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ExploitPrediction'

  /api/intelligence/zero-days:
    get:
      summary: List zero-day vulnerabilities
      responses:
        '200':
          description: Zero-day vulnerabilities
          content:
            application/json:
              schema:
                type: array
                items:
                  $ref: '#/components/schemas/ZeroDayVulnerability'

  /api/intelligence/trends:
    get:
      summary: Get vulnerability trends
      parameters:
        - name: startDate
          in: query
          schema:
            type: string
            format: date
        - name: endDate
          in: query
          schema:
            type: string
            format: date
      responses:
        '200':
          description: Vulnerability trends
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/VulnerabilityTrend'

  /api/intelligence/correlate/{cveId}:
    get:
      summary: Correlate vulnerability with threats
      parameters:
        - name: cveId
          in: path
          required: true
          schema:
            type: string
      responses:
        '200':
          description: Threat correlations
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ThreatCorrelation'

components:
  schemas:
    ExploitPrediction:
      type: object
      properties:
        cveId:
          type: string
        exploitProbability:
          type: number
        timeToExploit:
          type: integer
        predictedExploitDate:
          type: string
          format: date-time

    ZeroDayVulnerability:
      type: object
      properties:
        id:
          type: string
        discoveryDate:
          type: string
          format: date-time
        severity:
          type: string
          enum: [CRITICAL, HIGH, MEDIUM, LOW]
        exploitationStatus:
          type: string
          enum: [IN_THE_WILD, POC_AVAILABLE, THEORETICAL]
`.trim();
};
exports.generateVulnerabilityIntelligenceAPISpec = generateVulnerabilityIntelligenceAPISpec;
// ============================================================================
// EXPORTS
// ============================================================================
exports.default = {
    // Exploit prediction
    predictExploitLikelihood: exports.predictExploitLikelihood,
    calculateEPSSScore: exports.calculateEPSSScore,
    assessWeaponizationPotential: exports.assessWeaponizationPotential,
    // Zero-day tracking
    registerZeroDayVulnerability: exports.registerZeroDayVulnerability,
    trackZeroDayDisclosure: exports.trackZeroDayDisclosure,
    identifyZeroDayIndicators: exports.identifyZeroDayIndicators,
    // Trend analysis
    analyzeVulnerabilityTrends: exports.analyzeVulnerabilityTrends,
    predictVulnerabilityTrends: exports.predictVulnerabilityTrends,
    compareVulnerabilityTrends: exports.compareVulnerabilityTrends,
    // Exploit kit detection
    detectExploitKit: exports.detectExploitKit,
    profileExploitKitCapabilities: exports.profileExploitKitCapabilities,
    // Threat correlation
    correlateVulnerabilityWithThreats: exports.correlateVulnerabilityWithThreats,
    mapVulnerabilityToMITREATTACK: exports.mapVulnerabilityToMITREATTACK,
    // NVD integration
    parseNVDFeedEntry: exports.parseNVDFeedEntry,
    queryNVDDatabase: exports.queryNVDDatabase,
    syncNVDFeed: exports.syncNVDFeed,
    extractCPEFromNVD: exports.extractCPEFromNVD,
    // Intelligence feeds
    aggregateIntelligenceFeeds: exports.aggregateIntelligenceFeeds,
    validateIntelligenceFeed: exports.validateIntelligenceFeed,
    enrichVulnerabilityWithFeeds: exports.enrichVulnerabilityWithFeeds,
    // Code generation
    generateVulnerabilityIntelligenceAssociations: exports.generateVulnerabilityIntelligenceAssociations,
    generateIntelligenceServiceProvider: exports.generateIntelligenceServiceProvider,
    generateVulnerabilityIntelligenceAPISpec: exports.generateVulnerabilityIntelligenceAPISpec,
};
//# sourceMappingURL=vulnerability-intelligence-kit.js.map