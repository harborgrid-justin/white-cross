"use strict";
/**
 * LOC: VUMG1234567
 * File: /reuse/threat/vulnerability-management-kit.ts
 *
 * UPSTREAM (imports from):
 *   - None (leaf node - reusable utilities)
 *
 * DOWNSTREAM (imported by):
 *   - Vulnerability management services
 *   - Security scanning controllers
 *   - Patch management systems
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateVulnerabilityAPISpec = exports.generateVulnerabilityTypeDefinitions = exports.generateVulnerabilityManagementService = exports.generateVulnerabilityTrackingSchema = exports.generateVulnerabilityLifecycleModel = exports.generateCVESequelizeModel = exports.sortVulnerabilitiesByPriority = exports.prioritizeVulnerability = exports.groupAssetsBySeverity = exports.calculateAssetRiskScore = exports.mapVulnerabilitiesToAssets = exports.generatePatchDeploymentPlan = exports.validatePatchApplicability = exports.createPatchMetadata = exports.assignVulnerabilityDueDate = exports.calculateVulnerabilitySLA = exports.transitionVulnerabilityStatus = exports.createVulnerabilityLifecycle = exports.generateCVSSv3Vector = exports.parseCVSSv3Vector = exports.getCVSSv3Severity = exports.calculateCVSSv3BaseScore = exports.calculateCVSSv2BaseScore = exports.compareCVEIds = exports.extractCVEsFromText = exports.normalizeCVEId = exports.validateCVEId = exports.parseCVEIdentifier = void 0;
// ============================================================================
// CVE PARSING AND VALIDATION
// ============================================================================
/**
 * Parses CVE identifier string into structured components.
 *
 * @param {string} cveId - CVE identifier (e.g., "CVE-2024-12345")
 * @returns {CVEIdentifier} Parsed CVE identifier
 * @throws {Error} If CVE ID format is invalid
 *
 * @example
 * ```typescript
 * const cve = parseCVEIdentifier('CVE-2024-12345');
 * // Result: { id: 'CVE-2024-12345', year: 2024, sequence: 12345, isValid: true }
 * ```
 */
const parseCVEIdentifier = (cveId) => {
    const cvePattern = /^CVE-(\d{4})-(\d{4,})$/i;
    const match = cveId.match(cvePattern);
    if (!match) {
        throw new Error(`Invalid CVE identifier format: ${cveId}`);
    }
    const year = parseInt(match[1], 10);
    const sequence = parseInt(match[2], 10);
    return {
        id: cveId.toUpperCase(),
        year,
        sequence,
        isValid: year >= 1999 && year <= new Date().getFullYear() + 1,
    };
};
exports.parseCVEIdentifier = parseCVEIdentifier;
/**
 * Validates CVE identifier format and year range.
 *
 * @param {string} cveId - CVE identifier to validate
 * @returns {boolean} True if CVE ID is valid
 *
 * @example
 * ```typescript
 * validateCVEId('CVE-2024-12345'); // true
 * validateCVEId('CVE-1998-123'); // false (year too old)
 * validateCVEId('INVALID-2024-123'); // false (wrong format)
 * ```
 */
const validateCVEId = (cveId) => {
    try {
        const parsed = (0, exports.parseCVEIdentifier)(cveId);
        return parsed.isValid;
    }
    catch {
        return false;
    }
};
exports.validateCVEId = validateCVEId;
/**
 * Normalizes CVE identifier to standard uppercase format.
 *
 * @param {string} cveId - CVE identifier (any case)
 * @returns {string} Normalized CVE identifier
 *
 * @example
 * ```typescript
 * const normalized = normalizeCVEId('cve-2024-12345');
 * // Result: 'CVE-2024-12345'
 * ```
 */
const normalizeCVEId = (cveId) => {
    const parsed = (0, exports.parseCVEIdentifier)(cveId);
    return parsed.id;
};
exports.normalizeCVEId = normalizeCVEId;
/**
 * Extracts all CVE identifiers from text.
 *
 * @param {string} text - Text containing CVE references
 * @returns {string[]} Array of unique CVE identifiers
 *
 * @example
 * ```typescript
 * const cves = extractCVEsFromText('Found CVE-2024-1234 and cve-2024-5678 vulnerabilities');
 * // Result: ['CVE-2024-1234', 'CVE-2024-5678']
 * ```
 */
const extractCVEsFromText = (text) => {
    const cvePattern = /CVE-\d{4}-\d{4,}/gi;
    const matches = text.match(cvePattern) || [];
    const uniqueCVEs = [...new Set(matches.map(cve => cve.toUpperCase()))];
    return uniqueCVEs.filter(exports.validateCVEId);
};
exports.extractCVEsFromText = extractCVEsFromText;
/**
 * Compares two CVE identifiers for sorting.
 *
 * @param {string} cveA - First CVE identifier
 * @param {string} cveB - Second CVE identifier
 * @returns {number} Comparison result (-1, 0, 1)
 *
 * @example
 * ```typescript
 * const sorted = ['CVE-2023-1234', 'CVE-2024-5678', 'CVE-2023-9999']
 *   .sort(compareCVEIds);
 * // Result: ['CVE-2023-1234', 'CVE-2023-9999', 'CVE-2024-5678']
 * ```
 */
const compareCVEIds = (cveA, cveB) => {
    const a = (0, exports.parseCVEIdentifier)(cveA);
    const b = (0, exports.parseCVEIdentifier)(cveB);
    if (a.year !== b.year)
        return a.year - b.year;
    return a.sequence - b.sequence;
};
exports.compareCVEIds = compareCVEIds;
// ============================================================================
// CVSS SCORE CALCULATION
// ============================================================================
/**
 * Calculates CVSS v2 base score from metrics.
 *
 * @param {Omit<CVSSv2Score, 'baseScore' | 'vectorString' | 'version'>} metrics - CVSS v2 metrics
 * @returns {number} CVSS v2 base score (0.0 - 10.0)
 *
 * @example
 * ```typescript
 * const score = calculateCVSSv2BaseScore({
 *   accessVector: 'N',
 *   accessComplexity: 'L',
 *   authentication: 'N',
 *   confidentialityImpact: 'C',
 *   integrityImpact: 'C',
 *   availabilityImpact: 'C'
 * });
 * // Result: 10.0
 * ```
 */
const calculateCVSSv2BaseScore = (metrics) => {
    const avMap = { L: 0.395, A: 0.646, N: 1.0 };
    const acMap = { H: 0.35, M: 0.61, L: 0.71 };
    const auMap = { M: 0.45, S: 0.56, N: 0.704 };
    const impactMap = { N: 0.0, P: 0.275, C: 0.660 };
    const av = avMap[metrics.accessVector];
    const ac = acMap[metrics.accessComplexity];
    const au = auMap[metrics.authentication];
    const confImpact = impactMap[metrics.confidentialityImpact];
    const intImpact = impactMap[metrics.integrityImpact];
    const availImpact = impactMap[metrics.availabilityImpact];
    const impact = 10.41 * (1 - (1 - confImpact) * (1 - intImpact) * (1 - availImpact));
    const exploitability = 20 * av * ac * au;
    const fImpact = impact === 0 ? 0 : 1.176;
    const baseScore = ((0.6 * impact) + (0.4 * exploitability) - 1.5) * fImpact;
    return Math.round(baseScore * 10) / 10;
};
exports.calculateCVSSv2BaseScore = calculateCVSSv2BaseScore;
/**
 * Calculates CVSS v3 base score from metrics.
 *
 * @param {Omit<CVSSv3Score, 'baseScore' | 'baseSeverity' | 'vectorString' | 'version'>} metrics - CVSS v3 metrics
 * @returns {number} CVSS v3 base score (0.0 - 10.0)
 *
 * @example
 * ```typescript
 * const score = calculateCVSSv3BaseScore({
 *   attackVector: 'N',
 *   attackComplexity: 'L',
 *   privilegesRequired: 'N',
 *   userInteraction: 'N',
 *   scope: 'U',
 *   confidentialityImpact: 'H',
 *   integrityImpact: 'H',
 *   availabilityImpact: 'H'
 * });
 * // Result: 9.8
 * ```
 */
const calculateCVSSv3BaseScore = (metrics) => {
    const avMap = { N: 0.85, A: 0.62, L: 0.55, P: 0.2 };
    const acMap = { L: 0.77, H: 0.44 };
    const prMap = { U: { N: 0.85, L: 0.62, H: 0.27 }, C: { N: 0.85, L: 0.68, H: 0.5 } };
    const uiMap = { N: 0.85, R: 0.62 };
    const impactMap = { N: 0.0, L: 0.22, H: 0.56 };
    const av = avMap[metrics.attackVector];
    const ac = acMap[metrics.attackComplexity];
    const pr = prMap[metrics.scope][metrics.privilegesRequired];
    const ui = uiMap[metrics.userInteraction];
    const confImpact = impactMap[metrics.confidentialityImpact];
    const intImpact = impactMap[metrics.integrityImpact];
    const availImpact = impactMap[metrics.availabilityImpact];
    const iscBase = 1 - ((1 - confImpact) * (1 - intImpact) * (1 - availImpact));
    let impact;
    if (metrics.scope === 'U') {
        impact = 6.42 * iscBase;
    }
    else {
        impact = 7.52 * (iscBase - 0.029) - 3.25 * Math.pow(iscBase - 0.02, 15);
    }
    const exploitability = 8.22 * av * ac * pr * ui;
    let baseScore;
    if (impact <= 0) {
        baseScore = 0;
    }
    else if (metrics.scope === 'U') {
        baseScore = Math.min(impact + exploitability, 10);
    }
    else {
        baseScore = Math.min(1.08 * (impact + exploitability), 10);
    }
    return Math.round(baseScore * 10) / 10;
};
exports.calculateCVSSv3BaseScore = calculateCVSSv3BaseScore;
/**
 * Determines CVSS v3 severity rating from score.
 *
 * @param {number} score - CVSS v3 base score
 * @returns {'NONE' | 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL'} Severity rating
 *
 * @example
 * ```typescript
 * getCVSSv3Severity(9.8); // 'CRITICAL'
 * getCVSSv3Severity(5.5); // 'MEDIUM'
 * getCVSSv3Severity(0.0); // 'NONE'
 * ```
 */
const getCVSSv3Severity = (score) => {
    if (score === 0.0)
        return 'NONE';
    if (score >= 0.1 && score <= 3.9)
        return 'LOW';
    if (score >= 4.0 && score <= 6.9)
        return 'MEDIUM';
    if (score >= 7.0 && score <= 8.9)
        return 'HIGH';
    return 'CRITICAL';
};
exports.getCVSSv3Severity = getCVSSv3Severity;
/**
 * Parses CVSS v3 vector string into metrics.
 *
 * @param {string} vectorString - CVSS v3 vector string
 * @returns {Partial<CVSSv3Score>} Parsed CVSS v3 metrics
 * @throws {Error} If vector string format is invalid
 *
 * @example
 * ```typescript
 * const metrics = parseCVSSv3Vector('CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H');
 * // Result: { version: '3.1', attackVector: 'N', attackComplexity: 'L', ... }
 * ```
 */
const parseCVSSv3Vector = (vectorString) => {
    const parts = vectorString.split('/');
    if (parts.length < 2 || !parts[0].startsWith('CVSS:')) {
        throw new Error('Invalid CVSS v3 vector string format');
    }
    const version = parts[0].split(':')[1];
    const metrics = { version, vectorString };
    const metricMap = {
        AV: 'attackVector',
        AC: 'attackComplexity',
        PR: 'privilegesRequired',
        UI: 'userInteraction',
        S: 'scope',
        C: 'confidentialityImpact',
        I: 'integrityImpact',
        A: 'availabilityImpact',
    };
    for (let i = 1; i < parts.length; i++) {
        const [key, value] = parts[i].split(':');
        const metricKey = metricMap[key];
        if (metricKey) {
            metrics[metricKey] = value;
        }
    }
    return metrics;
};
exports.parseCVSSv3Vector = parseCVSSv3Vector;
/**
 * Generates CVSS v3 vector string from metrics.
 *
 * @param {Omit<CVSSv3Score, 'baseScore' | 'baseSeverity' | 'vectorString'>} metrics - CVSS v3 metrics
 * @returns {string} CVSS v3 vector string
 *
 * @example
 * ```typescript
 * const vector = generateCVSSv3Vector({
 *   version: '3.1',
 *   attackVector: 'N', attackComplexity: 'L', privilegesRequired: 'N',
 *   userInteraction: 'N', scope: 'U', confidentialityImpact: 'H',
 *   integrityImpact: 'H', availabilityImpact: 'H'
 * });
 * // Result: 'CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H'
 * ```
 */
const generateCVSSv3Vector = (metrics) => {
    return `CVSS:${metrics.version}/AV:${metrics.attackVector}/AC:${metrics.attackComplexity}/` +
        `PR:${metrics.privilegesRequired}/UI:${metrics.userInteraction}/S:${metrics.scope}/` +
        `C:${metrics.confidentialityImpact}/I:${metrics.integrityImpact}/A:${metrics.availabilityImpact}`;
};
exports.generateCVSSv3Vector = generateCVSSv3Vector;
// ============================================================================
// VULNERABILITY LIFECYCLE MANAGEMENT
// ============================================================================
/**
 * Creates initial vulnerability lifecycle record.
 *
 * @param {string} cveId - CVE identifier
 * @param {'CRITICAL' | 'HIGH' | 'MEDIUM' | 'LOW' | 'INFO'} priority - Initial priority
 * @returns {VulnerabilityLifecycle} Lifecycle record
 *
 * @example
 * ```typescript
 * const lifecycle = createVulnerabilityLifecycle('CVE-2024-12345', 'HIGH');
 * // Result: { status: 'NEW', detectedDate: Date, priority: 'HIGH', notes: [] }
 * ```
 */
const createVulnerabilityLifecycle = (cveId, priority) => {
    return {
        status: 'NEW',
        detectedDate: new Date(),
        priority,
        notes: [`Vulnerability ${cveId} detected with priority ${priority}`],
    };
};
exports.createVulnerabilityLifecycle = createVulnerabilityLifecycle;
/**
 * Transitions vulnerability to next lifecycle status.
 *
 * @param {VulnerabilityLifecycle} lifecycle - Current lifecycle
 * @param {'TRIAGED' | 'IN_PROGRESS' | 'PATCHED' | 'ACCEPTED' | 'CLOSED' | 'REOPENED'} newStatus - New status
 * @param {string} [note] - Optional transition note
 * @returns {VulnerabilityLifecycle} Updated lifecycle
 *
 * @example
 * ```typescript
 * const updated = transitionVulnerabilityStatus(lifecycle, 'TRIAGED', 'Assessed by security team');
 * ```
 */
const transitionVulnerabilityStatus = (lifecycle, newStatus, note) => {
    const updated = { ...lifecycle, status: newStatus };
    const now = new Date();
    switch (newStatus) {
        case 'TRIAGED':
            updated.triagedDate = now;
            break;
        case 'PATCHED':
            updated.patchedDate = now;
            break;
        case 'CLOSED':
            updated.closedDate = now;
            break;
    }
    if (note) {
        updated.notes = [...lifecycle.notes, `[${newStatus}] ${note}`];
    }
    return updated;
};
exports.transitionVulnerabilityStatus = transitionVulnerabilityStatus;
/**
 * Calculates SLA breach status for vulnerability.
 *
 * @param {VulnerabilityLifecycle} lifecycle - Vulnerability lifecycle
 * @returns {object} SLA status with breach information
 *
 * @example
 * ```typescript
 * const sla = calculateVulnerabilitySLA(lifecycle);
 * // Result: { isBreached: true, daysOverdue: 5, daysRemaining: -5 }
 * ```
 */
const calculateVulnerabilitySLA = (lifecycle) => {
    if (!lifecycle.dueDate) {
        return { isBreached: false, daysOverdue: 0, daysRemaining: Infinity };
    }
    const now = new Date();
    const dueDate = new Date(lifecycle.dueDate);
    const diffMs = dueDate.getTime() - now.getTime();
    const daysRemaining = Math.ceil(diffMs / (1000 * 60 * 60 * 24));
    const isBreached = daysRemaining < 0;
    const daysOverdue = isBreached ? Math.abs(daysRemaining) : 0;
    return { isBreached, daysOverdue, daysRemaining };
};
exports.calculateVulnerabilitySLA = calculateVulnerabilitySLA;
/**
 * Assigns due date based on vulnerability priority and policy.
 *
 * @param {'CRITICAL' | 'HIGH' | 'MEDIUM' | 'LOW' | 'INFO'} priority - Vulnerability priority
 * @param {Date} [detectedDate] - Detection date (defaults to now)
 * @returns {Date} Calculated due date
 *
 * @example
 * ```typescript
 * const dueDate = assignVulnerabilityDueDate('CRITICAL');
 * // Result: Date 7 days from now
 * ```
 */
const assignVulnerabilityDueDate = (priority, detectedDate = new Date()) => {
    const daysByPriority = {
        CRITICAL: 7,
        HIGH: 30,
        MEDIUM: 90,
        LOW: 180,
        INFO: 365,
    };
    const days = daysByPriority[priority];
    const dueDate = new Date(detectedDate);
    dueDate.setDate(dueDate.getDate() + days);
    return dueDate;
};
exports.assignVulnerabilityDueDate = assignVulnerabilityDueDate;
// ============================================================================
// PATCH MANAGEMENT
// ============================================================================
/**
 * Creates patch metadata record.
 *
 * @param {Partial<PatchMetadata>} patchData - Patch information
 * @returns {PatchMetadata} Complete patch metadata
 *
 * @example
 * ```typescript
 * const patch = createPatchMetadata({
 *   cveIds: ['CVE-2024-1234'],
 *   vendor: 'Microsoft',
 *   product: 'Windows Server',
 *   version: '2019',
 *   releaseDate: new Date()
 * });
 * ```
 */
const createPatchMetadata = (patchData) => {
    return {
        patchId: patchData.patchId || `PATCH-${Date.now()}`,
        cveIds: patchData.cveIds || [],
        vendor: patchData.vendor || '',
        product: patchData.product || '',
        version: patchData.version || '',
        releaseDate: patchData.releaseDate || new Date(),
        requiresReboot: patchData.requiresReboot ?? false,
        rollbackSupported: patchData.rollbackSupported ?? true,
        ...patchData,
    };
};
exports.createPatchMetadata = createPatchMetadata;
/**
 * Validates patch applicability to target system.
 *
 * @param {PatchMetadata} patch - Patch metadata
 * @param {object} targetSystem - Target system information
 * @returns {object} Applicability result
 *
 * @example
 * ```typescript
 * const result = validatePatchApplicability(patch, {
 *   vendor: 'Microsoft',
 *   product: 'Windows Server',
 *   version: '2019'
 * });
 * // Result: { applicable: true, reason: 'Patch matches target system' }
 * ```
 */
const validatePatchApplicability = (patch, targetSystem) => {
    if (patch.vendor !== targetSystem.vendor) {
        return { applicable: false, reason: 'Vendor mismatch' };
    }
    if (patch.product !== targetSystem.product) {
        return { applicable: false, reason: 'Product mismatch' };
    }
    if (patch.version !== targetSystem.version) {
        return { applicable: false, reason: 'Version mismatch' };
    }
    return { applicable: true, reason: 'Patch matches target system' };
};
exports.validatePatchApplicability = validatePatchApplicability;
/**
 * Generates patch deployment plan.
 *
 * @param {PatchMetadata[]} patches - Patches to deploy
 * @param {object} options - Deployment options
 * @returns {object} Deployment plan
 *
 * @example
 * ```typescript
 * const plan = generatePatchDeploymentPlan(patches, {
 *   rolloutStrategy: 'phased',
 *   maintenanceWindow: { start: '22:00', end: '06:00' }
 * });
 * ```
 */
const generatePatchDeploymentPlan = (patches, options) => {
    const rebootRequired = patches.some(p => p.requiresReboot);
    const criticalPatches = patches.filter(p => p.cveIds.some(cve => cve.includes('CRITICAL')));
    const normalPatches = patches.filter(p => !criticalPatches.includes(p));
    if (options.rolloutStrategy === 'phased') {
        return {
            phases: [
                { patches: criticalPatches, requiresReboot: criticalPatches.some(p => p.requiresReboot) },
                { patches: normalPatches, requiresReboot: normalPatches.some(p => p.requiresReboot) },
            ],
        };
    }
    return {
        phases: [{ patches, requiresReboot }],
    };
};
exports.generatePatchDeploymentPlan = generatePatchDeploymentPlan;
// ============================================================================
// ASSET-VULNERABILITY MAPPING
// ============================================================================
/**
 * Maps vulnerabilities to assets.
 *
 * @param {string[]} assetIds - Asset identifiers
 * @param {VulnerabilityMetadata[]} vulnerabilities - Vulnerabilities to map
 * @returns {AssetVulnerabilityMapping[]} Asset-vulnerability mappings
 *
 * @example
 * ```typescript
 * const mappings = mapVulnerabilitiesToAssets(
 *   ['asset-1', 'asset-2'],
 *   [vuln1, vuln2]
 * );
 * ```
 */
const mapVulnerabilitiesToAssets = (assetIds, vulnerabilities) => {
    return assetIds.map(assetId => ({
        assetId,
        assetName: `Asset ${assetId}`,
        assetType: 'unknown',
        vulnerabilities: vulnerabilities.map(v => ({
            cveId: v.cveId,
            severity: v.cvssScores.v3?.baseSeverity || 'UNKNOWN',
            status: 'NEW',
            detectedDate: new Date(),
            affectedComponent: 'unknown',
        })),
        riskScore: (0, exports.calculateAssetRiskScore)(vulnerabilities),
        lastScanDate: new Date(),
    }));
};
exports.mapVulnerabilitiesToAssets = mapVulnerabilitiesToAssets;
/**
 * Calculates risk score for asset based on vulnerabilities.
 *
 * @param {VulnerabilityMetadata[]} vulnerabilities - Vulnerabilities affecting asset
 * @returns {number} Risk score (0-100)
 *
 * @example
 * ```typescript
 * const riskScore = calculateAssetRiskScore([vuln1, vuln2, vuln3]);
 * // Result: 85.5
 * ```
 */
const calculateAssetRiskScore = (vulnerabilities) => {
    if (vulnerabilities.length === 0)
        return 0;
    const scores = vulnerabilities.map(v => v.cvssScores.v3?.baseScore || v.cvssScores.v2?.baseScore || 0);
    const maxScore = Math.max(...scores);
    const avgScore = scores.reduce((a, b) => a + b, 0) / scores.length;
    const count = vulnerabilities.length;
    // Weighted formula: max score (50%), average score (30%), count factor (20%)
    const riskScore = (maxScore * 5) + (avgScore * 3) + Math.min(count * 2, 20);
    return Math.min(Math.round(riskScore * 10) / 10, 100);
};
exports.calculateAssetRiskScore = calculateAssetRiskScore;
/**
 * Groups assets by vulnerability severity.
 *
 * @param {AssetVulnerabilityMapping[]} mappings - Asset-vulnerability mappings
 * @returns {Record<string, AssetVulnerabilityMapping[]>} Grouped assets
 *
 * @example
 * ```typescript
 * const grouped = groupAssetsBySeverity(mappings);
 * // Result: { CRITICAL: [...], HIGH: [...], MEDIUM: [...] }
 * ```
 */
const groupAssetsBySeverity = (mappings) => {
    return mappings.reduce((groups, mapping) => {
        const maxSeverity = mapping.vulnerabilities.reduce((max, v) => {
            const severityOrder = { CRITICAL: 5, HIGH: 4, MEDIUM: 3, LOW: 2, INFO: 1, UNKNOWN: 0 };
            return (severityOrder[v.severity] || 0) >
                (severityOrder[max] || 0)
                ? v.severity
                : max;
        }, 'UNKNOWN');
        if (!groups[maxSeverity])
            groups[maxSeverity] = [];
        groups[maxSeverity].push(mapping);
        return groups;
    }, {});
};
exports.groupAssetsBySeverity = groupAssetsBySeverity;
// ============================================================================
// VULNERABILITY PRIORITIZATION
// ============================================================================
/**
 * Calculates vulnerability priority score with business context.
 *
 * @param {VulnerabilityMetadata} vulnerability - Vulnerability metadata
 * @param {object} context - Business and threat context
 * @returns {VulnerabilityPrioritization} Prioritization result
 *
 * @example
 * ```typescript
 * const priority = prioritizeVulnerability(vuln, {
 *   assetCriticality: 0.9,
 *   exploitAvailable: true,
 *   businessImpact: 0.8
 * });
 * ```
 */
const prioritizeVulnerability = (vulnerability, context) => {
    const baseScore = vulnerability.cvssScores.v3?.baseScore || vulnerability.cvssScores.v2?.baseScore || 0;
    const exploitability = (vulnerability.epssScore || 0) * 10;
    const exploitBonus = (vulnerability.exploitAvailable || context.exploitAvailable) ? 2 : 0;
    const threatLevel = Math.min((exploitability + exploitBonus) / 10, 1);
    const adjustedScore = (baseScore * 0.4 +
        context.businessImpact * 10 * 0.25 +
        exploitability * 0.2 +
        context.assetCriticality * 10 * 0.15);
    const reasoning = [
        `Base CVSS: ${baseScore}`,
        `Business impact: ${context.businessImpact}`,
        `Asset criticality: ${context.assetCriticality}`,
        `Exploit available: ${vulnerability.exploitAvailable || context.exploitAvailable}`,
    ];
    let finalPriority;
    if (adjustedScore >= 9.0)
        finalPriority = 'P0';
    else if (adjustedScore >= 7.0)
        finalPriority = 'P1';
    else if (adjustedScore >= 5.0)
        finalPriority = 'P2';
    else if (adjustedScore >= 3.0)
        finalPriority = 'P3';
    else
        finalPriority = 'P4';
    return {
        cveId: vulnerability.cveId,
        baseScore,
        adjustedScore: Math.round(adjustedScore * 10) / 10,
        businessImpact: context.businessImpact,
        exploitability,
        assetCriticality: context.assetCriticality,
        threatLevel,
        finalPriority,
        reasoning,
    };
};
exports.prioritizeVulnerability = prioritizeVulnerability;
/**
 * Sorts vulnerabilities by priority for remediation.
 *
 * @param {VulnerabilityPrioritization[]} prioritizations - Prioritized vulnerabilities
 * @returns {VulnerabilityPrioritization[]} Sorted vulnerabilities
 *
 * @example
 * ```typescript
 * const sorted = sortVulnerabilitiesByPriority(prioritizations);
 * // Result: [P0 vulns, P1 vulns, P2 vulns, ...]
 * ```
 */
const sortVulnerabilitiesByPriority = (prioritizations) => {
    const priorityOrder = { P0: 0, P1: 1, P2: 2, P3: 3, P4: 4 };
    return [...prioritizations].sort((a, b) => {
        if (priorityOrder[a.finalPriority] !== priorityOrder[b.finalPriority]) {
            return priorityOrder[a.finalPriority] - priorityOrder[b.finalPriority];
        }
        return b.adjustedScore - a.adjustedScore;
    });
};
exports.sortVulnerabilitiesByPriority = sortVulnerabilitiesByPriority;
// ============================================================================
// SEQUELIZE MODELS
// ============================================================================
/**
 * Generates Sequelize model for CVE data.
 *
 * @returns {string} Sequelize model definition code
 *
 * @example
 * ```typescript
 * const modelCode = generateCVESequelizeModel();
 * // Returns: Complete Sequelize model class definition
 * ```
 */
const generateCVESequelizeModel = () => {
    return `
import { Table, Column, Model, DataType, Index, HasMany } from 'sequelize-typescript';

@Table({ tableName: 'cves', timestamps: true })
export class CVE extends Model {
  @Column({ type: DataType.UUID, primaryKey: true, defaultValue: DataType.UUIDV4 })
  id: string;

  @Index
  @Column({ type: DataType.STRING(20), unique: true, allowNull: false })
  cveId: string;

  @Column({ type: DataType.INTEGER, allowNull: false })
  year: number;

  @Column({ type: DataType.INTEGER, allowNull: false })
  sequence: number;

  @Column({ type: DataType.TEXT, allowNull: false })
  description: string;

  @Index
  @Column({ type: DataType.DATE, allowNull: false })
  publishedDate: Date;

  @Column({ type: DataType.DATE, allowNull: false })
  lastModifiedDate: Date;

  @Column({ type: DataType.JSONB })
  cvssV2: any;

  @Column({ type: DataType.JSONB })
  cvssV3: any;

  @Column({ type: DataType.JSONB })
  cvssV4: any;

  @Column({ type: DataType.ARRAY(DataType.STRING) })
  cweIds: string[];

  @Column({ type: DataType.ARRAY(DataType.STRING) })
  references: string[];

  @Column({ type: DataType.JSONB })
  affectedProducts: any;

  @Column({ type: DataType.STRING })
  vendorAdvisory: string;

  @Index
  @Column({ type: DataType.FLOAT })
  epssScore: number;

  @Index
  @Column({ type: DataType.BOOLEAN, defaultValue: false })
  exploitAvailable: boolean;

  @HasMany(() => VulnerabilityFinding)
  findings: VulnerabilityFinding[];
}
`.trim();
};
exports.generateCVESequelizeModel = generateCVESequelizeModel;
/**
 * Generates Sequelize model for vulnerability lifecycle.
 *
 * @returns {string} Sequelize model definition code
 *
 * @example
 * ```typescript
 * const modelCode = generateVulnerabilityLifecycleModel();
 * ```
 */
const generateVulnerabilityLifecycleModel = () => {
    return `
import { Table, Column, Model, DataType, Index, BelongsTo, ForeignKey } from 'sequelize-typescript';

@Table({ tableName: 'vulnerability_lifecycles', timestamps: true })
export class VulnerabilityLifecycle extends Model {
  @Column({ type: DataType.UUID, primaryKey: true, defaultValue: DataType.UUIDV4 })
  id: string;

  @ForeignKey(() => CVE)
  @Index
  @Column({ type: DataType.UUID, allowNull: false })
  cveId: string;

  @BelongsTo(() => CVE)
  cve: CVE;

  @Index
  @Column({
    type: DataType.ENUM('NEW', 'TRIAGED', 'IN_PROGRESS', 'PATCHED', 'ACCEPTED', 'CLOSED', 'REOPENED'),
    allowNull: false,
    defaultValue: 'NEW'
  })
  status: string;

  @Index
  @Column({ type: DataType.DATE, allowNull: false })
  detectedDate: Date;

  @Column({ type: DataType.DATE })
  triagedDate: Date;

  @Column({ type: DataType.DATE })
  patchedDate: Date;

  @Column({ type: DataType.DATE })
  closedDate: Date;

  @Column({ type: DataType.STRING })
  assignedTo: string;

  @Index
  @Column({
    type: DataType.ENUM('CRITICAL', 'HIGH', 'MEDIUM', 'LOW', 'INFO'),
    allowNull: false
  })
  priority: string;

  @Column({ type: DataType.DATE })
  dueDate: Date;

  @Column({ type: DataType.ARRAY(DataType.TEXT), defaultValue: [] })
  notes: string[];
}
`.trim();
};
exports.generateVulnerabilityLifecycleModel = generateVulnerabilityLifecycleModel;
// ============================================================================
// DATABASE SCHEMA
// ============================================================================
/**
 * Generates database migration for vulnerability tracking schema.
 *
 * @returns {string} Sequelize migration code
 *
 * @example
 * ```typescript
 * const migration = generateVulnerabilityTrackingSchema();
 * ```
 */
const generateVulnerabilityTrackingSchema = () => {
    return `
module.exports = {
  up: async (queryInterface, Sequelize) => {
    await queryInterface.createTable('cves', {
      id: { type: Sequelize.UUID, primaryKey: true, defaultValue: Sequelize.UUIDV4 },
      cveId: { type: Sequelize.STRING(20), unique: true, allowNull: false },
      year: { type: Sequelize.INTEGER, allowNull: false },
      sequence: { type: Sequelize.INTEGER, allowNull: false },
      description: { type: Sequelize.TEXT, allowNull: false },
      publishedDate: { type: Sequelize.DATE, allowNull: false },
      lastModifiedDate: { type: Sequelize.DATE, allowNull: false },
      cvssV2: { type: Sequelize.JSONB },
      cvssV3: { type: Sequelize.JSONB },
      cvssV4: { type: Sequelize.JSONB },
      cweIds: { type: Sequelize.ARRAY(Sequelize.STRING) },
      references: { type: Sequelize.ARRAY(Sequelize.STRING) },
      affectedProducts: { type: Sequelize.JSONB },
      vendorAdvisory: { type: Sequelize.STRING },
      epssScore: { type: Sequelize.FLOAT },
      exploitAvailable: { type: Sequelize.BOOLEAN, defaultValue: false },
      createdAt: { type: Sequelize.DATE, allowNull: false },
      updatedAt: { type: Sequelize.DATE, allowNull: false },
    });

    await queryInterface.addIndex('cves', ['cveId']);
    await queryInterface.addIndex('cves', ['publishedDate']);
    await queryInterface.addIndex('cves', ['epssScore']);
    await queryInterface.addIndex('cves', ['exploitAvailable']);

    await queryInterface.createTable('vulnerability_lifecycles', {
      id: { type: Sequelize.UUID, primaryKey: true, defaultValue: Sequelize.UUIDV4 },
      cveId: { type: Sequelize.UUID, allowNull: false, references: { model: 'cves', key: 'id' } },
      status: { type: Sequelize.ENUM('NEW', 'TRIAGED', 'IN_PROGRESS', 'PATCHED', 'ACCEPTED', 'CLOSED', 'REOPENED'), allowNull: false },
      detectedDate: { type: Sequelize.DATE, allowNull: false },
      triagedDate: { type: Sequelize.DATE },
      patchedDate: { type: Sequelize.DATE },
      closedDate: { type: Sequelize.DATE },
      assignedTo: { type: Sequelize.STRING },
      priority: { type: Sequelize.ENUM('CRITICAL', 'HIGH', 'MEDIUM', 'LOW', 'INFO'), allowNull: false },
      dueDate: { type: Sequelize.DATE },
      notes: { type: Sequelize.ARRAY(Sequelize.TEXT), defaultValue: [] },
      createdAt: { type: Sequelize.DATE, allowNull: false },
      updatedAt: { type: Sequelize.DATE, allowNull: false },
    });

    await queryInterface.addIndex('vulnerability_lifecycles', ['cveId']);
    await queryInterface.addIndex('vulnerability_lifecycles', ['status']);
    await queryInterface.addIndex('vulnerability_lifecycles', ['priority']);
  },

  down: async (queryInterface) => {
    await queryInterface.dropTable('vulnerability_lifecycles');
    await queryInterface.dropTable('cves');
  },
};
`.trim();
};
exports.generateVulnerabilityTrackingSchema = generateVulnerabilityTrackingSchema;
// ============================================================================
// NESTJS SERVICES
// ============================================================================
/**
 * Generates NestJS service for vulnerability management.
 *
 * @returns {string} NestJS service class code
 *
 * @example
 * ```typescript
 * const serviceCode = generateVulnerabilityManagementService();
 * ```
 */
const generateVulnerabilityManagementService = () => {
    return `
import { Injectable } from '@nestjs/common';
import { InjectModel } from '@nestjs/sequelize';
import { CVE } from './models/cve.model';
import { VulnerabilityLifecycle } from './models/vulnerability-lifecycle.model';

@Injectable()
export class VulnerabilityManagementService {
  constructor(
    @InjectModel(CVE) private cveModel: typeof CVE,
    @InjectModel(VulnerabilityLifecycle) private lifecycleModel: typeof VulnerabilityLifecycle,
  ) {}

  async createVulnerability(cveData: Partial<CVE>): Promise<CVE> {
    return this.cveModel.create(cveData);
  }

  async findByCVEId(cveId: string): Promise<CVE | null> {
    return this.cveModel.findOne({ where: { cveId } });
  }

  async updateLifecycle(id: string, updates: Partial<VulnerabilityLifecycle>): Promise<VulnerabilityLifecycle> {
    const lifecycle = await this.lifecycleModel.findByPk(id);
    if (!lifecycle) throw new Error('Lifecycle not found');
    return lifecycle.update(updates);
  }

  async getVulnerabilitiesBySeverity(severity: string): Promise<CVE[]> {
    return this.cveModel.findAll({
      where: {
        'cvssV3.baseSeverity': severity,
      },
    });
  }

  async getPendingVulnerabilities(): Promise<VulnerabilityLifecycle[]> {
    return this.lifecycleModel.findAll({
      where: {
        status: ['NEW', 'TRIAGED', 'IN_PROGRESS'],
      },
      include: [CVE],
    });
  }
}
`.trim();
};
exports.generateVulnerabilityManagementService = generateVulnerabilityManagementService;
// ============================================================================
// TYPESCRIPT TYPES
// ============================================================================
/**
 * Generates TypeScript type definitions for vulnerability metadata.
 *
 * @returns {string} TypeScript type definition code
 *
 * @example
 * ```typescript
 * const types = generateVulnerabilityTypeDefinitions();
 * ```
 */
const generateVulnerabilityTypeDefinitions = () => {
    return `
export interface VulnerabilityDTO {
  cveId: string;
  description: string;
  publishedDate: string;
  lastModifiedDate: string;
  cvssScores: {
    v2?: CVSSv2Score;
    v3?: CVSSv3Score;
    v4?: CVSSv4Score;
  };
  severity: 'CRITICAL' | 'HIGH' | 'MEDIUM' | 'LOW' | 'NONE';
  affectedProducts: AffectedProductDTO[];
  references: string[];
  cweIds: string[];
}

export interface AffectedProductDTO {
  vendor: string;
  product: string;
  versions: string[];
}

export interface VulnerabilityScanRequestDTO {
  targets: string[];
  scanType: 'full' | 'quick' | 'compliance';
  scannerProfile?: string;
}

export interface VulnerabilityScanResponseDTO {
  scanId: string;
  status: 'pending' | 'running' | 'completed' | 'failed';
  startedAt: string;
  completedAt?: string;
  vulnerabilitiesFound: number;
  severityBreakdown: {
    critical: number;
    high: number;
    medium: number;
    low: number;
    info: number;
  };
}
`.trim();
};
exports.generateVulnerabilityTypeDefinitions = generateVulnerabilityTypeDefinitions;
// ============================================================================
// SWAGGER API DEFINITIONS
// ============================================================================
/**
 * Generates Swagger/OpenAPI specification for vulnerability management API.
 *
 * @returns {string} OpenAPI YAML specification
 *
 * @example
 * ```typescript
 * const swagger = generateVulnerabilityAPISpec();
 * ```
 */
const generateVulnerabilityAPISpec = () => {
    return `
openapi: 3.0.0
info:
  title: Vulnerability Management API
  version: 1.0.0
  description: API for managing vulnerabilities, CVEs, and security patches

paths:
  /api/vulnerabilities:
    get:
      summary: List vulnerabilities
      parameters:
        - name: severity
          in: query
          schema:
            type: string
            enum: [CRITICAL, HIGH, MEDIUM, LOW, INFO]
        - name: status
          in: query
          schema:
            type: string
            enum: [NEW, TRIAGED, IN_PROGRESS, PATCHED, CLOSED]
      responses:
        '200':
          description: List of vulnerabilities
          content:
            application/json:
              schema:
                type: array
                items:
                  $ref: '#/components/schemas/Vulnerability'

  /api/vulnerabilities/{cveId}:
    get:
      summary: Get vulnerability by CVE ID
      parameters:
        - name: cveId
          in: path
          required: true
          schema:
            type: string
      responses:
        '200':
          description: Vulnerability details
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Vulnerability'

  /api/scans:
    post:
      summary: Initiate vulnerability scan
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/ScanRequest'
      responses:
        '201':
          description: Scan initiated
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ScanResponse'

components:
  schemas:
    Vulnerability:
      type: object
      properties:
        cveId:
          type: string
        description:
          type: string
        severity:
          type: string
          enum: [CRITICAL, HIGH, MEDIUM, LOW, INFO]
        cvssScore:
          type: number
        publishedDate:
          type: string
          format: date-time
`.trim();
};
exports.generateVulnerabilityAPISpec = generateVulnerabilityAPISpec;
// ============================================================================
// EXPORTS
// ============================================================================
exports.default = {
    // CVE parsing
    parseCVEIdentifier: exports.parseCVEIdentifier,
    validateCVEId: exports.validateCVEId,
    normalizeCVEId: exports.normalizeCVEId,
    extractCVEsFromText: exports.extractCVEsFromText,
    compareCVEIds: exports.compareCVEIds,
    // CVSS scoring
    calculateCVSSv2BaseScore: exports.calculateCVSSv2BaseScore,
    calculateCVSSv3BaseScore: exports.calculateCVSSv3BaseScore,
    getCVSSv3Severity: exports.getCVSSv3Severity,
    parseCVSSv3Vector: exports.parseCVSSv3Vector,
    generateCVSSv3Vector: exports.generateCVSSv3Vector,
    // Lifecycle management
    createVulnerabilityLifecycle: exports.createVulnerabilityLifecycle,
    transitionVulnerabilityStatus: exports.transitionVulnerabilityStatus,
    calculateVulnerabilitySLA: exports.calculateVulnerabilitySLA,
    assignVulnerabilityDueDate: exports.assignVulnerabilityDueDate,
    // Patch management
    createPatchMetadata: exports.createPatchMetadata,
    validatePatchApplicability: exports.validatePatchApplicability,
    generatePatchDeploymentPlan: exports.generatePatchDeploymentPlan,
    // Asset mapping
    mapVulnerabilitiesToAssets: exports.mapVulnerabilitiesToAssets,
    calculateAssetRiskScore: exports.calculateAssetRiskScore,
    groupAssetsBySeverity: exports.groupAssetsBySeverity,
    // Prioritization
    prioritizeVulnerability: exports.prioritizeVulnerability,
    sortVulnerabilitiesByPriority: exports.sortVulnerabilitiesByPriority,
    // Code generation
    generateCVESequelizeModel: exports.generateCVESequelizeModel,
    generateVulnerabilityLifecycleModel: exports.generateVulnerabilityLifecycleModel,
    generateVulnerabilityTrackingSchema: exports.generateVulnerabilityTrackingSchema,
    generateVulnerabilityManagementService: exports.generateVulnerabilityManagementService,
    generateVulnerabilityTypeDefinitions: exports.generateVulnerabilityTypeDefinitions,
    generateVulnerabilityAPISpec: exports.generateVulnerabilityAPISpec,
};
//# sourceMappingURL=vulnerability-management-kit.js.map