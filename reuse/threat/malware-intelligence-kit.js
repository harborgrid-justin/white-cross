"use strict";
/**
 * LOC: MLIK1234567
 * File: /reuse/threat/malware-intelligence-kit.ts
 *
 * UPSTREAM (imports from):
 *   - None (leaf node - reusable utilities)
 *
 * DOWNSTREAM (imported by):
 *   - Threat intelligence services
 *   - Malware intelligence controllers
 *   - Security analytics systems
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.exportIntelligenceToCSV = exports.calculateIntelligenceCoverage = exports.generateThreatRecommendations = exports.generateIntelligenceReport = exports.aggregateMalwareStatistics = exports.validateThreatIntelReport = exports.createMalwareTrendsApiDoc = exports.createThreatIntelligenceApiDoc = exports.createC2ApiResponse = exports.createTrendsApiResponse = exports.provideThreatCorrelation = exports.provideC2Monitoring = exports.provideIntelligenceAnalytics = exports.createMalwareCampaignQuery = exports.createC2InfrastructureQuery = exports.createMalwareTrendQuery = exports.enrichMalwareWithIntelligence = exports.validateIntelligenceFreshness = exports.createThreatIntelReport = exports.correlateMalwareFamilies = exports.calculateCampaignImpact = exports.createMalwareCampaign = exports.generateKillChainVisualization = exports.analyzeKillChainCompleteness = exports.mapToKillChain = exports.calculateDistributionEffectiveness = exports.identifyTargetedSectors = exports.analyzeDistributionVectors = exports.calculateC2Reputation = exports.identifySharedC2Infrastructure = exports.trackC2Communication = exports.createC2Infrastructure = exports.updateSignatureDetectionCount = exports.validateSignatureEffectiveness = exports.generateYaraSignature = exports.clusterMalwareVariants = exports.identifyVariantMutations = exports.calculateCodeSimilarity = exports.detectMalwareVariant = exports.calculateSectorPrevalence = exports.calculateRegionalPrevalence = exports.rankMalwareByPrevalence = exports.calculatePrevalenceScore = exports.compareMalwareTrends = exports.identifyDecliningMalware = exports.detectEmergingMalware = exports.analyzeMalwareTrend = void 0;
// ============================================================================
// MALWARE TREND ANALYSIS
// ============================================================================
/**
 * Analyzes malware trends over a time window.
 *
 * @param {string} familyName - Malware family name
 * @param {TimeWindow} timeWindow - Time window for analysis
 * @param {number[]} sampleCounts - Array of sample counts per interval
 * @returns {MalwareTrend} Trend analysis result
 *
 * @example
 * ```typescript
 * const trend = analyzeMalwareTrend('Emotet',
 *   { startDate: new Date('2025-01-01'), endDate: new Date('2025-01-31'), intervalType: 'day' },
 *   [100, 120, 150, 180, 200, ...]
 * );
 * // Result: { familyName: 'Emotet', growthRate: 0.15, trendDirection: 'rising', ... }
 * ```
 */
const analyzeMalwareTrend = (familyName, timeWindow, sampleCounts) => {
    const totalSamples = sampleCounts.reduce((sum, count) => sum + count, 0);
    const avgCount = totalSamples / sampleCounts.length;
    // Calculate growth rate
    const firstHalfAvg = sampleCounts.slice(0, Math.floor(sampleCounts.length / 2))
        .reduce((sum, count) => sum + count, 0) / Math.floor(sampleCounts.length / 2);
    const secondHalfAvg = sampleCounts.slice(Math.floor(sampleCounts.length / 2))
        .reduce((sum, count) => sum + count, 0) / Math.ceil(sampleCounts.length / 2);
    const growthRate = (secondHalfAvg - firstHalfAvg) / firstHalfAvg;
    // Determine trend direction
    let trendDirection;
    if (growthRate > 0.1) {
        trendDirection = 'rising';
    }
    else if (growthRate < -0.1) {
        trendDirection = 'falling';
    }
    else {
        trendDirection = 'stable';
    }
    // Find peak date
    const peakIndex = sampleCounts.indexOf(Math.max(...sampleCounts));
    const peakDate = calculateDateForIndex(timeWindow, peakIndex);
    // Calculate impact score
    const impactScore = Math.min(100, Math.round(avgCount * (1 + Math.abs(growthRate)) * 0.5));
    return {
        familyName,
        timeWindow,
        sampleCount: totalSamples,
        growthRate: Math.round(growthRate * 100) / 100,
        peakDate,
        currentPrevalence: sampleCounts[sampleCounts.length - 1],
        trendDirection,
        impactScore,
    };
};
exports.analyzeMalwareTrend = analyzeMalwareTrend;
/**
 * Calculates date for a given index in a time window.
 *
 * @param {TimeWindow} timeWindow - Time window
 * @param {number} index - Index in the time window
 * @returns {Date} Calculated date
 */
const calculateDateForIndex = (timeWindow, index) => {
    const millisecondsPerInterval = {
        hour: 3600000,
        day: 86400000,
        week: 604800000,
        month: 2592000000, // Approximate
    };
    const intervalMs = millisecondsPerInterval[timeWindow.intervalType];
    return new Date(timeWindow.startDate.getTime() + (index * intervalMs));
};
/**
 * Detects emerging malware families based on growth patterns.
 *
 * @param {MalwareTrend[]} trends - Array of malware trends
 * @param {number} [growthThreshold] - Minimum growth rate to be considered emerging (default: 0.5)
 * @returns {MalwareTrend[]} Emerging malware families
 *
 * @example
 * ```typescript
 * const emerging = detectEmergingMalware(trends, 0.5);
 * // Result: [{ familyName: 'NewTrojan', growthRate: 1.2, ... }, ...]
 * ```
 */
const detectEmergingMalware = (trends, growthThreshold = 0.5) => {
    return trends
        .filter(trend => trend.growthRate >= growthThreshold && trend.trendDirection === 'rising')
        .sort((a, b) => b.growthRate - a.growthRate);
};
exports.detectEmergingMalware = detectEmergingMalware;
/**
 * Identifies declining malware families.
 *
 * @param {MalwareTrend[]} trends - Array of malware trends
 * @param {number} [declineThreshold] - Maximum growth rate to be considered declining (default: -0.3)
 * @returns {MalwareTrend[]} Declining malware families
 *
 * @example
 * ```typescript
 * const declining = identifyDecliningMalware(trends, -0.3);
 * // Result: [{ familyName: 'OldWorm', growthRate: -0.6, ... }, ...]
 * ```
 */
const identifyDecliningMalware = (trends, declineThreshold = -0.3) => {
    return trends
        .filter(trend => trend.growthRate <= declineThreshold && trend.trendDirection === 'falling')
        .sort((a, b) => a.growthRate - b.growthRate);
};
exports.identifyDecliningMalware = identifyDecliningMalware;
/**
 * Compares malware trends across multiple families.
 *
 * @param {MalwareTrend[]} trends - Array of malware trends
 * @returns {Record<string, any>} Comparative analysis
 *
 * @example
 * ```typescript
 * const comparison = compareMalwareTrends(trends);
 * // Result: { topGrowing: 'Emotet', topDeclining: 'Zeus', avgGrowthRate: 0.15, ... }
 * ```
 */
const compareMalwareTrends = (trends) => {
    if (trends.length === 0) {
        return { topGrowing: null, topDeclining: null, avgGrowthRate: 0 };
    }
    const sorted = [...trends].sort((a, b) => b.growthRate - a.growthRate);
    const avgGrowthRate = trends.reduce((sum, t) => sum + t.growthRate, 0) / trends.length;
    const totalSamples = trends.reduce((sum, t) => sum + t.sampleCount, 0);
    return {
        topGrowing: sorted[0].familyName,
        topDeclining: sorted[sorted.length - 1].familyName,
        avgGrowthRate: Math.round(avgGrowthRate * 100) / 100,
        totalSamples,
        activeFamilies: trends.filter(t => t.trendDirection !== 'falling').length,
    };
};
exports.compareMalwareTrends = compareMalwareTrends;
// ============================================================================
// PREVALENCE SCORING
// ============================================================================
/**
 * Calculates malware prevalence score.
 *
 * @param {number} globalSamples - Global sample count
 * @param {number} totalGlobalMalware - Total global malware samples
 * @param {number} detectionRate - Detection rate (0-1)
 * @param {number} infectionRate - Infection rate (0-1)
 * @returns {PrevalenceScore} Prevalence score object
 *
 * @example
 * ```typescript
 * const score = calculatePrevalenceScore('malware123', 5000, 100000, 0.85, 0.15);
 * // Result: { malwareId: 'malware123', globalPrevalence: 5.0, score: 68, ... }
 * ```
 */
const calculatePrevalenceScore = (malwareId, globalSamples, totalGlobalMalware, detectionRate, infectionRate) => {
    const globalPrevalence = (globalSamples / totalGlobalMalware) * 100;
    // Calculate composite score
    const score = Math.min(100, Math.round((globalPrevalence * 0.4) +
        (detectionRate * 100 * 0.3) +
        (infectionRate * 100 * 0.3)));
    return {
        malwareId,
        globalPrevalence: Math.round(globalPrevalence * 100) / 100,
        detectionRate,
        infectionRate,
        score,
        regionalPrevalence: {},
        sectorPrevalence: {},
    };
};
exports.calculatePrevalenceScore = calculatePrevalenceScore;
/**
 * Ranks malware by prevalence scores.
 *
 * @param {PrevalenceScore[]} scores - Array of prevalence scores
 * @returns {PrevalenceScore[]} Ranked prevalence scores
 *
 * @example
 * ```typescript
 * const ranked = rankMalwareByPrevalence(scores);
 * // Result: [{ malwareId: 'a', rank: 1, score: 95, ... }, { malwareId: 'b', rank: 2, score: 82, ... }]
 * ```
 */
const rankMalwareByPrevalence = (scores) => {
    const sorted = [...scores].sort((a, b) => b.score - a.score);
    return sorted.map((score, index) => ({
        ...score,
        rank: index + 1,
    }));
};
exports.rankMalwareByPrevalence = rankMalwareByPrevalence;
/**
 * Calculates regional prevalence distribution.
 *
 * @param {Record<string, number>} regionalSamples - Regional sample counts
 * @param {number} totalSamples - Total sample count
 * @returns {Record<string, number>} Regional prevalence percentages
 *
 * @example
 * ```typescript
 * const distribution = calculateRegionalPrevalence(
 *   { 'North America': 5000, 'Europe': 3000, 'Asia': 2000 },
 *   10000
 * );
 * // Result: { 'North America': 50.0, 'Europe': 30.0, 'Asia': 20.0 }
 * ```
 */
const calculateRegionalPrevalence = (regionalSamples, totalSamples) => {
    const prevalence = {};
    for (const [region, samples] of Object.entries(regionalSamples)) {
        prevalence[region] = Math.round((samples / totalSamples) * 10000) / 100;
    }
    return prevalence;
};
exports.calculateRegionalPrevalence = calculateRegionalPrevalence;
/**
 * Calculates sector-specific prevalence distribution.
 *
 * @param {Record<string, number>} sectorSamples - Sector sample counts
 * @param {number} totalSamples - Total sample count
 * @returns {Record<string, number>} Sector prevalence percentages
 *
 * @example
 * ```typescript
 * const distribution = calculateSectorPrevalence(
 *   { 'Healthcare': 4000, 'Finance': 3500, 'Government': 2500 },
 *   10000
 * );
 * // Result: { 'Healthcare': 40.0, 'Finance': 35.0, 'Government': 25.0 }
 * ```
 */
const calculateSectorPrevalence = (sectorSamples, totalSamples) => {
    const prevalence = {};
    for (const [sector, samples] of Object.entries(sectorSamples)) {
        prevalence[sector] = Math.round((samples / totalSamples) * 10000) / 100;
    }
    return prevalence;
};
exports.calculateSectorPrevalence = calculateSectorPrevalence;
// ============================================================================
// VARIANT DETECTION
// ============================================================================
/**
 * Detects malware variants based on similarity threshold.
 *
 * @param {string} parentFamily - Parent malware family
 * @param {string} sha256 - SHA256 hash of potential variant
 * @param {number} similarity - Similarity score (0-1)
 * @param {VariantMutation[]} mutations - Array of detected mutations
 * @returns {MalwareVariant} Malware variant object
 *
 * @example
 * ```typescript
 * const variant = detectMalwareVariant('Emotet', 'abc123...', 0.85,
 *   [{ type: 'packer', description: 'Changed to UPX', severity: 'low' }]
 * );
 * ```
 */
const detectMalwareVariant = (parentFamily, sha256, similarity, mutations) => {
    const variantId = `${parentFamily}_variant_${sha256.substring(0, 8)}`;
    return {
        variantId,
        parentFamily,
        sha256,
        firstSeen: new Date(),
        lastSeen: new Date(),
        similarity,
        mutations,
        isActive: true,
        prevalence: 0,
    };
};
exports.detectMalwareVariant = detectMalwareVariant;
/**
 * Calculates code similarity between two malware samples.
 *
 * @param {string} hash1 - First malware hash
 * @param {string} hash2 - Second malware hash
 * @param {string[]} commonStrings - Common strings found in both samples
 * @param {number} totalStrings - Total unique strings across both samples
 * @returns {number} Similarity score (0-1)
 *
 * @example
 * ```typescript
 * const similarity = calculateCodeSimilarity('hash1', 'hash2',
 *   ['malicious', 'encrypt', 'download'], 10
 * );
 * // Result: 0.30
 * ```
 */
const calculateCodeSimilarity = (hash1, hash2, commonStrings, totalStrings) => {
    if (hash1 === hash2)
        return 1.0;
    if (totalStrings === 0)
        return 0.0;
    const similarity = commonStrings.length / totalStrings;
    return Math.round(similarity * 100) / 100;
};
exports.calculateCodeSimilarity = calculateCodeSimilarity;
/**
 * Identifies mutation types in malware variant.
 *
 * @param {string} originalHash - Original malware hash
 * @param {string} variantHash - Variant malware hash
 * @param {string[]} differences - Array of detected differences
 * @returns {VariantMutation[]} Array of identified mutations
 *
 * @example
 * ```typescript
 * const mutations = identifyVariantMutations('original', 'variant',
 *   ['packer changed', 'new C2 domain', 'obfuscation added']
 * );
 * // Result: [{ type: 'packer', description: 'packer changed', severity: 'low' }, ...]
 * ```
 */
const identifyVariantMutations = (originalHash, variantHash, differences) => {
    const mutations = [];
    const mutationPatterns = {
        'packer': { type: 'packer', severity: 'low' },
        'obfuscation': { type: 'obfuscation', severity: 'medium' },
        'c2': { type: 'c2', severity: 'high' },
        'payload': { type: 'payload', severity: 'high' },
        'persistence': { type: 'persistence', severity: 'medium' },
        'code': { type: 'code', severity: 'medium' },
    };
    for (const diff of differences) {
        const lowerDiff = diff.toLowerCase();
        for (const [pattern, mutation] of Object.entries(mutationPatterns)) {
            if (lowerDiff.includes(pattern)) {
                mutations.push({
                    type: mutation.type,
                    description: diff,
                    severity: mutation.severity,
                });
                break;
            }
        }
    }
    return mutations;
};
exports.identifyVariantMutations = identifyVariantMutations;
/**
 * Groups malware variants by similarity clusters.
 *
 * @param {MalwareVariant[]} variants - Array of malware variants
 * @param {number} [similarityThreshold] - Minimum similarity for clustering (default: 0.7)
 * @returns {Record<string, MalwareVariant[]>} Clustered variants
 *
 * @example
 * ```typescript
 * const clusters = clusterMalwareVariants(variants, 0.7);
 * // Result: { 'cluster1': [variant1, variant2], 'cluster2': [variant3, variant4] }
 * ```
 */
const clusterMalwareVariants = (variants, similarityThreshold = 0.7) => {
    const clusters = {};
    let clusterIndex = 0;
    for (const variant of variants) {
        let addedToCluster = false;
        for (const [clusterId, clusterVariants] of Object.entries(clusters)) {
            // Check if variant is similar to any variant in cluster
            const isSimilar = clusterVariants.some(cv => cv.similarity >= similarityThreshold);
            if (isSimilar) {
                clusters[clusterId].push(variant);
                addedToCluster = true;
                break;
            }
        }
        if (!addedToCluster) {
            const newClusterId = `cluster_${clusterIndex++}`;
            clusters[newClusterId] = [variant];
        }
    }
    return clusters;
};
exports.clusterMalwareVariants = clusterMalwareVariants;
// ============================================================================
// MALWARE SIGNATURE GENERATION
// ============================================================================
/**
 * Generates YARA signature from malware sample characteristics.
 *
 * @param {string} malwareFamily - Malware family name
 * @param {string[]} uniqueStrings - Unique strings found in malware
 * @param {string[]} hexPatterns - Hex patterns for detection
 * @returns {MalwareSignature} Generated malware signature
 *
 * @example
 * ```typescript
 * const signature = generateYaraSignature('Emotet',
 *   ['C2_connect', 'encrypt_payload'],
 *   ['4D5A', '504B0304']
 * );
 * ```
 */
const generateYaraSignature = (malwareFamily, uniqueStrings, hexPatterns) => {
    const signatureId = `YARA_${malwareFamily}_${Date.now()}`;
    const ruleName = `${malwareFamily.replace(/\s+/g, '_')}_Detection`;
    let content = `rule ${ruleName} {\n`;
    content += `  meta:\n`;
    content += `    author = "Automated Signature Generation"\n`;
    content += `    description = "Detects ${malwareFamily} malware"\n`;
    content += `    date = "${new Date().toISOString().split('T')[0]}"\n`;
    content += `  strings:\n`;
    uniqueStrings.forEach((str, index) => {
        content += `    $str${index} = "${str}" ascii wide\n`;
    });
    hexPatterns.forEach((hex, index) => {
        content += `    $hex${index} = { ${hex} }\n`;
    });
    content += `  condition:\n`;
    content += `    any of them\n`;
    content += `}\n`;
    return {
        signatureId,
        signatureType: 'yara',
        name: ruleName,
        content,
        malwareFamily,
        confidence: 0.75,
        falsePositiveRate: 0.05,
        createdDate: new Date(),
        lastUpdated: new Date(),
        detectionCount: 0,
    };
};
exports.generateYaraSignature = generateYaraSignature;
/**
 * Validates malware signature effectiveness.
 *
 * @param {MalwareSignature} signature - Malware signature
 * @param {number} truePositives - True positive detections
 * @param {number} falsePositives - False positive detections
 * @param {number} totalSamples - Total samples tested
 * @returns {{ confidence: number; falsePositiveRate: number; isEffective: boolean }} Validation result
 *
 * @example
 * ```typescript
 * const validation = validateSignatureEffectiveness(signature, 95, 5, 100);
 * // Result: { confidence: 0.95, falsePositiveRate: 0.05, isEffective: true }
 * ```
 */
const validateSignatureEffectiveness = (signature, truePositives, falsePositives, totalSamples) => {
    const confidence = truePositives / totalSamples;
    const falsePositiveRate = falsePositives / totalSamples;
    return {
        confidence: Math.round(confidence * 100) / 100,
        falsePositiveRate: Math.round(falsePositiveRate * 100) / 100,
        isEffective: confidence >= 0.8 && falsePositiveRate <= 0.1,
    };
};
exports.validateSignatureEffectiveness = validateSignatureEffectiveness;
/**
 * Updates signature detection statistics.
 *
 * @param {MalwareSignature} signature - Malware signature
 * @param {number} newDetections - Number of new detections
 * @returns {MalwareSignature} Updated signature
 *
 * @example
 * ```typescript
 * const updated = updateSignatureDetectionCount(signature, 25);
 * // Increments detection count and updates lastUpdated
 * ```
 */
const updateSignatureDetectionCount = (signature, newDetections) => {
    return {
        ...signature,
        detectionCount: signature.detectionCount + newDetections,
        lastUpdated: new Date(),
    };
};
exports.updateSignatureDetectionCount = updateSignatureDetectionCount;
// ============================================================================
// C2 INFRASTRUCTURE TRACKING
// ============================================================================
/**
 * Creates C2 infrastructure record.
 *
 * @param {string} type - C2 type (domain, IP, URL, tor)
 * @param {string} value - C2 value
 * @param {string[]} malwareFamilies - Associated malware families
 * @param {number} reputation - Reputation score (0-100)
 * @returns {Partial<C2Infrastructure>} C2 infrastructure object
 *
 * @example
 * ```typescript
 * const c2 = createC2Infrastructure('domain', 'evil.com', ['Emotet', 'TrickBot'], 95);
 * ```
 */
const createC2Infrastructure = (type, value, malwareFamilies, reputation) => {
    const c2Id = `c2_${type}_${value.replace(/[^a-zA-Z0-9]/g, '_')}`;
    return {
        c2Id,
        type,
        value,
        protocol: 'https',
        malwareFamilies,
        firstSeen: new Date(),
        lastSeen: new Date(),
        isActive: true,
        reputation: Math.min(100, Math.max(0, reputation)),
    };
};
exports.createC2Infrastructure = createC2Infrastructure;
/**
 * Tracks C2 communication patterns.
 *
 * @param {string} c2Id - C2 infrastructure ID
 * @param {number[]} communicationTimestamps - Array of communication timestamps (ms)
 * @returns {{ beaconInterval: number; regularity: number; isBeaconing: boolean }} Pattern analysis
 *
 * @example
 * ```typescript
 * const pattern = trackC2Communication('c2_123', [1000, 2000, 3000, 4000]);
 * // Result: { beaconInterval: 1000, regularity: 1.0, isBeaconing: true }
 * ```
 */
const trackC2Communication = (c2Id, communicationTimestamps) => {
    if (communicationTimestamps.length < 2) {
        return { beaconInterval: 0, regularity: 0, isBeaconing: false };
    }
    const intervals = [];
    for (let i = 1; i < communicationTimestamps.length; i++) {
        intervals.push(communicationTimestamps[i] - communicationTimestamps[i - 1]);
    }
    const avgInterval = intervals.reduce((sum, interval) => sum + interval, 0) / intervals.length;
    const variance = intervals.reduce((sum, interval) => sum + Math.pow(interval - avgInterval, 2), 0) / intervals.length;
    const stdDev = Math.sqrt(variance);
    const regularity = 1 - Math.min(1, stdDev / avgInterval);
    const isBeaconing = regularity >= 0.8;
    return {
        beaconInterval: Math.round(avgInterval),
        regularity: Math.round(regularity * 100) / 100,
        isBeaconing,
    };
};
exports.trackC2Communication = trackC2Communication;
/**
 * Identifies shared C2 infrastructure across malware families.
 *
 * @param {C2Infrastructure[]} c2List - Array of C2 infrastructure
 * @returns {Record<string, string[]>} Map of C2 IDs to malware families
 *
 * @example
 * ```typescript
 * const shared = identifySharedC2Infrastructure(c2List);
 * // Result: { 'c2_1': ['Emotet', 'TrickBot'], 'c2_2': ['Zeus', 'Dridex'] }
 * ```
 */
const identifySharedC2Infrastructure = (c2List) => {
    const sharedC2 = {};
    for (const c2 of c2List) {
        if (c2.malwareFamilies.length > 1) {
            sharedC2[c2.c2Id] = c2.malwareFamilies;
        }
    }
    return sharedC2;
};
exports.identifySharedC2Infrastructure = identifySharedC2Infrastructure;
/**
 * Calculates C2 reputation score based on malicious activity.
 *
 * @param {number} malwareFamilyCount - Number of associated malware families
 * @param {number} infectionCount - Number of infections attributed to C2
 * @param {number} ageInDays - Age of C2 in days
 * @returns {number} Reputation score (0-100, higher = more malicious)
 *
 * @example
 * ```typescript
 * const reputation = calculateC2Reputation(5, 1000, 30);
 * // Result: 92
 * ```
 */
const calculateC2Reputation = (malwareFamilyCount, infectionCount, ageInDays) => {
    let score = 0;
    score += Math.min(40, malwareFamilyCount * 8);
    score += Math.min(40, Math.log10(infectionCount + 1) * 10);
    score += Math.min(20, ageInDays * 0.5);
    return Math.min(100, Math.round(score));
};
exports.calculateC2Reputation = calculateC2Reputation;
// ============================================================================
// DISTRIBUTION ANALYSIS
// ============================================================================
/**
 * Analyzes malware distribution vectors.
 *
 * @param {DistributionVector[]} vectors - Array of distribution vectors
 * @returns {Record<string, any>} Distribution analysis
 *
 * @example
 * ```typescript
 * const analysis = analyzeDistributionVectors(vectors);
 * // Result: { mostCommon: 'email', totalVictims: 5000, avgSuccessRate: 0.35, ... }
 * ```
 */
const analyzeDistributionVectors = (vectors) => {
    if (vectors.length === 0) {
        return { mostCommon: null, totalVictims: 0, avgSuccessRate: 0 };
    }
    const vectorCounts = {};
    const totalVictims = vectors.reduce((sum, v) => sum + v.victimCount, 0);
    const avgSuccessRate = vectors.reduce((sum, v) => sum + v.successRate, 0) / vectors.length;
    for (const vector of vectors) {
        vectorCounts[vector.vectorType] = (vectorCounts[vector.vectorType] || 0) + 1;
    }
    const mostCommon = Object.entries(vectorCounts)
        .sort(([, a], [, b]) => b - a)[0][0];
    return {
        mostCommon,
        totalVictims,
        avgSuccessRate: Math.round(avgSuccessRate * 100) / 100,
        vectorDistribution: vectorCounts,
    };
};
exports.analyzeDistributionVectors = analyzeDistributionVectors;
/**
 * Identifies targeted sectors from distribution data.
 *
 * @param {DistributionVector[]} vectors - Array of distribution vectors
 * @returns {Record<string, number>} Sector targeting frequency
 *
 * @example
 * ```typescript
 * const sectors = identifyTargetedSectors(vectors);
 * // Result: { 'Healthcare': 150, 'Finance': 120, 'Government': 80 }
 * ```
 */
const identifyTargetedSectors = (vectors) => {
    const sectorCounts = {};
    for (const vector of vectors) {
        for (const sector of vector.targetedSectors) {
            sectorCounts[sector] = (sectorCounts[sector] || 0) + 1;
        }
    }
    return sectorCounts;
};
exports.identifyTargetedSectors = identifyTargetedSectors;
/**
 * Calculates distribution effectiveness score.
 *
 * @param {number} victimCount - Number of victims
 * @param {number} attemptCount - Number of distribution attempts
 * @param {number} successRate - Success rate (0-1)
 * @returns {number} Effectiveness score (0-100)
 *
 * @example
 * ```typescript
 * const effectiveness = calculateDistributionEffectiveness(500, 1000, 0.5);
 * // Result: 75
 * ```
 */
const calculateDistributionEffectiveness = (victimCount, attemptCount, successRate) => {
    const conversionRate = victimCount / attemptCount;
    const score = (conversionRate * 50) + (successRate * 50);
    return Math.min(100, Math.round(score));
};
exports.calculateDistributionEffectiveness = calculateDistributionEffectiveness;
// ============================================================================
// KILL CHAIN MAPPING
// ============================================================================
/**
 * Maps malware behavior to cyber kill chain stages.
 *
 * @param {string[]} techniques - Array of observed techniques
 * @param {string[]} mitreAttackIds - Array of MITRE ATT&CK IDs
 * @returns {KillChainStage[]} Array of kill chain stages
 *
 * @example
 * ```typescript
 * const stages = mapToKillChain(
 *   ['Spear Phishing', 'Exploit Public-Facing Application', 'Command and Control'],
 *   ['T1566.001', 'T1190', 'T1071']
 * );
 * // Result: [{ stage: 'delivery', techniques: [...], ... }, ...]
 * ```
 */
const mapToKillChain = (techniques, mitreAttackIds) => {
    const stageMapping = {
        'reconnaissance': 'reconnaissance',
        'weaponization': 'weaponization',
        'phishing': 'delivery',
        'delivery': 'delivery',
        'exploit': 'exploitation',
        'execution': 'exploitation',
        'installation': 'installation',
        'persistence': 'installation',
        'command': 'command_control',
        'control': 'command_control',
        'exfiltration': 'actions_on_objective',
        'impact': 'actions_on_objective',
    };
    const stages = new Map();
    for (let i = 0; i < techniques.length; i++) {
        const technique = techniques[i];
        const lowerTechnique = technique.toLowerCase();
        for (const [keyword, stage] of Object.entries(stageMapping)) {
            if (lowerTechnique.includes(keyword)) {
                const existing = stages.get(stage) || {
                    stage,
                    techniques: [],
                    mitreAttackIds: [],
                    indicators: [],
                };
                existing.techniques.push(technique);
                if (i < mitreAttackIds.length) {
                    existing.mitreAttackIds.push(mitreAttackIds[i]);
                }
                stages.set(stage, existing);
                break;
            }
        }
    }
    return Array.from(stages.values());
};
exports.mapToKillChain = mapToKillChain;
/**
 * Analyzes kill chain completeness for malware campaign.
 *
 * @param {KillChainStage[]} stages - Array of kill chain stages
 * @returns {{ completeness: number; missingStages: string[]; coverage: number }} Analysis result
 *
 * @example
 * ```typescript
 * const analysis = analyzeKillChainCompleteness(stages);
 * // Result: { completeness: 0.85, missingStages: ['reconnaissance'], coverage: 6 }
 * ```
 */
const analyzeKillChainCompleteness = (stages) => {
    const allStages = [
        'reconnaissance',
        'weaponization',
        'delivery',
        'exploitation',
        'installation',
        'command_control',
        'actions_on_objective',
    ];
    const presentStages = new Set(stages.map(s => s.stage));
    const missingStages = allStages.filter(s => !presentStages.has(s));
    const completeness = presentStages.size / allStages.length;
    const coverage = presentStages.size;
    return {
        completeness: Math.round(completeness * 100) / 100,
        missingStages,
        coverage,
    };
};
exports.analyzeKillChainCompleteness = analyzeKillChainCompleteness;
/**
 * Generates kill chain visualization data.
 *
 * @param {KillChainStage[]} stages - Array of kill chain stages
 * @returns {Record<string, any>} Visualization data
 *
 * @example
 * ```typescript
 * const vizData = generateKillChainVisualization(stages);
 * // Result: { stages: [...], connections: [...], techniqueCount: 15 }
 * ```
 */
const generateKillChainVisualization = (stages) => {
    const techniqueCount = stages.reduce((sum, s) => sum + s.techniques.length, 0);
    const stageNames = stages.map(s => s.stage);
    return {
        stages: stages.map(s => ({
            name: s.stage,
            techniqueCount: s.techniques.length,
            mitreCount: s.mitreAttackIds.length,
        })),
        connections: stageNames.slice(0, -1).map((stage, i) => ({
            from: stage,
            to: stageNames[i + 1],
        })),
        techniqueCount,
    };
};
exports.generateKillChainVisualization = generateKillChainVisualization;
// ============================================================================
// MALWARE CAMPAIGN TRACKING
// ============================================================================
/**
 * Creates malware campaign record.
 *
 * @param {string} name - Campaign name
 * @param {string[]} malwareFamilies - Associated malware families
 * @param {CampaignTarget[]} targets - Campaign targets
 * @returns {Partial<MalwareCampaign>} Campaign object
 *
 * @example
 * ```typescript
 * const campaign = createMalwareCampaign('Operation X',
 *   ['Emotet', 'TrickBot'],
 *   [{ targetType: 'sector', name: 'Healthcare', attackCount: 50, successRate: 0.4 }]
 * );
 * ```
 */
const createMalwareCampaign = (name, malwareFamilies, targets) => {
    const campaignId = `campaign_${name.replace(/\s+/g, '_')}_${Date.now()}`;
    return {
        campaignId,
        name,
        malwareFamilies,
        startDate: new Date(),
        isActive: true,
        targets,
        killChain: [],
        c2Infrastructure: [],
        victimCount: 0,
        impactScore: 0,
    };
};
exports.createMalwareCampaign = createMalwareCampaign;
/**
 * Calculates campaign impact score.
 *
 * @param {number} victimCount - Number of victims
 * @param {CampaignTarget[]} targets - Campaign targets
 * @param {number} duration - Campaign duration in days
 * @returns {number} Impact score (0-100)
 *
 * @example
 * ```typescript
 * const impact = calculateCampaignImpact(1000, targets, 30);
 * // Result: 78
 * ```
 */
const calculateCampaignImpact = (victimCount, targets, duration) => {
    let score = 0;
    // Victim count impact (max 40 points)
    score += Math.min(40, Math.log10(victimCount + 1) * 10);
    // Target diversity (max 30 points)
    score += Math.min(30, targets.length * 5);
    // Campaign persistence (max 30 points)
    score += Math.min(30, duration * 0.5);
    return Math.min(100, Math.round(score));
};
exports.calculateCampaignImpact = calculateCampaignImpact;
/**
 * Correlates multiple malware families in campaigns.
 *
 * @param {string} primaryMalware - Primary malware family
 * @param {string[]} relatedMalware - Related malware families
 * @param {'c2_sharing' | 'code_similarity' | 'campaign' | 'threat_actor' | 'infrastructure'} correlationType - Type of correlation
 * @param {string[]} evidence - Evidence of correlation
 * @returns {MalwareCorrelation} Correlation object
 *
 * @example
 * ```typescript
 * const correlation = correlateMalwareFamilies('Emotet', ['TrickBot', 'Ryuk'],
 *   'campaign', ['Shared C2 infrastructure', 'Sequential deployment']
 * );
 * ```
 */
const correlateMalwareFamilies = (primaryMalware, relatedMalware, correlationType, evidence) => {
    const confidenceScore = Math.min(1.0, evidence.length * 0.2);
    return {
        primaryMalware,
        relatedMalware,
        correlationType,
        confidenceScore: Math.round(confidenceScore * 100) / 100,
        evidence,
    };
};
exports.correlateMalwareFamilies = correlateMalwareFamilies;
// ============================================================================
// THREAT INTELLIGENCE INTEGRATION
// ============================================================================
/**
 * Creates threat intelligence report.
 *
 * @param {string} source - Intelligence source
 * @param {'low' | 'medium' | 'high' | 'confirmed'} confidence - Confidence level
 * @param {'white' | 'green' | 'amber' | 'red'} tlpLevel - Traffic Light Protocol level
 * @param {ThreatIndicator[]} indicators - Threat indicators
 * @param {string} description - Report description
 * @returns {Partial<ThreatIntelligence>} Threat intelligence object
 *
 * @example
 * ```typescript
 * const intel = createThreatIntelReport('OSINT', 'high', 'amber',
 *   [{ type: 'hash', value: 'abc123...', context: 'Malware sample' }],
 *   'New Emotet campaign detected'
 * );
 * ```
 */
const createThreatIntelReport = (source, confidence, tlpLevel, indicators, description) => {
    const intelId = `intel_${source}_${Date.now()}`;
    return {
        intelId,
        source,
        confidence,
        tlpLevel,
        indicators,
        description,
        publishedDate: new Date(),
    };
};
exports.createThreatIntelReport = createThreatIntelReport;
/**
 * Validates threat intelligence freshness.
 *
 * @param {ThreatIntelligence} intel - Threat intelligence object
 * @param {number} [maxAgeInDays] - Maximum age in days (default: 90)
 * @returns {boolean} True if intelligence is fresh
 *
 * @example
 * ```typescript
 * const isFresh = validateIntelligenceFreshness(intel, 90);
 * // Result: true or false
 * ```
 */
const validateIntelligenceFreshness = (intel, maxAgeInDays = 90) => {
    const ageInMs = Date.now() - intel.publishedDate.getTime();
    const ageInDays = ageInMs / (1000 * 60 * 60 * 24);
    if (intel.expirationDate && Date.now() > intel.expirationDate.getTime()) {
        return false;
    }
    return ageInDays <= maxAgeInDays;
};
exports.validateIntelligenceFreshness = validateIntelligenceFreshness;
/**
 * Enriches malware data with threat intelligence.
 *
 * @param {string} malwareHash - Malware hash
 * @param {ThreatIntelligence[]} intelReports - Array of threat intelligence reports
 * @returns {Record<string, any>} Enriched malware data
 *
 * @example
 * ```typescript
 * const enriched = enrichMalwareWithIntelligence('abc123...', intelReports);
 * // Result: { hash: 'abc123...', intelMatches: 3, highConfidenceMatches: 2, ... }
 * ```
 */
const enrichMalwareWithIntelligence = (malwareHash, intelReports) => {
    const matches = intelReports.filter(report => report.indicators.some(indicator => indicator.type === 'hash' && indicator.value === malwareHash));
    const highConfidenceMatches = matches.filter(m => m.confidence === 'high' || m.confidence === 'confirmed');
    return {
        hash: malwareHash,
        intelMatches: matches.length,
        highConfidenceMatches: highConfidenceMatches.length,
        sources: [...new Set(matches.map(m => m.source))],
        malwareFamilies: [...new Set(matches.map(m => m.malwareFamily).filter(Boolean))],
    };
};
exports.enrichMalwareWithIntelligence = enrichMalwareWithIntelligence;
// ============================================================================
// SEQUELIZE QUERY UTILITIES
// ============================================================================
/**
 * Creates Sequelize query for malware trend analysis.
 *
 * @param {string} familyName - Malware family name
 * @param {Date} startDate - Start date
 * @param {Date} endDate - End date
 * @returns {Record<string, any>} Sequelize query
 *
 * @example
 * ```typescript
 * const query = createMalwareTrendQuery('Emotet', new Date('2025-01-01'), new Date('2025-01-31'));
 * const samples = await MalwareSample.findAll({ where: query });
 * ```
 */
const createMalwareTrendQuery = (familyName, startDate, endDate) => {
    return {
        malwareFamily: familyName,
        firstSeen: {
            $gte: startDate,
            $lte: endDate,
        },
    };
};
exports.createMalwareTrendQuery = createMalwareTrendQuery;
/**
 * Creates Sequelize query for C2 infrastructure search.
 *
 * @param {string} [type] - C2 type filter
 * @param {boolean} [activeOnly] - Filter only active C2
 * @param {number} [minReputation] - Minimum reputation score
 * @returns {Record<string, any>} Sequelize query
 *
 * @example
 * ```typescript
 * const query = createC2InfrastructureQuery('domain', true, 80);
 * const c2List = await C2Infrastructure.findAll({ where: query });
 * ```
 */
const createC2InfrastructureQuery = (type, activeOnly, minReputation) => {
    const where = {};
    if (type)
        where.type = type;
    if (activeOnly)
        where.isActive = true;
    if (minReputation !== undefined) {
        where.reputation = { $gte: minReputation };
    }
    return where;
};
exports.createC2InfrastructureQuery = createC2InfrastructureQuery;
/**
 * Creates Sequelize query for malware campaign search.
 *
 * @param {boolean} [activeOnly] - Filter only active campaigns
 * @param {string} [threatActor] - Threat actor filter
 * @returns {Record<string, any>} Sequelize query
 *
 * @example
 * ```typescript
 * const query = createMalwareCampaignQuery(true, 'APT28');
 * const campaigns = await MalwareCampaign.findAll({ where: query });
 * ```
 */
const createMalwareCampaignQuery = (activeOnly, threatActor) => {
    const where = {};
    if (activeOnly)
        where.isActive = true;
    if (threatActor)
        where.threatActor = threatActor;
    return where;
};
exports.createMalwareCampaignQuery = createMalwareCampaignQuery;
// ============================================================================
// NESTJS PROVIDER UTILITIES
// ============================================================================
/**
 * Creates NestJS provider for malware intelligence analytics.
 *
 * @param {MalwareTrend[]} trends - Array of malware trends
 * @returns {Record<string, any>} Analytics dashboard data
 *
 * @example
 * ```typescript
 * // In NestJS provider:
 * async getIntelligenceDashboard(): Promise<Record<string, any>> {
 *   const trends = await this.getTrends();
 *   return await provideIntelligenceAnalytics(trends);
 * }
 * ```
 */
const provideIntelligenceAnalytics = async (trends) => {
    const emerging = (0, exports.detectEmergingMalware)(trends);
    const declining = (0, exports.identifyDecliningMalware)(trends);
    const comparison = (0, exports.compareMalwareTrends)(trends);
    return {
        totalFamilies: trends.length,
        emergingThreats: emerging.length,
        decliningThreats: declining.length,
        topGrowing: comparison.topGrowing,
        topDeclining: comparison.topDeclining,
        avgGrowthRate: comparison.avgGrowthRate,
        trends: trends.slice(0, 10), // Top 10 trends
    };
};
exports.provideIntelligenceAnalytics = provideIntelligenceAnalytics;
/**
 * Creates NestJS provider for C2 infrastructure monitoring.
 *
 * @param {C2Infrastructure[]} c2List - Array of C2 infrastructure
 * @returns {Record<string, any>} C2 monitoring data
 *
 * @example
 * ```typescript
 * // In NestJS provider:
 * async getC2Monitoring(): Promise<Record<string, any>> {
 *   const c2List = await this.getC2Infrastructure();
 *   return await provideC2Monitoring(c2List);
 * }
 * ```
 */
const provideC2Monitoring = async (c2List) => {
    const activeC2 = c2List.filter(c2 => c2.isActive);
    const sharedC2 = (0, exports.identifySharedC2Infrastructure)(c2List);
    const avgReputation = c2List.reduce((sum, c2) => sum + c2.reputation, 0) / c2List.length;
    return {
        totalC2: c2List.length,
        activeC2: activeC2.length,
        sharedInfrastructure: Object.keys(sharedC2).length,
        avgReputation: Math.round(avgReputation * 100) / 100,
        highRiskC2: c2List.filter(c2 => c2.reputation >= 80).length,
    };
};
exports.provideC2Monitoring = provideC2Monitoring;
/**
 * Creates NestJS provider for threat intelligence correlation.
 *
 * @param {string} malwareHash - Malware hash
 * @param {ThreatIntelligence[]} intelReports - Threat intelligence reports
 * @param {C2Infrastructure[]} c2List - C2 infrastructure list
 * @returns {Promise<Record<string, any>>} Correlated intelligence data
 *
 * @example
 * ```typescript
 * // In NestJS provider:
 * async getCorrelatedIntelligence(hash: string): Promise<Record<string, any>> {
 *   return await provideThreatCorrelation(hash, intelReports, c2List);
 * }
 * ```
 */
const provideThreatCorrelation = async (malwareHash, intelReports, c2List) => {
    const enriched = (0, exports.enrichMalwareWithIntelligence)(malwareHash, intelReports);
    // Find related C2 infrastructure
    const relatedC2 = c2List.filter(c2 => enriched.malwareFamilies.some(family => c2.malwareFamilies.includes(family)));
    return {
        ...enriched,
        relatedC2: relatedC2.length,
        c2Domains: relatedC2.filter(c2 => c2.type === 'domain').map(c2 => c2.value),
        c2IPs: relatedC2.filter(c2 => c2.type === 'ip').map(c2 => c2.value),
    };
};
exports.provideThreatCorrelation = provideThreatCorrelation;
// ============================================================================
// API ENDPOINT HELPERS
// ============================================================================
/**
 * Creates API endpoint response for malware trends.
 *
 * @param {MalwareTrend[]} trends - Array of malware trends
 * @param {number} page - Page number
 * @param {number} limit - Items per page
 * @returns {Record<string, any>} Paginated API response
 *
 * @example
 * ```typescript
 * @Get('/intelligence/trends')
 * async getTrends(@Query('page') page: number, @Query('limit') limit: number) {
 *   const trends = await this.getTrendData();
 *   return createTrendsApiResponse(trends, page, limit);
 * }
 * ```
 */
const createTrendsApiResponse = (trends, page = 1, limit = 20) => {
    const startIndex = (page - 1) * limit;
    const endIndex = startIndex + limit;
    const paginatedTrends = trends.slice(startIndex, endIndex);
    return {
        success: true,
        data: paginatedTrends,
        pagination: {
            currentPage: page,
            pageSize: limit,
            totalItems: trends.length,
            totalPages: Math.ceil(trends.length / limit),
            hasNextPage: endIndex < trends.length,
            hasPreviousPage: page > 1,
        },
    };
};
exports.createTrendsApiResponse = createTrendsApiResponse;
/**
 * Creates API endpoint response for C2 infrastructure.
 *
 * @param {C2Infrastructure[]} c2List - Array of C2 infrastructure
 * @param {Record<string, any>} [filters] - Applied filters
 * @returns {Record<string, any>} API response
 *
 * @example
 * ```typescript
 * @Get('/intelligence/c2')
 * async getC2Infrastructure(@Query() filters: Record<string, any>) {
 *   const c2List = await this.getC2Data(filters);
 *   return createC2ApiResponse(c2List, filters);
 * }
 * ```
 */
const createC2ApiResponse = (c2List, filters) => {
    const monitoring = (0, exports.provideC2Monitoring)(c2List);
    return {
        success: true,
        data: c2List,
        filters: filters || {},
        summary: monitoring,
    };
};
exports.createC2ApiResponse = createC2ApiResponse;
/**
 * Creates Swagger API documentation for threat intelligence endpoint.
 *
 * @returns {Record<string, any>} Swagger API specification
 *
 * @example
 * ```typescript
 * @ApiOperation(createThreatIntelligenceApiDoc())
 * @Get('/intelligence/threats')
 * async getThreatIntelligence() { ... }
 * ```
 */
const createThreatIntelligenceApiDoc = () => {
    return {
        summary: 'Get threat intelligence reports',
        description: 'Retrieves current threat intelligence reports with confidence levels',
        parameters: [
            {
                name: 'confidence',
                in: 'query',
                required: false,
                description: 'Minimum confidence level',
                schema: { type: 'string', enum: ['low', 'medium', 'high', 'confirmed'] },
            },
            {
                name: 'tlp',
                in: 'query',
                required: false,
                description: 'Traffic Light Protocol level',
                schema: { type: 'string', enum: ['white', 'green', 'amber', 'red'] },
            },
        ],
        responses: {
            200: {
                description: 'Threat intelligence retrieved',
                schema: {
                    type: 'object',
                    properties: {
                        success: { type: 'boolean' },
                        data: { type: 'array', items: { type: 'object' } },
                        count: { type: 'integer' },
                    },
                },
            },
            500: { description: 'Internal server error' },
        },
    };
};
exports.createThreatIntelligenceApiDoc = createThreatIntelligenceApiDoc;
/**
 * Creates Swagger API documentation for malware trends endpoint.
 *
 * @returns {Record<string, any>} Swagger API specification
 *
 * @example
 * ```typescript
 * @ApiOperation(createMalwareTrendsApiDoc())
 * @Get('/intelligence/trends')
 * async getMalwareTrends() { ... }
 * ```
 */
const createMalwareTrendsApiDoc = () => {
    return {
        summary: 'Get malware trend analysis',
        description: 'Retrieves malware trend analysis over specified time window',
        parameters: [
            {
                name: 'family',
                in: 'query',
                required: false,
                description: 'Filter by malware family',
                schema: { type: 'string' },
            },
            {
                name: 'startDate',
                in: 'query',
                required: false,
                description: 'Start date for trend analysis',
                schema: { type: 'string', format: 'date' },
            },
            {
                name: 'endDate',
                in: 'query',
                required: false,
                description: 'End date for trend analysis',
                schema: { type: 'string', format: 'date' },
            },
        ],
        responses: {
            200: {
                description: 'Malware trends retrieved',
                schema: {
                    type: 'object',
                    properties: {
                        success: { type: 'boolean' },
                        data: { type: 'array', items: { type: 'object' } },
                        summary: {
                            type: 'object',
                            properties: {
                                emerging: { type: 'integer' },
                                declining: { type: 'integer' },
                                avgGrowthRate: { type: 'number' },
                            },
                        },
                    },
                },
            },
            400: { description: 'Invalid date range' },
            500: { description: 'Internal server error' },
        },
    };
};
exports.createMalwareTrendsApiDoc = createMalwareTrendsApiDoc;
/**
 * Validates threat intelligence report input.
 *
 * @param {Partial<ThreatIntelligence>} report - Threat intelligence report
 * @returns {{ isValid: boolean; errors: string[] }} Validation result
 *
 * @example
 * ```typescript
 * const validation = validateThreatIntelReport(report);
 * if (!validation.isValid) throw new BadRequestException(validation.errors);
 * ```
 */
const validateThreatIntelReport = (report) => {
    const errors = [];
    if (!report.source || report.source.trim().length === 0) {
        errors.push('Source is required');
    }
    if (!report.confidence) {
        errors.push('Confidence level is required');
    }
    if (!report.tlpLevel) {
        errors.push('TLP level is required');
    }
    if (!report.indicators || report.indicators.length === 0) {
        errors.push('At least one indicator is required');
    }
    if (!report.description || report.description.trim().length === 0) {
        errors.push('Description is required');
    }
    return {
        isValid: errors.length === 0,
        errors,
    };
};
exports.validateThreatIntelReport = validateThreatIntelReport;
/**
 * Aggregates malware statistics over time period.
 *
 * @param {MalwareTrend[]} trends - Array of malware trends
 * @param {Date} startDate - Start date
 * @param {Date} endDate - End date
 * @returns {Record<string, any>} Aggregated statistics
 *
 * @example
 * ```typescript
 * const stats = aggregateMalwareStatistics(trends, new Date('2025-01-01'), new Date('2025-01-31'));
 * // Result: { totalSamples: 10000, uniqueFamilies: 150, avgGrowthRate: 0.15, ... }
 * ```
 */
const aggregateMalwareStatistics = (trends, startDate, endDate) => {
    const filteredTrends = trends.filter(t => t.timeWindow.startDate >= startDate && t.timeWindow.endDate <= endDate);
    const totalSamples = filteredTrends.reduce((sum, t) => sum + t.sampleCount, 0);
    const uniqueFamilies = new Set(filteredTrends.map(t => t.familyName)).size;
    const avgGrowthRate = filteredTrends.reduce((sum, t) => sum + t.growthRate, 0) / filteredTrends.length || 0;
    const avgImpact = filteredTrends.reduce((sum, t) => sum + t.impactScore, 0) / filteredTrends.length || 0;
    return {
        period: { startDate, endDate },
        totalSamples,
        uniqueFamilies,
        avgGrowthRate: Math.round(avgGrowthRate * 100) / 100,
        avgImpact: Math.round(avgImpact * 100) / 100,
        trendCount: filteredTrends.length,
    };
};
exports.aggregateMalwareStatistics = aggregateMalwareStatistics;
/**
 * Generates intelligence report in structured format.
 *
 * @param {ThreatIntelligence[]} intelReports - Array of threat intelligence
 * @param {MalwareTrend[]} trends - Array of malware trends
 * @param {C2Infrastructure[]} c2List - Array of C2 infrastructure
 * @returns {Record<string, any>} Comprehensive intelligence report
 *
 * @example
 * ```typescript
 * const report = generateIntelligenceReport(intelReports, trends, c2List);
 * // Result: { executive Summary: '...', threats: [...], c2Infrastructure: [...], ... }
 * ```
 */
const generateIntelligenceReport = (intelReports, trends, c2List) => {
    const highConfidenceIntel = intelReports.filter(i => i.confidence === 'high' || i.confidence === 'confirmed');
    const emergingThreats = (0, exports.detectEmergingMalware)(trends);
    const activeC2 = c2List.filter(c2 => c2.isActive && c2.reputation >= 70);
    return {
        reportDate: new Date().toISOString(),
        executiveSummary: {
            totalIntelReports: intelReports.length,
            highConfidenceReports: highConfidenceIntel.length,
            emergingThreats: emergingThreats.length,
            activeC2Infrastructure: activeC2.length,
        },
        threats: emergingThreats.slice(0, 10),
        intelligence: highConfidenceIntel.slice(0, 20),
        c2Infrastructure: activeC2.slice(0, 15),
        recommendations: (0, exports.generateThreatRecommendations)(emergingThreats, activeC2),
    };
};
exports.generateIntelligenceReport = generateIntelligenceReport;
/**
 * Generates threat mitigation recommendations.
 *
 * @param {MalwareTrend[]} emergingThreats - Emerging malware threats
 * @param {C2Infrastructure[]} activeC2 - Active C2 infrastructure
 * @returns {string[]} Array of recommendations
 *
 * @example
 * ```typescript
 * const recommendations = generateThreatRecommendations(emerging, c2List);
 * // Result: ['Block domains: evil.com, bad.com', 'Monitor for Emotet indicators', ...]
 * ```
 */
const generateThreatRecommendations = (emergingThreats, activeC2) => {
    const recommendations = [];
    if (emergingThreats.length > 0) {
        recommendations.push(`Monitor for emerging threats: ${emergingThreats.slice(0, 5).map(t => t.familyName).join(', ')}`);
    }
    const c2Domains = activeC2.filter(c2 => c2.type === 'domain').map(c2 => c2.value);
    if (c2Domains.length > 0) {
        recommendations.push(`Block malicious domains: ${c2Domains.slice(0, 10).join(', ')}`);
    }
    const c2IPs = activeC2.filter(c2 => c2.type === 'ip').map(c2 => c2.value);
    if (c2IPs.length > 0) {
        recommendations.push(`Block malicious IPs: ${c2IPs.slice(0, 10).join(', ')}`);
    }
    if (emergingThreats.some(t => t.growthRate > 1.0)) {
        recommendations.push('Increase monitoring frequency for rapidly growing threats');
    }
    recommendations.push('Update threat intelligence feeds and YARA rules');
    recommendations.push('Review and update endpoint protection signatures');
    return recommendations;
};
exports.generateThreatRecommendations = generateThreatRecommendations;
/**
 * Calculates threat intelligence coverage score.
 *
 * @param {ThreatIntelligence[]} intelReports - Array of threat intelligence
 * @param {MalwareTrend[]} trends - Array of malware trends
 * @returns {{ coverageScore: number; coveredFamilies: string[]; gaps: string[] }} Coverage analysis
 *
 * @example
 * ```typescript
 * const coverage = calculateIntelligenceCoverage(intelReports, trends);
 * // Result: { coverageScore: 75, coveredFamilies: ['Emotet', ...], gaps: ['NewTrojan', ...] }
 * ```
 */
const calculateIntelligenceCoverage = (intelReports, trends) => {
    const malwareFamilies = new Set(trends.map(t => t.familyName));
    const coveredFamilies = new Set(intelReports
        .filter(i => i.malwareFamily)
        .map(i => i.malwareFamily));
    const covered = Array.from(malwareFamilies).filter(family => coveredFamilies.has(family));
    const gaps = Array.from(malwareFamilies).filter(family => !coveredFamilies.has(family));
    const coverageScore = Math.round((covered.length / malwareFamilies.size) * 100);
    return {
        coverageScore,
        coveredFamilies: covered,
        gaps,
    };
};
exports.calculateIntelligenceCoverage = calculateIntelligenceCoverage;
/**
 * Exports malware intelligence data in CSV format.
 *
 * @param {MalwareTrend[]} trends - Array of malware trends
 * @returns {string} CSV formatted data
 *
 * @example
 * ```typescript
 * const csv = exportIntelligenceToCSV(trends);
 * // Result: "Family,Sample Count,Growth Rate,Trend Direction,Impact Score\nEmotet,1000,0.25,rising,85\n..."
 * ```
 */
const exportIntelligenceToCSV = (trends) => {
    const headers = ['Family', 'Sample Count', 'Growth Rate', 'Trend Direction', 'Impact Score', 'Peak Date'];
    const rows = trends.map(t => [
        t.familyName,
        t.sampleCount.toString(),
        t.growthRate.toString(),
        t.trendDirection,
        t.impactScore.toString(),
        t.peakDate.toISOString().split('T')[0],
    ]);
    const csvContent = [
        headers.join(','),
        ...rows.map(row => row.join(',')),
    ].join('\n');
    return csvContent;
};
exports.exportIntelligenceToCSV = exportIntelligenceToCSV;
// ============================================================================
// EXPORTS
// ============================================================================
exports.default = {
    // Trend analysis
    analyzeMalwareTrend: exports.analyzeMalwareTrend,
    detectEmergingMalware: exports.detectEmergingMalware,
    identifyDecliningMalware: exports.identifyDecliningMalware,
    compareMalwareTrends: exports.compareMalwareTrends,
    // Prevalence scoring
    calculatePrevalenceScore: exports.calculatePrevalenceScore,
    rankMalwareByPrevalence: exports.rankMalwareByPrevalence,
    calculateRegionalPrevalence: exports.calculateRegionalPrevalence,
    calculateSectorPrevalence: exports.calculateSectorPrevalence,
    // Variant detection
    detectMalwareVariant: exports.detectMalwareVariant,
    calculateCodeSimilarity: exports.calculateCodeSimilarity,
    identifyVariantMutations: exports.identifyVariantMutations,
    clusterMalwareVariants: exports.clusterMalwareVariants,
    // Signature generation
    generateYaraSignature: exports.generateYaraSignature,
    validateSignatureEffectiveness: exports.validateSignatureEffectiveness,
    updateSignatureDetectionCount: exports.updateSignatureDetectionCount,
    // C2 tracking
    createC2Infrastructure: exports.createC2Infrastructure,
    trackC2Communication: exports.trackC2Communication,
    identifySharedC2Infrastructure: exports.identifySharedC2Infrastructure,
    calculateC2Reputation: exports.calculateC2Reputation,
    // Distribution analysis
    analyzeDistributionVectors: exports.analyzeDistributionVectors,
    identifyTargetedSectors: exports.identifyTargetedSectors,
    calculateDistributionEffectiveness: exports.calculateDistributionEffectiveness,
    // Kill chain mapping
    mapToKillChain: exports.mapToKillChain,
    analyzeKillChainCompleteness: exports.analyzeKillChainCompleteness,
    generateKillChainVisualization: exports.generateKillChainVisualization,
    // Campaign tracking
    createMalwareCampaign: exports.createMalwareCampaign,
    calculateCampaignImpact: exports.calculateCampaignImpact,
    correlateMalwareFamilies: exports.correlateMalwareFamilies,
    // Threat intelligence
    createThreatIntelReport: exports.createThreatIntelReport,
    validateIntelligenceFreshness: exports.validateIntelligenceFreshness,
    enrichMalwareWithIntelligence: exports.enrichMalwareWithIntelligence,
    // Sequelize queries
    createMalwareTrendQuery: exports.createMalwareTrendQuery,
    createC2InfrastructureQuery: exports.createC2InfrastructureQuery,
    createMalwareCampaignQuery: exports.createMalwareCampaignQuery,
    // NestJS providers
    provideIntelligenceAnalytics: exports.provideIntelligenceAnalytics,
    provideC2Monitoring: exports.provideC2Monitoring,
    provideThreatCorrelation: exports.provideThreatCorrelation,
    // API endpoints
    createTrendsApiResponse: exports.createTrendsApiResponse,
    createC2ApiResponse: exports.createC2ApiResponse,
    createThreatIntelligenceApiDoc: exports.createThreatIntelligenceApiDoc,
    createMalwareTrendsApiDoc: exports.createMalwareTrendsApiDoc,
    validateThreatIntelReport: exports.validateThreatIntelReport,
    // Analytics and reporting
    aggregateMalwareStatistics: exports.aggregateMalwareStatistics,
    generateIntelligenceReport: exports.generateIntelligenceReport,
    generateThreatRecommendations: exports.generateThreatRecommendations,
    calculateIntelligenceCoverage: exports.calculateIntelligenceCoverage,
    exportIntelligenceToCSV: exports.exportIntelligenceToCSV,
};
//# sourceMappingURL=malware-intelligence-kit.js.map