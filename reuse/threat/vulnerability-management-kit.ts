/**
 * LOC: VUMG1234567
 * File: /reuse/threat/vulnerability-management-kit.ts
 *
 * UPSTREAM (imports from):
 *   - None (leaf node - reusable utilities)
 *
 * DOWNSTREAM (imported by):
 *   - Vulnerability management services
 *   - Security scanning controllers
 *   - Patch management systems
 */

/**
 * File: /reuse/threat/vulnerability-management-kit.ts
 * Locator: WC-THR-VUMG-001
 * Purpose: Comprehensive Vulnerability Management Utilities - CVE parsing, CVSS scoring, patch tracking, asset mapping
 *
 * Upstream: Independent utility module for vulnerability management and tracking
 * Downstream: ../backend/*, security controllers, scanning services, patch management
 * Dependencies: TypeScript 5.x, Node 18+, NestJS 10.x, Sequelize 6.x, Swagger/OpenAPI
 * Exports: 45 utility functions for CVE management, CVSS calculation, vulnerability lifecycle, patch tracking
 *
 * LLM Context: Comprehensive vulnerability management utilities for implementing production-ready security systems.
 * Provides CVE parsing/validation, CVSS v2/v3/v4 score calculation, vulnerability lifecycle management, patch tracking,
 * asset-vulnerability mapping, prioritization, and database schema for vulnerability data. Essential for building
 * secure, compliant healthcare systems with robust vulnerability management capabilities.
 */

// ============================================================================
// TYPE DEFINITIONS
// ============================================================================

interface CVEIdentifier {
  id: string;
  year: number;
  sequence: number;
  isValid: boolean;
}

interface CVSSv2Score {
  version: '2.0';
  baseScore: number;
  temporalScore?: number;
  environmentalScore?: number;
  vectorString: string;
  accessVector: 'L' | 'A' | 'N';
  accessComplexity: 'H' | 'M' | 'L';
  authentication: 'M' | 'S' | 'N';
  confidentialityImpact: 'N' | 'P' | 'C';
  integrityImpact: 'N' | 'P' | 'C';
  availabilityImpact: 'N' | 'P' | 'C';
}

interface CVSSv3Score {
  version: '3.0' | '3.1';
  baseScore: number;
  baseSeverity: 'NONE' | 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL';
  temporalScore?: number;
  environmentalScore?: number;
  vectorString: string;
  attackVector: 'N' | 'A' | 'L' | 'P';
  attackComplexity: 'L' | 'H';
  privilegesRequired: 'N' | 'L' | 'H';
  userInteraction: 'N' | 'R';
  scope: 'U' | 'C';
  confidentialityImpact: 'N' | 'L' | 'H';
  integrityImpact: 'N' | 'L' | 'H';
  availabilityImpact: 'N' | 'L' | 'H';
}

interface CVSSv4Score {
  version: '4.0';
  baseScore: number;
  baseSeverity: 'NONE' | 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL';
  vectorString: string;
  attackVector: 'N' | 'A' | 'L' | 'P';
  attackComplexity: 'L' | 'H';
  attackRequirements: 'N' | 'P';
  privilegesRequired: 'N' | 'L' | 'H';
  userInteraction: 'N' | 'P' | 'A';
  vulnConfidentialityImpact: 'N' | 'L' | 'H';
  vulnIntegrityImpact: 'N' | 'L' | 'H';
  vulnAvailabilityImpact: 'N' | 'L' | 'H';
  subConfidentialityImpact: 'N' | 'L' | 'H';
  subIntegrityImpact: 'N' | 'L' | 'H';
  subAvailabilityImpact: 'N' | 'L' | 'H';
}

interface VulnerabilityMetadata {
  cveId: string;
  publishedDate: Date;
  lastModifiedDate: Date;
  description: string;
  references: string[];
  cvssScores: {
    v2?: CVSSv2Score;
    v3?: CVSSv3Score;
    v4?: CVSSv4Score;
  };
  cweIds: string[];
  affectedProducts: AffectedProduct[];
  vendorAdvisory?: string;
  epssScore?: number;
  exploitAvailable?: boolean;
}

interface AffectedProduct {
  vendor: string;
  product: string;
  versions: string[];
  versionStartIncluding?: string;
  versionEndIncluding?: string;
  versionStartExcluding?: string;
  versionEndExcluding?: string;
}

interface VulnerabilityLifecycle {
  status: 'NEW' | 'TRIAGED' | 'IN_PROGRESS' | 'PATCHED' | 'ACCEPTED' | 'CLOSED' | 'REOPENED';
  detectedDate: Date;
  triagedDate?: Date;
  patchedDate?: Date;
  closedDate?: Date;
  assignedTo?: string;
  priority: 'CRITICAL' | 'HIGH' | 'MEDIUM' | 'LOW' | 'INFO';
  dueDate?: Date;
  notes: string[];
}

interface PatchMetadata {
  patchId: string;
  cveIds: string[];
  vendor: string;
  product: string;
  version: string;
  releaseDate: Date;
  downloadUrl?: string;
  checksum?: string;
  installationInstructions?: string;
  requiresReboot: boolean;
  prerequisites?: string[];
  rollbackSupported: boolean;
}

interface AssetVulnerabilityMapping {
  assetId: string;
  assetName: string;
  assetType: string;
  vulnerabilities: {
    cveId: string;
    severity: string;
    status: string;
    detectedDate: Date;
    affectedComponent: string;
  }[];
  riskScore: number;
  lastScanDate: Date;
}

interface VulnerabilityScanResult {
  scanId: string;
  scanDate: Date;
  scanner: string;
  targetAssets: string[];
  vulnerabilitiesFound: number;
  criticalCount: number;
  highCount: number;
  mediumCount: number;
  lowCount: number;
  infoCount: number;
  findings: VulnerabilityFinding[];
}

interface VulnerabilityFinding {
  cveId?: string;
  title: string;
  description: string;
  severity: string;
  cvssScore?: number;
  affectedAssets: string[];
  remediation: string;
  references: string[];
}

interface VulnerabilityPrioritization {
  cveId: string;
  baseScore: number;
  adjustedScore: number;
  businessImpact: number;
  exploitability: number;
  assetCriticality: number;
  threatLevel: number;
  finalPriority: 'P0' | 'P1' | 'P2' | 'P3' | 'P4';
  reasoning: string[];
}

// ============================================================================
// CVE PARSING AND VALIDATION
// ============================================================================

/**
 * Parses CVE identifier string into structured components.
 *
 * @param {string} cveId - CVE identifier (e.g., "CVE-2024-12345")
 * @returns {CVEIdentifier} Parsed CVE identifier
 * @throws {Error} If CVE ID format is invalid
 *
 * @example
 * ```typescript
 * const cve = parseCVEIdentifier('CVE-2024-12345');
 * // Result: { id: 'CVE-2024-12345', year: 2024, sequence: 12345, isValid: true }
 * ```
 */
export const parseCVEIdentifier = (cveId: string): CVEIdentifier => {
  const cvePattern = /^CVE-(\d{4})-(\d{4,})$/i;
  const match = cveId.match(cvePattern);

  if (!match) {
    throw new Error(`Invalid CVE identifier format: ${cveId}`);
  }

  const year = parseInt(match[1], 10);
  const sequence = parseInt(match[2], 10);

  return {
    id: cveId.toUpperCase(),
    year,
    sequence,
    isValid: year >= 1999 && year <= new Date().getFullYear() + 1,
  };
};

/**
 * Validates CVE identifier format and year range.
 *
 * @param {string} cveId - CVE identifier to validate
 * @returns {boolean} True if CVE ID is valid
 *
 * @example
 * ```typescript
 * validateCVEId('CVE-2024-12345'); // true
 * validateCVEId('CVE-1998-123'); // false (year too old)
 * validateCVEId('INVALID-2024-123'); // false (wrong format)
 * ```
 */
export const validateCVEId = (cveId: string): boolean => {
  try {
    const parsed = parseCVEIdentifier(cveId);
    return parsed.isValid;
  } catch {
    return false;
  }
};

/**
 * Normalizes CVE identifier to standard uppercase format.
 *
 * @param {string} cveId - CVE identifier (any case)
 * @returns {string} Normalized CVE identifier
 *
 * @example
 * ```typescript
 * const normalized = normalizeCVEId('cve-2024-12345');
 * // Result: 'CVE-2024-12345'
 * ```
 */
export const normalizeCVEId = (cveId: string): string => {
  const parsed = parseCVEIdentifier(cveId);
  return parsed.id;
};

/**
 * Extracts all CVE identifiers from text.
 *
 * @param {string} text - Text containing CVE references
 * @returns {string[]} Array of unique CVE identifiers
 *
 * @example
 * ```typescript
 * const cves = extractCVEsFromText('Found CVE-2024-1234 and cve-2024-5678 vulnerabilities');
 * // Result: ['CVE-2024-1234', 'CVE-2024-5678']
 * ```
 */
export const extractCVEsFromText = (text: string): string[] => {
  const cvePattern = /CVE-\d{4}-\d{4,}/gi;
  const matches = text.match(cvePattern) || [];
  const uniqueCVEs = [...new Set(matches.map(cve => cve.toUpperCase()))];
  return uniqueCVEs.filter(validateCVEId);
};

/**
 * Compares two CVE identifiers for sorting.
 *
 * @param {string} cveA - First CVE identifier
 * @param {string} cveB - Second CVE identifier
 * @returns {number} Comparison result (-1, 0, 1)
 *
 * @example
 * ```typescript
 * const sorted = ['CVE-2023-1234', 'CVE-2024-5678', 'CVE-2023-9999']
 *   .sort(compareCVEIds);
 * // Result: ['CVE-2023-1234', 'CVE-2023-9999', 'CVE-2024-5678']
 * ```
 */
export const compareCVEIds = (cveA: string, cveB: string): number => {
  const a = parseCVEIdentifier(cveA);
  const b = parseCVEIdentifier(cveB);

  if (a.year !== b.year) return a.year - b.year;
  return a.sequence - b.sequence;
};

// ============================================================================
// CVSS SCORE CALCULATION
// ============================================================================

/**
 * Calculates CVSS v2 base score from metrics.
 *
 * @param {Omit<CVSSv2Score, 'baseScore' | 'vectorString' | 'version'>} metrics - CVSS v2 metrics
 * @returns {number} CVSS v2 base score (0.0 - 10.0)
 *
 * @example
 * ```typescript
 * const score = calculateCVSSv2BaseScore({
 *   accessVector: 'N',
 *   accessComplexity: 'L',
 *   authentication: 'N',
 *   confidentialityImpact: 'C',
 *   integrityImpact: 'C',
 *   availabilityImpact: 'C'
 * });
 * // Result: 10.0
 * ```
 */
export const calculateCVSSv2BaseScore = (
  metrics: Omit<CVSSv2Score, 'baseScore' | 'vectorString' | 'version'>,
): number => {
  const avMap = { L: 0.395, A: 0.646, N: 1.0 };
  const acMap = { H: 0.35, M: 0.61, L: 0.71 };
  const auMap = { M: 0.45, S: 0.56, N: 0.704 };
  const impactMap = { N: 0.0, P: 0.275, C: 0.660 };

  const av = avMap[metrics.accessVector];
  const ac = acMap[metrics.accessComplexity];
  const au = auMap[metrics.authentication];
  const confImpact = impactMap[metrics.confidentialityImpact];
  const intImpact = impactMap[metrics.integrityImpact];
  const availImpact = impactMap[metrics.availabilityImpact];

  const impact = 10.41 * (1 - (1 - confImpact) * (1 - intImpact) * (1 - availImpact));
  const exploitability = 20 * av * ac * au;
  const fImpact = impact === 0 ? 0 : 1.176;
  const baseScore = ((0.6 * impact) + (0.4 * exploitability) - 1.5) * fImpact;

  return Math.round(baseScore * 10) / 10;
};

/**
 * Calculates CVSS v3 base score from metrics.
 *
 * @param {Omit<CVSSv3Score, 'baseScore' | 'baseSeverity' | 'vectorString' | 'version'>} metrics - CVSS v3 metrics
 * @returns {number} CVSS v3 base score (0.0 - 10.0)
 *
 * @example
 * ```typescript
 * const score = calculateCVSSv3BaseScore({
 *   attackVector: 'N',
 *   attackComplexity: 'L',
 *   privilegesRequired: 'N',
 *   userInteraction: 'N',
 *   scope: 'U',
 *   confidentialityImpact: 'H',
 *   integrityImpact: 'H',
 *   availabilityImpact: 'H'
 * });
 * // Result: 9.8
 * ```
 */
export const calculateCVSSv3BaseScore = (
  metrics: Omit<CVSSv3Score, 'baseScore' | 'baseSeverity' | 'vectorString' | 'version'>,
): number => {
  const avMap = { N: 0.85, A: 0.62, L: 0.55, P: 0.2 };
  const acMap = { L: 0.77, H: 0.44 };
  const prMap = { U: { N: 0.85, L: 0.62, H: 0.27 }, C: { N: 0.85, L: 0.68, H: 0.5 } };
  const uiMap = { N: 0.85, R: 0.62 };
  const impactMap = { N: 0.0, L: 0.22, H: 0.56 };

  const av = avMap[metrics.attackVector];
  const ac = acMap[metrics.attackComplexity];
  const pr = prMap[metrics.scope][metrics.privilegesRequired];
  const ui = uiMap[metrics.userInteraction];
  const confImpact = impactMap[metrics.confidentialityImpact];
  const intImpact = impactMap[metrics.integrityImpact];
  const availImpact = impactMap[metrics.availabilityImpact];

  const iscBase = 1 - ((1 - confImpact) * (1 - intImpact) * (1 - availImpact));
  let impact: number;

  if (metrics.scope === 'U') {
    impact = 6.42 * iscBase;
  } else {
    impact = 7.52 * (iscBase - 0.029) - 3.25 * Math.pow(iscBase - 0.02, 15);
  }

  const exploitability = 8.22 * av * ac * pr * ui;

  let baseScore: number;
  if (impact <= 0) {
    baseScore = 0;
  } else if (metrics.scope === 'U') {
    baseScore = Math.min(impact + exploitability, 10);
  } else {
    baseScore = Math.min(1.08 * (impact + exploitability), 10);
  }

  return Math.round(baseScore * 10) / 10;
};

/**
 * Determines CVSS v3 severity rating from score.
 *
 * @param {number} score - CVSS v3 base score
 * @returns {'NONE' | 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL'} Severity rating
 *
 * @example
 * ```typescript
 * getCVSSv3Severity(9.8); // 'CRITICAL'
 * getCVSSv3Severity(5.5); // 'MEDIUM'
 * getCVSSv3Severity(0.0); // 'NONE'
 * ```
 */
export const getCVSSv3Severity = (score: number): 'NONE' | 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL' => {
  if (score === 0.0) return 'NONE';
  if (score >= 0.1 && score <= 3.9) return 'LOW';
  if (score >= 4.0 && score <= 6.9) return 'MEDIUM';
  if (score >= 7.0 && score <= 8.9) return 'HIGH';
  return 'CRITICAL';
};

/**
 * Parses CVSS v3 vector string into metrics.
 *
 * @param {string} vectorString - CVSS v3 vector string
 * @returns {Partial<CVSSv3Score>} Parsed CVSS v3 metrics
 * @throws {Error} If vector string format is invalid
 *
 * @example
 * ```typescript
 * const metrics = parseCVSSv3Vector('CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H');
 * // Result: { version: '3.1', attackVector: 'N', attackComplexity: 'L', ... }
 * ```
 */
export const parseCVSSv3Vector = (vectorString: string): Partial<CVSSv3Score> => {
  const parts = vectorString.split('/');
  if (parts.length < 2 || !parts[0].startsWith('CVSS:')) {
    throw new Error('Invalid CVSS v3 vector string format');
  }

  const version = parts[0].split(':')[1] as '3.0' | '3.1';
  const metrics: Partial<CVSSv3Score> = { version, vectorString };

  const metricMap: Record<string, keyof CVSSv3Score> = {
    AV: 'attackVector',
    AC: 'attackComplexity',
    PR: 'privilegesRequired',
    UI: 'userInteraction',
    S: 'scope',
    C: 'confidentialityImpact',
    I: 'integrityImpact',
    A: 'availabilityImpact',
  };

  for (let i = 1; i < parts.length; i++) {
    const [key, value] = parts[i].split(':');
    const metricKey = metricMap[key];
    if (metricKey) {
      (metrics as any)[metricKey] = value;
    }
  }

  return metrics;
};

/**
 * Generates CVSS v3 vector string from metrics.
 *
 * @param {Omit<CVSSv3Score, 'baseScore' | 'baseSeverity' | 'vectorString'>} metrics - CVSS v3 metrics
 * @returns {string} CVSS v3 vector string
 *
 * @example
 * ```typescript
 * const vector = generateCVSSv3Vector({
 *   version: '3.1',
 *   attackVector: 'N', attackComplexity: 'L', privilegesRequired: 'N',
 *   userInteraction: 'N', scope: 'U', confidentialityImpact: 'H',
 *   integrityImpact: 'H', availabilityImpact: 'H'
 * });
 * // Result: 'CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H'
 * ```
 */
export const generateCVSSv3Vector = (
  metrics: Omit<CVSSv3Score, 'baseScore' | 'baseSeverity' | 'vectorString'>,
): string => {
  return `CVSS:${metrics.version}/AV:${metrics.attackVector}/AC:${metrics.attackComplexity}/` +
    `PR:${metrics.privilegesRequired}/UI:${metrics.userInteraction}/S:${metrics.scope}/` +
    `C:${metrics.confidentialityImpact}/I:${metrics.integrityImpact}/A:${metrics.availabilityImpact}`;
};

// ============================================================================
// VULNERABILITY LIFECYCLE MANAGEMENT
// ============================================================================

/**
 * Creates initial vulnerability lifecycle record.
 *
 * @param {string} cveId - CVE identifier
 * @param {'CRITICAL' | 'HIGH' | 'MEDIUM' | 'LOW' | 'INFO'} priority - Initial priority
 * @returns {VulnerabilityLifecycle} Lifecycle record
 *
 * @example
 * ```typescript
 * const lifecycle = createVulnerabilityLifecycle('CVE-2024-12345', 'HIGH');
 * // Result: { status: 'NEW', detectedDate: Date, priority: 'HIGH', notes: [] }
 * ```
 */
export const createVulnerabilityLifecycle = (
  cveId: string,
  priority: 'CRITICAL' | 'HIGH' | 'MEDIUM' | 'LOW' | 'INFO',
): VulnerabilityLifecycle => {
  return {
    status: 'NEW',
    detectedDate: new Date(),
    priority,
    notes: [`Vulnerability ${cveId} detected with priority ${priority}`],
  };
};

/**
 * Transitions vulnerability to next lifecycle status.
 *
 * @param {VulnerabilityLifecycle} lifecycle - Current lifecycle
 * @param {'TRIAGED' | 'IN_PROGRESS' | 'PATCHED' | 'ACCEPTED' | 'CLOSED' | 'REOPENED'} newStatus - New status
 * @param {string} [note] - Optional transition note
 * @returns {VulnerabilityLifecycle} Updated lifecycle
 *
 * @example
 * ```typescript
 * const updated = transitionVulnerabilityStatus(lifecycle, 'TRIAGED', 'Assessed by security team');
 * ```
 */
export const transitionVulnerabilityStatus = (
  lifecycle: VulnerabilityLifecycle,
  newStatus: 'TRIAGED' | 'IN_PROGRESS' | 'PATCHED' | 'ACCEPTED' | 'CLOSED' | 'REOPENED',
  note?: string,
): VulnerabilityLifecycle => {
  const updated = { ...lifecycle, status: newStatus };
  const now = new Date();

  switch (newStatus) {
    case 'TRIAGED':
      updated.triagedDate = now;
      break;
    case 'PATCHED':
      updated.patchedDate = now;
      break;
    case 'CLOSED':
      updated.closedDate = now;
      break;
  }

  if (note) {
    updated.notes = [...lifecycle.notes, `[${newStatus}] ${note}`];
  }

  return updated;
};

/**
 * Calculates SLA breach status for vulnerability.
 *
 * @param {VulnerabilityLifecycle} lifecycle - Vulnerability lifecycle
 * @returns {object} SLA status with breach information
 *
 * @example
 * ```typescript
 * const sla = calculateVulnerabilitySLA(lifecycle);
 * // Result: { isBreached: true, daysOverdue: 5, daysRemaining: -5 }
 * ```
 */
export const calculateVulnerabilitySLA = (
  lifecycle: VulnerabilityLifecycle,
): { isBreached: boolean; daysOverdue: number; daysRemaining: number } => {
  if (!lifecycle.dueDate) {
    return { isBreached: false, daysOverdue: 0, daysRemaining: Infinity };
  }

  const now = new Date();
  const dueDate = new Date(lifecycle.dueDate);
  const diffMs = dueDate.getTime() - now.getTime();
  const daysRemaining = Math.ceil(diffMs / (1000 * 60 * 60 * 24));
  const isBreached = daysRemaining < 0;
  const daysOverdue = isBreached ? Math.abs(daysRemaining) : 0;

  return { isBreached, daysOverdue, daysRemaining };
};

/**
 * Assigns due date based on vulnerability priority and policy.
 *
 * @param {'CRITICAL' | 'HIGH' | 'MEDIUM' | 'LOW' | 'INFO'} priority - Vulnerability priority
 * @param {Date} [detectedDate] - Detection date (defaults to now)
 * @returns {Date} Calculated due date
 *
 * @example
 * ```typescript
 * const dueDate = assignVulnerabilityDueDate('CRITICAL');
 * // Result: Date 7 days from now
 * ```
 */
export const assignVulnerabilityDueDate = (
  priority: 'CRITICAL' | 'HIGH' | 'MEDIUM' | 'LOW' | 'INFO',
  detectedDate: Date = new Date(),
): Date => {
  const daysByPriority: Record<string, number> = {
    CRITICAL: 7,
    HIGH: 30,
    MEDIUM: 90,
    LOW: 180,
    INFO: 365,
  };

  const days = daysByPriority[priority];
  const dueDate = new Date(detectedDate);
  dueDate.setDate(dueDate.getDate() + days);
  return dueDate;
};

// ============================================================================
// PATCH MANAGEMENT
// ============================================================================

/**
 * Creates patch metadata record.
 *
 * @param {Partial<PatchMetadata>} patchData - Patch information
 * @returns {PatchMetadata} Complete patch metadata
 *
 * @example
 * ```typescript
 * const patch = createPatchMetadata({
 *   cveIds: ['CVE-2024-1234'],
 *   vendor: 'Microsoft',
 *   product: 'Windows Server',
 *   version: '2019',
 *   releaseDate: new Date()
 * });
 * ```
 */
export const createPatchMetadata = (patchData: Partial<PatchMetadata>): PatchMetadata => {
  return {
    patchId: patchData.patchId || `PATCH-${Date.now()}`,
    cveIds: patchData.cveIds || [],
    vendor: patchData.vendor || '',
    product: patchData.product || '',
    version: patchData.version || '',
    releaseDate: patchData.releaseDate || new Date(),
    requiresReboot: patchData.requiresReboot ?? false,
    rollbackSupported: patchData.rollbackSupported ?? true,
    ...patchData,
  };
};

/**
 * Validates patch applicability to target system.
 *
 * @param {PatchMetadata} patch - Patch metadata
 * @param {object} targetSystem - Target system information
 * @returns {object} Applicability result
 *
 * @example
 * ```typescript
 * const result = validatePatchApplicability(patch, {
 *   vendor: 'Microsoft',
 *   product: 'Windows Server',
 *   version: '2019'
 * });
 * // Result: { applicable: true, reason: 'Patch matches target system' }
 * ```
 */
export const validatePatchApplicability = (
  patch: PatchMetadata,
  targetSystem: { vendor: string; product: string; version: string },
): { applicable: boolean; reason: string } => {
  if (patch.vendor !== targetSystem.vendor) {
    return { applicable: false, reason: 'Vendor mismatch' };
  }

  if (patch.product !== targetSystem.product) {
    return { applicable: false, reason: 'Product mismatch' };
  }

  if (patch.version !== targetSystem.version) {
    return { applicable: false, reason: 'Version mismatch' };
  }

  return { applicable: true, reason: 'Patch matches target system' };
};

/**
 * Generates patch deployment plan.
 *
 * @param {PatchMetadata[]} patches - Patches to deploy
 * @param {object} options - Deployment options
 * @returns {object} Deployment plan
 *
 * @example
 * ```typescript
 * const plan = generatePatchDeploymentPlan(patches, {
 *   rolloutStrategy: 'phased',
 *   maintenanceWindow: { start: '22:00', end: '06:00' }
 * });
 * ```
 */
export const generatePatchDeploymentPlan = (
  patches: PatchMetadata[],
  options: { rolloutStrategy?: 'immediate' | 'phased'; maintenanceWindow?: { start: string; end: string } },
): { phases: { patches: PatchMetadata[]; scheduledTime?: Date; requiresReboot: boolean }[] } => {
  const rebootRequired = patches.some(p => p.requiresReboot);
  const criticalPatches = patches.filter(p => p.cveIds.some(cve => cve.includes('CRITICAL')));
  const normalPatches = patches.filter(p => !criticalPatches.includes(p));

  if (options.rolloutStrategy === 'phased') {
    return {
      phases: [
        { patches: criticalPatches, requiresReboot: criticalPatches.some(p => p.requiresReboot) },
        { patches: normalPatches, requiresReboot: normalPatches.some(p => p.requiresReboot) },
      ],
    };
  }

  return {
    phases: [{ patches, requiresReboot }],
  };
};

// ============================================================================
// ASSET-VULNERABILITY MAPPING
// ============================================================================

/**
 * Maps vulnerabilities to assets.
 *
 * @param {string[]} assetIds - Asset identifiers
 * @param {VulnerabilityMetadata[]} vulnerabilities - Vulnerabilities to map
 * @returns {AssetVulnerabilityMapping[]} Asset-vulnerability mappings
 *
 * @example
 * ```typescript
 * const mappings = mapVulnerabilitiesToAssets(
 *   ['asset-1', 'asset-2'],
 *   [vuln1, vuln2]
 * );
 * ```
 */
export const mapVulnerabilitiesToAssets = (
  assetIds: string[],
  vulnerabilities: VulnerabilityMetadata[],
): AssetVulnerabilityMapping[] => {
  return assetIds.map(assetId => ({
    assetId,
    assetName: `Asset ${assetId}`,
    assetType: 'unknown',
    vulnerabilities: vulnerabilities.map(v => ({
      cveId: v.cveId,
      severity: v.cvssScores.v3?.baseSeverity || 'UNKNOWN',
      status: 'NEW',
      detectedDate: new Date(),
      affectedComponent: 'unknown',
    })),
    riskScore: calculateAssetRiskScore(vulnerabilities),
    lastScanDate: new Date(),
  }));
};

/**
 * Calculates risk score for asset based on vulnerabilities.
 *
 * @param {VulnerabilityMetadata[]} vulnerabilities - Vulnerabilities affecting asset
 * @returns {number} Risk score (0-100)
 *
 * @example
 * ```typescript
 * const riskScore = calculateAssetRiskScore([vuln1, vuln2, vuln3]);
 * // Result: 85.5
 * ```
 */
export const calculateAssetRiskScore = (vulnerabilities: VulnerabilityMetadata[]): number => {
  if (vulnerabilities.length === 0) return 0;

  const scores = vulnerabilities.map(v => v.cvssScores.v3?.baseScore || v.cvssScores.v2?.baseScore || 0);
  const maxScore = Math.max(...scores);
  const avgScore = scores.reduce((a, b) => a + b, 0) / scores.length;
  const count = vulnerabilities.length;

  // Weighted formula: max score (50%), average score (30%), count factor (20%)
  const riskScore = (maxScore * 5) + (avgScore * 3) + Math.min(count * 2, 20);
  return Math.min(Math.round(riskScore * 10) / 10, 100);
};

/**
 * Groups assets by vulnerability severity.
 *
 * @param {AssetVulnerabilityMapping[]} mappings - Asset-vulnerability mappings
 * @returns {Record<string, AssetVulnerabilityMapping[]>} Grouped assets
 *
 * @example
 * ```typescript
 * const grouped = groupAssetsBySeverity(mappings);
 * // Result: { CRITICAL: [...], HIGH: [...], MEDIUM: [...] }
 * ```
 */
export const groupAssetsBySeverity = (
  mappings: AssetVulnerabilityMapping[],
): Record<string, AssetVulnerabilityMapping[]> => {
  return mappings.reduce((groups, mapping) => {
    const maxSeverity = mapping.vulnerabilities.reduce((max, v) => {
      const severityOrder = { CRITICAL: 5, HIGH: 4, MEDIUM: 3, LOW: 2, INFO: 1, UNKNOWN: 0 };
      return (severityOrder[v.severity as keyof typeof severityOrder] || 0) >
        (severityOrder[max as keyof typeof severityOrder] || 0)
        ? v.severity
        : max;
    }, 'UNKNOWN');

    if (!groups[maxSeverity]) groups[maxSeverity] = [];
    groups[maxSeverity].push(mapping);
    return groups;
  }, {} as Record<string, AssetVulnerabilityMapping[]>);
};

// ============================================================================
// VULNERABILITY PRIORITIZATION
// ============================================================================

/**
 * Calculates vulnerability priority score with business context.
 *
 * @param {VulnerabilityMetadata} vulnerability - Vulnerability metadata
 * @param {object} context - Business and threat context
 * @returns {VulnerabilityPrioritization} Prioritization result
 *
 * @example
 * ```typescript
 * const priority = prioritizeVulnerability(vuln, {
 *   assetCriticality: 0.9,
 *   exploitAvailable: true,
 *   businessImpact: 0.8
 * });
 * ```
 */
export const prioritizeVulnerability = (
  vulnerability: VulnerabilityMetadata,
  context: { assetCriticality: number; exploitAvailable?: boolean; businessImpact: number },
): VulnerabilityPrioritization => {
  const baseScore = vulnerability.cvssScores.v3?.baseScore || vulnerability.cvssScores.v2?.baseScore || 0;
  const exploitability = (vulnerability.epssScore || 0) * 10;
  const exploitBonus = (vulnerability.exploitAvailable || context.exploitAvailable) ? 2 : 0;
  const threatLevel = Math.min((exploitability + exploitBonus) / 10, 1);

  const adjustedScore = (
    baseScore * 0.4 +
    context.businessImpact * 10 * 0.25 +
    exploitability * 0.2 +
    context.assetCriticality * 10 * 0.15
  );

  const reasoning = [
    `Base CVSS: ${baseScore}`,
    `Business impact: ${context.businessImpact}`,
    `Asset criticality: ${context.assetCriticality}`,
    `Exploit available: ${vulnerability.exploitAvailable || context.exploitAvailable}`,
  ];

  let finalPriority: 'P0' | 'P1' | 'P2' | 'P3' | 'P4';
  if (adjustedScore >= 9.0) finalPriority = 'P0';
  else if (adjustedScore >= 7.0) finalPriority = 'P1';
  else if (adjustedScore >= 5.0) finalPriority = 'P2';
  else if (adjustedScore >= 3.0) finalPriority = 'P3';
  else finalPriority = 'P4';

  return {
    cveId: vulnerability.cveId,
    baseScore,
    adjustedScore: Math.round(adjustedScore * 10) / 10,
    businessImpact: context.businessImpact,
    exploitability,
    assetCriticality: context.assetCriticality,
    threatLevel,
    finalPriority,
    reasoning,
  };
};

/**
 * Sorts vulnerabilities by priority for remediation.
 *
 * @param {VulnerabilityPrioritization[]} prioritizations - Prioritized vulnerabilities
 * @returns {VulnerabilityPrioritization[]} Sorted vulnerabilities
 *
 * @example
 * ```typescript
 * const sorted = sortVulnerabilitiesByPriority(prioritizations);
 * // Result: [P0 vulns, P1 vulns, P2 vulns, ...]
 * ```
 */
export const sortVulnerabilitiesByPriority = (
  prioritizations: VulnerabilityPrioritization[],
): VulnerabilityPrioritization[] => {
  const priorityOrder = { P0: 0, P1: 1, P2: 2, P3: 3, P4: 4 };
  return [...prioritizations].sort((a, b) => {
    if (priorityOrder[a.finalPriority] !== priorityOrder[b.finalPriority]) {
      return priorityOrder[a.finalPriority] - priorityOrder[b.finalPriority];
    }
    return b.adjustedScore - a.adjustedScore;
  });
};

// ============================================================================
// SEQUELIZE MODELS
// ============================================================================

/**
 * Generates Sequelize model for CVE data.
 *
 * @returns {string} Sequelize model definition code
 *
 * @example
 * ```typescript
 * const modelCode = generateCVESequelizeModel();
 * // Returns: Complete Sequelize model class definition
 * ```
 */
export const generateCVESequelizeModel = (): string => {
  return `
import { Table, Column, Model, DataType, Index, HasMany } from 'sequelize-typescript';

@Table({ tableName: 'cves', timestamps: true })
export class CVE extends Model {
  @Column({ type: DataType.UUID, primaryKey: true, defaultValue: DataType.UUIDV4 })
  id: string;

  @Index
  @Column({ type: DataType.STRING(20), unique: true, allowNull: false })
  cveId: string;

  @Column({ type: DataType.INTEGER, allowNull: false })
  year: number;

  @Column({ type: DataType.INTEGER, allowNull: false })
  sequence: number;

  @Column({ type: DataType.TEXT, allowNull: false })
  description: string;

  @Index
  @Column({ type: DataType.DATE, allowNull: false })
  publishedDate: Date;

  @Column({ type: DataType.DATE, allowNull: false })
  lastModifiedDate: Date;

  @Column({ type: DataType.JSONB })
  cvssV2: any;

  @Column({ type: DataType.JSONB })
  cvssV3: any;

  @Column({ type: DataType.JSONB })
  cvssV4: any;

  @Column({ type: DataType.ARRAY(DataType.STRING) })
  cweIds: string[];

  @Column({ type: DataType.ARRAY(DataType.STRING) })
  references: string[];

  @Column({ type: DataType.JSONB })
  affectedProducts: any;

  @Column({ type: DataType.STRING })
  vendorAdvisory: string;

  @Index
  @Column({ type: DataType.FLOAT })
  epssScore: number;

  @Index
  @Column({ type: DataType.BOOLEAN, defaultValue: false })
  exploitAvailable: boolean;

  @HasMany(() => VulnerabilityFinding)
  findings: VulnerabilityFinding[];
}
`.trim();
};

/**
 * Generates Sequelize model for vulnerability lifecycle.
 *
 * @returns {string} Sequelize model definition code
 *
 * @example
 * ```typescript
 * const modelCode = generateVulnerabilityLifecycleModel();
 * ```
 */
export const generateVulnerabilityLifecycleModel = (): string => {
  return `
import { Table, Column, Model, DataType, Index, BelongsTo, ForeignKey } from 'sequelize-typescript';

@Table({ tableName: 'vulnerability_lifecycles', timestamps: true })
export class VulnerabilityLifecycle extends Model {
  @Column({ type: DataType.UUID, primaryKey: true, defaultValue: DataType.UUIDV4 })
  id: string;

  @ForeignKey(() => CVE)
  @Index
  @Column({ type: DataType.UUID, allowNull: false })
  cveId: string;

  @BelongsTo(() => CVE)
  cve: CVE;

  @Index
  @Column({
    type: DataType.ENUM('NEW', 'TRIAGED', 'IN_PROGRESS', 'PATCHED', 'ACCEPTED', 'CLOSED', 'REOPENED'),
    allowNull: false,
    defaultValue: 'NEW'
  })
  status: string;

  @Index
  @Column({ type: DataType.DATE, allowNull: false })
  detectedDate: Date;

  @Column({ type: DataType.DATE })
  triagedDate: Date;

  @Column({ type: DataType.DATE })
  patchedDate: Date;

  @Column({ type: DataType.DATE })
  closedDate: Date;

  @Column({ type: DataType.STRING })
  assignedTo: string;

  @Index
  @Column({
    type: DataType.ENUM('CRITICAL', 'HIGH', 'MEDIUM', 'LOW', 'INFO'),
    allowNull: false
  })
  priority: string;

  @Column({ type: DataType.DATE })
  dueDate: Date;

  @Column({ type: DataType.ARRAY(DataType.TEXT), defaultValue: [] })
  notes: string[];
}
`.trim();
};

// ============================================================================
// DATABASE SCHEMA
// ============================================================================

/**
 * Generates database migration for vulnerability tracking schema.
 *
 * @returns {string} Sequelize migration code
 *
 * @example
 * ```typescript
 * const migration = generateVulnerabilityTrackingSchema();
 * ```
 */
export const generateVulnerabilityTrackingSchema = (): string => {
  return `
module.exports = {
  up: async (queryInterface, Sequelize) => {
    await queryInterface.createTable('cves', {
      id: { type: Sequelize.UUID, primaryKey: true, defaultValue: Sequelize.UUIDV4 },
      cveId: { type: Sequelize.STRING(20), unique: true, allowNull: false },
      year: { type: Sequelize.INTEGER, allowNull: false },
      sequence: { type: Sequelize.INTEGER, allowNull: false },
      description: { type: Sequelize.TEXT, allowNull: false },
      publishedDate: { type: Sequelize.DATE, allowNull: false },
      lastModifiedDate: { type: Sequelize.DATE, allowNull: false },
      cvssV2: { type: Sequelize.JSONB },
      cvssV3: { type: Sequelize.JSONB },
      cvssV4: { type: Sequelize.JSONB },
      cweIds: { type: Sequelize.ARRAY(Sequelize.STRING) },
      references: { type: Sequelize.ARRAY(Sequelize.STRING) },
      affectedProducts: { type: Sequelize.JSONB },
      vendorAdvisory: { type: Sequelize.STRING },
      epssScore: { type: Sequelize.FLOAT },
      exploitAvailable: { type: Sequelize.BOOLEAN, defaultValue: false },
      createdAt: { type: Sequelize.DATE, allowNull: false },
      updatedAt: { type: Sequelize.DATE, allowNull: false },
    });

    await queryInterface.addIndex('cves', ['cveId']);
    await queryInterface.addIndex('cves', ['publishedDate']);
    await queryInterface.addIndex('cves', ['epssScore']);
    await queryInterface.addIndex('cves', ['exploitAvailable']);

    await queryInterface.createTable('vulnerability_lifecycles', {
      id: { type: Sequelize.UUID, primaryKey: true, defaultValue: Sequelize.UUIDV4 },
      cveId: { type: Sequelize.UUID, allowNull: false, references: { model: 'cves', key: 'id' } },
      status: { type: Sequelize.ENUM('NEW', 'TRIAGED', 'IN_PROGRESS', 'PATCHED', 'ACCEPTED', 'CLOSED', 'REOPENED'), allowNull: false },
      detectedDate: { type: Sequelize.DATE, allowNull: false },
      triagedDate: { type: Sequelize.DATE },
      patchedDate: { type: Sequelize.DATE },
      closedDate: { type: Sequelize.DATE },
      assignedTo: { type: Sequelize.STRING },
      priority: { type: Sequelize.ENUM('CRITICAL', 'HIGH', 'MEDIUM', 'LOW', 'INFO'), allowNull: false },
      dueDate: { type: Sequelize.DATE },
      notes: { type: Sequelize.ARRAY(Sequelize.TEXT), defaultValue: [] },
      createdAt: { type: Sequelize.DATE, allowNull: false },
      updatedAt: { type: Sequelize.DATE, allowNull: false },
    });

    await queryInterface.addIndex('vulnerability_lifecycles', ['cveId']);
    await queryInterface.addIndex('vulnerability_lifecycles', ['status']);
    await queryInterface.addIndex('vulnerability_lifecycles', ['priority']);
  },

  down: async (queryInterface) => {
    await queryInterface.dropTable('vulnerability_lifecycles');
    await queryInterface.dropTable('cves');
  },
};
`.trim();
};

// ============================================================================
// NESTJS SERVICES
// ============================================================================

/**
 * Generates NestJS service for vulnerability management.
 *
 * @returns {string} NestJS service class code
 *
 * @example
 * ```typescript
 * const serviceCode = generateVulnerabilityManagementService();
 * ```
 */
export const generateVulnerabilityManagementService = (): string => {
  return `
import { Injectable } from '@nestjs/common';
import { InjectModel } from '@nestjs/sequelize';
import { CVE } from './models/cve.model';
import { VulnerabilityLifecycle } from './models/vulnerability-lifecycle.model';

@Injectable()
export class VulnerabilityManagementService {
  constructor(
    @InjectModel(CVE) private cveModel: typeof CVE,
    @InjectModel(VulnerabilityLifecycle) private lifecycleModel: typeof VulnerabilityLifecycle,
  ) {}

  async createVulnerability(cveData: Partial<CVE>): Promise<CVE> {
    return this.cveModel.create(cveData);
  }

  async findByCVEId(cveId: string): Promise<CVE | null> {
    return this.cveModel.findOne({ where: { cveId } });
  }

  async updateLifecycle(id: string, updates: Partial<VulnerabilityLifecycle>): Promise<VulnerabilityLifecycle> {
    const lifecycle = await this.lifecycleModel.findByPk(id);
    if (!lifecycle) throw new Error('Lifecycle not found');
    return lifecycle.update(updates);
  }

  async getVulnerabilitiesBySeverity(severity: string): Promise<CVE[]> {
    return this.cveModel.findAll({
      where: {
        'cvssV3.baseSeverity': severity,
      },
    });
  }

  async getPendingVulnerabilities(): Promise<VulnerabilityLifecycle[]> {
    return this.lifecycleModel.findAll({
      where: {
        status: ['NEW', 'TRIAGED', 'IN_PROGRESS'],
      },
      include: [CVE],
    });
  }
}
`.trim();
};

// ============================================================================
// TYPESCRIPT TYPES
// ============================================================================

/**
 * Generates TypeScript type definitions for vulnerability metadata.
 *
 * @returns {string} TypeScript type definition code
 *
 * @example
 * ```typescript
 * const types = generateVulnerabilityTypeDefinitions();
 * ```
 */
export const generateVulnerabilityTypeDefinitions = (): string => {
  return `
export interface VulnerabilityDTO {
  cveId: string;
  description: string;
  publishedDate: string;
  lastModifiedDate: string;
  cvssScores: {
    v2?: CVSSv2Score;
    v3?: CVSSv3Score;
    v4?: CVSSv4Score;
  };
  severity: 'CRITICAL' | 'HIGH' | 'MEDIUM' | 'LOW' | 'NONE';
  affectedProducts: AffectedProductDTO[];
  references: string[];
  cweIds: string[];
}

export interface AffectedProductDTO {
  vendor: string;
  product: string;
  versions: string[];
}

export interface VulnerabilityScanRequestDTO {
  targets: string[];
  scanType: 'full' | 'quick' | 'compliance';
  scannerProfile?: string;
}

export interface VulnerabilityScanResponseDTO {
  scanId: string;
  status: 'pending' | 'running' | 'completed' | 'failed';
  startedAt: string;
  completedAt?: string;
  vulnerabilitiesFound: number;
  severityBreakdown: {
    critical: number;
    high: number;
    medium: number;
    low: number;
    info: number;
  };
}
`.trim();
};

// ============================================================================
// SWAGGER API DEFINITIONS
// ============================================================================

/**
 * Generates Swagger/OpenAPI specification for vulnerability management API.
 *
 * @returns {string} OpenAPI YAML specification
 *
 * @example
 * ```typescript
 * const swagger = generateVulnerabilityAPISpec();
 * ```
 */
export const generateVulnerabilityAPISpec = (): string => {
  return `
openapi: 3.0.0
info:
  title: Vulnerability Management API
  version: 1.0.0
  description: API for managing vulnerabilities, CVEs, and security patches

paths:
  /api/vulnerabilities:
    get:
      summary: List vulnerabilities
      parameters:
        - name: severity
          in: query
          schema:
            type: string
            enum: [CRITICAL, HIGH, MEDIUM, LOW, INFO]
        - name: status
          in: query
          schema:
            type: string
            enum: [NEW, TRIAGED, IN_PROGRESS, PATCHED, CLOSED]
      responses:
        '200':
          description: List of vulnerabilities
          content:
            application/json:
              schema:
                type: array
                items:
                  $ref: '#/components/schemas/Vulnerability'

  /api/vulnerabilities/{cveId}:
    get:
      summary: Get vulnerability by CVE ID
      parameters:
        - name: cveId
          in: path
          required: true
          schema:
            type: string
      responses:
        '200':
          description: Vulnerability details
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Vulnerability'

  /api/scans:
    post:
      summary: Initiate vulnerability scan
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/ScanRequest'
      responses:
        '201':
          description: Scan initiated
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ScanResponse'

components:
  schemas:
    Vulnerability:
      type: object
      properties:
        cveId:
          type: string
        description:
          type: string
        severity:
          type: string
          enum: [CRITICAL, HIGH, MEDIUM, LOW, INFO]
        cvssScore:
          type: number
        publishedDate:
          type: string
          format: date-time
`.trim();
};

// ============================================================================
// EXPORTS
// ============================================================================

export default {
  // CVE parsing
  parseCVEIdentifier,
  validateCVEId,
  normalizeCVEId,
  extractCVEsFromText,
  compareCVEIds,

  // CVSS scoring
  calculateCVSSv2BaseScore,
  calculateCVSSv3BaseScore,
  getCVSSv3Severity,
  parseCVSSv3Vector,
  generateCVSSv3Vector,

  // Lifecycle management
  createVulnerabilityLifecycle,
  transitionVulnerabilityStatus,
  calculateVulnerabilitySLA,
  assignVulnerabilityDueDate,

  // Patch management
  createPatchMetadata,
  validatePatchApplicability,
  generatePatchDeploymentPlan,

  // Asset mapping
  mapVulnerabilitiesToAssets,
  calculateAssetRiskScore,
  groupAssetsBySeverity,

  // Prioritization
  prioritizeVulnerability,
  sortVulnerabilitiesByPriority,

  // Code generation
  generateCVESequelizeModel,
  generateVulnerabilityLifecycleModel,
  generateVulnerabilityTrackingSchema,
  generateVulnerabilityManagementService,
  generateVulnerabilityTypeDefinitions,
  generateVulnerabilityAPISpec,
};
