{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///F:/temp/white-cross/frontend/src/identity-access/utils/tokenSecurity.types.ts"],"sourcesContent":["/**\r\n * @fileoverview Token Security Type Definitions\r\n * @module identity-access/utils/tokenSecurity.types\r\n *\r\n * Provides TypeScript type definitions and configuration constants for the token security system.\r\n * This module defines data structures for encrypted and unencrypted token storage, along with\r\n * security configuration constants used throughout the authentication system.\r\n *\r\n * Security Considerations:\r\n * - Token data contains sensitive user information and authentication tokens\r\n * - Encryption uses AES-GCM with 256-bit keys\r\n * - Expiration timestamps prevent use of stale tokens\r\n * - Legacy keys support backward compatibility during migration\r\n *\r\n * Related Modules:\r\n * - tokenSecurity.storage: Uses these types for token storage operations\r\n * - tokenSecurity.encryption: Uses EncryptedTokenData for encryption operations\r\n * - tokenSecurity.validation: Uses TokenData for validation logic\r\n *\r\n * @since 2025-11-04\r\n */\r\n\r\nimport { User } from '@/types';\r\n\r\n/**\r\n * Token data structure containing authentication token and metadata.\r\n *\r\n * This interface represents the complete token data stored in the application,\r\n * including the JWT token, associated user information, and temporal metadata\r\n * for expiration tracking.\r\n *\r\n * @interface TokenData\r\n *\r\n * @property {string} token - JWT authentication token string\r\n * @property {User} user - Complete user object associated with this token\r\n * @property {number} expiresAt - Unix timestamp (milliseconds) when token expires\r\n * @property {number} issuedAt - Unix timestamp (milliseconds) when token was issued\r\n *\r\n * @example\r\n * ```typescript\r\n * const tokenData: TokenData = {\r\n *   token: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...',\r\n *   user: { id: '123', email: 'nurse@example.com', role: 'NURSE' },\r\n *   expiresAt: Date.now() + 86400000, // 24 hours from now\r\n *   issuedAt: Date.now()\r\n * };\r\n * ```\r\n *\r\n * @see {@link TokenSecurityManager.storeToken} for token storage\r\n * @see {@link TokenSecurityManager.getValidToken} for token retrieval\r\n */\r\nexport interface TokenData {\r\n  token: string\r\n  user: User\r\n  expiresAt: number\r\n  issuedAt: number\r\n}\r\n\r\n/**\r\n * Encrypted token data structure for secure localStorage storage.\r\n *\r\n * Contains the encrypted token data along with the initialization vector (IV)\r\n * required for AES-GCM decryption. The timestamp helps track when data was\r\n * encrypted and can be used for additional security checks.\r\n *\r\n * @interface EncryptedTokenData\r\n *\r\n * @property {string} data - Base64-encoded encrypted token data\r\n * @property {string} iv - Base64-encoded initialization vector for AES-GCM decryption\r\n * @property {number} timestamp - Unix timestamp (milliseconds) when data was encrypted\r\n *\r\n * @example\r\n * ```typescript\r\n * const encrypted: EncryptedTokenData = {\r\n *   data: 'k7JHg92nVbX...',  // Base64 encrypted data\r\n *   iv: 'pLm9Qw8r...',        // Base64 IV\r\n *   timestamp: Date.now()\r\n * };\r\n * ```\r\n *\r\n * @remarks\r\n * - Uses AES-GCM encryption with 256-bit keys\r\n * - IV must be unique for each encryption operation\r\n * - Never reuse IVs with the same encryption key\r\n *\r\n * @see {@link EncryptionManager.encryptData} for encryption\r\n * @see {@link EncryptionManager.decryptData} for decryption\r\n */\r\nexport interface EncryptedTokenData {\r\n  data: string\r\n  iv: string\r\n  timestamp: number\r\n}\r\n\r\n/**\r\n * Configuration constants for token security operations.\r\n *\r\n * Defines all configuration values used throughout the token security system,\r\n * including storage keys, expiration buffers, and legacy key mappings for\r\n * backward compatibility.\r\n *\r\n * @constant\r\n * @type {Object}\r\n * @readonly\r\n *\r\n * @property {string} STORAGE_KEY - Primary localStorage key for encrypted token data\r\n * @property {string} ENCRYPTION_KEY_NAME - localStorage key for AES-GCM encryption key\r\n * @property {number} TOKEN_EXPIRY_BUFFER - Time buffer (5 minutes) before token expiration to trigger refresh\r\n * @property {number} DEFAULT_TOKEN_LIFETIME - Default token lifetime (24 hours) in milliseconds\r\n * @property {string[]} LEGACY_TOKEN_KEYS - Legacy localStorage keys for token migration\r\n * @property {string} LEGACY_USER_KEY - Legacy localStorage key for user data migration\r\n *\r\n * @example\r\n * ```typescript\r\n * // Check if token is expiring soon\r\n * const timeRemaining = tokenData.expiresAt - Date.now();\r\n * if (timeRemaining < TOKEN_SECURITY_CONFIG.TOKEN_EXPIRY_BUFFER) {\r\n *   // Trigger token refresh\r\n *   await refreshAuthToken();\r\n * }\r\n * ```\r\n *\r\n * @remarks\r\n * Security Considerations:\r\n * - STORAGE_KEY should be unique to prevent collisions with other app data\r\n * - TOKEN_EXPIRY_BUFFER provides time for refresh before hard expiration\r\n * - LEGACY_TOKEN_KEYS support migration from previous auth implementations\r\n * - All legacy keys are cleared on new token storage for security\r\n *\r\n * @since 2025-11-04\r\n */\r\nexport const TOKEN_SECURITY_CONFIG = {\r\n  STORAGE_KEY: 'auth_data',\r\n  ENCRYPTION_KEY_NAME: 'auth_encryption_key',\r\n  TOKEN_EXPIRY_BUFFER: 5 * 60 * 1000, // 5 minutes buffer\r\n  DEFAULT_TOKEN_LIFETIME: 24 * 60 * 60 * 1000, // 24 hours\r\n  LEGACY_TOKEN_KEYS: ['auth_token', 'token', 'authToken'],\r\n  LEGACY_USER_KEY: 'user'\r\n} as const;\r\n"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;CAoBC;;;;AA+GM,MAAM,wBAAwB;IACnC,aAAa;IACb,qBAAqB;IACrB,qBAAqB,IAAI,KAAK;IAC9B,wBAAwB,KAAK,KAAK,KAAK;IACvC,mBAAmB;QAAC;QAAc;QAAS;KAAY;IACvD,iBAAiB;AACnB","debugId":null}},
    {"offset": {"line": 44, "column": 0}, "map": {"version":3,"sources":["file:///F:/temp/white-cross/frontend/src/identity-access/utils/tokenSecurity.encryption.ts"],"sourcesContent":["/**\r\n * @fileoverview Token Encryption Utilities\r\n * @module identity-access/utils/tokenSecurity.encryption\r\n *\r\n * Provides encryption and decryption capabilities using the Web Crypto API for secure\r\n * token storage in localStorage. Implements AES-GCM encryption with 256-bit keys for\r\n * client-side token protection.\r\n *\r\n * Security Considerations:\r\n * - Uses AES-GCM (Galois/Counter Mode) for authenticated encryption\r\n * - Generates unique 256-bit encryption keys per browser\r\n * - Creates unique initialization vectors (IVs) for each encryption operation\r\n * - Keys stored in localStorage - consider httpOnly cookies for production\r\n * - Does NOT protect against XSS attacks (use CSP and input sanitization)\r\n * - localStorage is vulnerable to JavaScript access - httpOnly cookies preferred\r\n *\r\n * Architecture Notes:\r\n * - Singleton pattern via exported `encryptionManager` instance\r\n * - Lazy initialization on first use via `init()` method\r\n * - Graceful fallback to unencrypted storage if encryption unavailable\r\n *\r\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto} Web Crypto API\r\n * @see {@link TokenSecurityManager} for token storage operations using this encryption\r\n *\r\n * @since 2025-11-04\r\n */\r\n\r\nimport { EncryptedTokenData, TOKEN_SECURITY_CONFIG } from './tokenSecurity.types';\r\n\r\n/**\r\n * Encryption manager for secure token storage operations.\r\n *\r\n * Manages AES-GCM encryption and decryption using the Web Crypto API. Handles encryption\r\n * key generation, storage, and retrieval. Each encryption operation uses a unique\r\n * initialization vector (IV) for security.\r\n *\r\n * @class EncryptionManager\r\n *\r\n * @remarks\r\n * Security Limitations:\r\n * - localStorage encryption provides protection against casual inspection only\r\n * - Does NOT protect against XSS attacks that can access localStorage\r\n * - Encryption key is stored in localStorage, accessible to JavaScript\r\n * - For production systems, prefer httpOnly cookies for token storage\r\n *\r\n * Best Practices:\r\n * - Always call `init()` before using other methods\r\n * - Check `isEncryptionAvailable()` before encryption operations\r\n * - Implement proper Content Security Policy (CSP) to mitigate XSS\r\n * - Use in conjunction with HTTPS for transport security\r\n *\r\n * @example\r\n * ```typescript\r\n * // Initialize encryption manager\r\n * await encryptionManager.init();\r\n *\r\n * if (encryptionManager.isEncryptionAvailable()) {\r\n *   // Encrypt sensitive data\r\n *   const encrypted = await encryptionManager.encryptData('sensitive-token');\r\n *\r\n *   // Store encrypted data\r\n *   localStorage.setItem('auth', JSON.stringify(encrypted));\r\n *\r\n *   // Later, decrypt the data\r\n *   const stored = JSON.parse(localStorage.getItem('auth'));\r\n *   const decrypted = await encryptionManager.decryptData(stored);\r\n * }\r\n * ```\r\n *\r\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt} SubtleCrypto.encrypt\r\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/decrypt} SubtleCrypto.decrypt\r\n */\r\nexport class EncryptionManager {\r\n  /**\r\n   * Web Crypto API encryption key for AES-GCM operations.\r\n   * Null until initialization completes successfully.\r\n   *\r\n   * @private\r\n   * @type {CryptoKey | null}\r\n   */\r\n  private encryptionKey: CryptoKey | null = null;\r\n\r\n  /**\r\n   * Initializes the encryption manager.\r\n   *\r\n   * Retrieves an existing encryption key from localStorage or generates a new one\r\n   * if none exists. Must be called before performing any encryption operations.\r\n   *\r\n   * @async\r\n   * @returns {Promise<void>} Resolves when initialization completes\r\n   *\r\n   * @throws {Error} Logs error but does not throw - falls back to unencrypted storage\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * const manager = new EncryptionManager();\r\n   * await manager.init();\r\n   *\r\n   * if (manager.isEncryptionAvailable()) {\r\n   *   console.log('Encryption ready');\r\n   * } else {\r\n   *   console.warn('Encryption unavailable, using fallback');\r\n   * }\r\n   * ```\r\n   *\r\n   * @remarks\r\n   * - Generates a new 256-bit AES-GCM key if none exists\r\n   * - Stores key in localStorage for persistence across sessions\r\n   * - Falls back gracefully if Web Crypto API unavailable\r\n   * - Key generation uses cryptographically secure random number generator\r\n   */\r\n  async init(): Promise<void> {\r\n    try {\r\n      const keyData = localStorage.getItem(TOKEN_SECURITY_CONFIG.ENCRYPTION_KEY_NAME);\r\n      if (keyData) {\r\n        const keyBuffer = this.base64ToArrayBuffer(keyData);\r\n        this.encryptionKey = await crypto.subtle.importKey(\r\n          'raw',\r\n          keyBuffer,\r\n          { name: 'AES-GCM' },\r\n          false,\r\n          ['encrypt', 'decrypt']\r\n        );\r\n      } else {\r\n        await this.generateNewKey();\r\n      }\r\n    } catch (error) {\r\n      console.error('Failed to initialize encryption:', error);\r\n      console.warn('Using unencrypted token storage - consider implementing httpOnly cookies');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Generates a new AES-GCM encryption key.\r\n   *\r\n   * Creates a new 256-bit encryption key using the Web Crypto API and stores it\r\n   * in localStorage for future sessions. The key is generated using a\r\n   * cryptographically secure random number generator.\r\n   *\r\n   * @private\r\n   * @async\r\n   * @returns {Promise<void>} Resolves when key generation and storage complete\r\n   *\r\n   * @throws {Error} If key generation or storage fails\r\n   *\r\n   * @remarks\r\n   * Security Considerations:\r\n   * - Uses 256-bit key length for strong encryption\r\n   * - Key is exportable to enable localStorage storage\r\n   * - Key stored as base64-encoded string in localStorage\r\n   * - Each browser/device gets a unique key\r\n   * - Key persists across browser sessions until cleared\r\n   */\r\n  private async generateNewKey(): Promise<void> {\r\n    this.encryptionKey = await crypto.subtle.generateKey(\r\n      { name: 'AES-GCM', length: 256 },\r\n      true,\r\n      ['encrypt', 'decrypt']\r\n    );\r\n\r\n    const keyBuffer = await crypto.subtle.exportKey('raw', this.encryptionKey);\r\n    localStorage.setItem(\r\n      TOKEN_SECURITY_CONFIG.ENCRYPTION_KEY_NAME,\r\n      this.arrayBufferToBase64(keyBuffer)\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Checks if encryption is available and ready to use.\r\n   *\r\n   * Returns true if the encryption key has been successfully initialized and\r\n   * is ready for encryption/decryption operations.\r\n   *\r\n   * @returns {boolean} True if encryption key is available, false otherwise\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * if (encryptionManager.isEncryptionAvailable()) {\r\n   *   // Safe to encrypt\r\n   *   const encrypted = await encryptionManager.encryptData(data);\r\n   * } else {\r\n   *   // Use fallback (unencrypted storage)\r\n   *   localStorage.setItem('data', data);\r\n   * }\r\n   * ```\r\n   *\r\n   * @remarks\r\n   * - Should be checked before calling encryptData() or decryptData()\r\n   * - Returns false if init() hasn't been called or failed\r\n   * - Fallback to unencrypted storage recommended when false\r\n   */\r\n  isEncryptionAvailable(): boolean {\r\n    return this.encryptionKey !== null;\r\n  }\r\n\r\n  /**\r\n   * Encrypts string data using AES-GCM encryption.\r\n   *\r\n   * Encrypts the provided string data using AES-GCM with a unique initialization\r\n   * vector (IV) for each operation. Returns an object containing the encrypted\r\n   * data, IV, and timestamp.\r\n   *\r\n   * @async\r\n   * @param {string} data - String data to encrypt (typically JSON-serialized token data)\r\n   * @returns {Promise<EncryptedTokenData>} Object containing encrypted data, IV, and timestamp\r\n   *\r\n   * @throws {Error} If encryption key is not available (call init() first)\r\n   * @throws {Error} If encryption operation fails\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * await encryptionManager.init();\r\n   *\r\n   * const tokenData = JSON.stringify({\r\n   *   token: 'jwt-token-here',\r\n   *   user: { id: '123', email: 'user@example.com' }\r\n   * });\r\n   *\r\n   * const encrypted = await encryptionManager.encryptData(tokenData);\r\n   * console.log(encrypted);\r\n   * // {\r\n   * //   data: 'base64-encrypted-data',\r\n   * //   iv: 'base64-iv',\r\n   * //   timestamp: 1699564800000\r\n   * // }\r\n   * ```\r\n   *\r\n   * @remarks\r\n   * Security Features:\r\n   * - Uses AES-GCM for authenticated encryption\r\n   * - Generates unique 12-byte IV for each encryption\r\n   * - Includes timestamp for audit and age verification\r\n   * - IV must be stored with encrypted data for decryption\r\n   * - Never reuse an IV with the same key\r\n   *\r\n   * @see {@link decryptData} for decryption\r\n   * @see {@link EncryptedTokenData} for return type structure\r\n   */\r\n  async encryptData(data: string): Promise<EncryptedTokenData> {\r\n    if (!this.encryptionKey) {\r\n      throw new Error('Encryption key not available');\r\n    }\r\n\r\n    const iv = crypto.getRandomValues(new Uint8Array(12));\r\n    const encoder = new TextEncoder();\r\n    const encodedData = encoder.encode(data);\r\n\r\n    const encrypted = await crypto.subtle.encrypt(\r\n      { name: 'AES-GCM', iv },\r\n      this.encryptionKey,\r\n      encodedData\r\n    );\r\n\r\n    return {\r\n      data: this.arrayBufferToBase64(encrypted),\r\n      iv: this.arrayBufferToBase64(iv.buffer),\r\n      timestamp: Date.now()\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Decrypts AES-GCM encrypted data.\r\n   *\r\n   * Decrypts data that was previously encrypted with encryptData(). Requires the\r\n   * original initialization vector (IV) that was used during encryption.\r\n   *\r\n   * @async\r\n   * @param {EncryptedTokenData} encryptedData - Object containing encrypted data and IV\r\n   * @returns {Promise<string>} Decrypted string data\r\n   *\r\n   * @throws {Error} If encryption key is not available (call init() first)\r\n   * @throws {Error} If decryption fails (corrupted data, wrong key, or tampered data)\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * const encryptedData = {\r\n   *   data: 'base64-encrypted-data',\r\n   *   iv: 'base64-iv',\r\n   *   timestamp: 1699564800000\r\n   * };\r\n   *\r\n   * try {\r\n   *   const decrypted = await encryptionManager.decryptData(encryptedData);\r\n   *   const tokenData = JSON.parse(decrypted);\r\n   *   console.log('Token:', tokenData.token);\r\n   * } catch (error) {\r\n   *   console.error('Decryption failed:', error);\r\n   *   // Handle corrupted or tampered data\r\n   * }\r\n   * ```\r\n   *\r\n   * @remarks\r\n   * Security Features:\r\n   * - AES-GCM provides authenticated encryption (detects tampering)\r\n   * - Decryption fails if data has been modified\r\n   * - Decryption fails if wrong key is used\r\n   * - Always handle decryption errors gracefully\r\n   *\r\n   * Error Scenarios:\r\n   * - Data corrupted: Decryption throws error\r\n   * - Data tampered: Authentication tag mismatch\r\n   * - Wrong key: Decryption fails\r\n   * - Invalid IV: Decryption fails\r\n   *\r\n   * @see {@link encryptData} for encryption\r\n   * @see {@link EncryptedTokenData} for parameter structure\r\n   */\r\n  async decryptData(encryptedData: EncryptedTokenData): Promise<string> {\r\n    if (!this.encryptionKey) {\r\n      throw new Error('Encryption key not available');\r\n    }\r\n\r\n    const iv = this.base64ToArrayBuffer(encryptedData.iv);\r\n    const data = this.base64ToArrayBuffer(encryptedData.data);\r\n\r\n    const decrypted = await crypto.subtle.decrypt(\r\n      { name: 'AES-GCM', iv },\r\n      this.encryptionKey,\r\n      data\r\n    );\r\n\r\n    const decoder = new TextDecoder();\r\n    return decoder.decode(decrypted);\r\n  }\r\n\r\n  /**\r\n   * Converts ArrayBuffer to base64-encoded string.\r\n   *\r\n   * Utility method to encode binary data as base64 for storage in localStorage.\r\n   * Uses the btoa() function for encoding.\r\n   *\r\n   * @private\r\n   * @param {ArrayBuffer} buffer - Binary data to encode\r\n   * @returns {string} Base64-encoded string\r\n   *\r\n   * @remarks\r\n   * - Used for encoding encrypted data and IVs\r\n   * - Output is safe for localStorage storage\r\n   * - Inverse operation: {@link base64ToArrayBuffer}\r\n   */\r\n  private arrayBufferToBase64(buffer: ArrayBuffer): string {\r\n    const bytes = new Uint8Array(buffer);\r\n    let binary = '';\r\n    for (let i = 0; i < bytes.byteLength; i++) {\r\n      binary += String.fromCharCode(bytes[i]);\r\n    }\r\n    return btoa(binary);\r\n  }\r\n\r\n  /**\r\n   * Converts base64-encoded string to ArrayBuffer.\r\n   *\r\n   * Utility method to decode base64 strings from localStorage back into binary\r\n   * data for cryptographic operations. Uses the atob() function for decoding.\r\n   *\r\n   * @private\r\n   * @param {string} base64 - Base64-encoded string to decode\r\n   * @returns {ArrayBuffer} Binary data as ArrayBuffer\r\n   *\r\n   * @remarks\r\n   * - Used for decoding stored encrypted data and IVs\r\n   * - Inverse operation: {@link arrayBufferToBase64}\r\n   * - Required before decryption operations\r\n   */\r\n  private base64ToArrayBuffer(base64: string): ArrayBuffer {\r\n    const binary = atob(base64);\r\n    const bytes = new Uint8Array(binary.length);\r\n    for (let i = 0; i < binary.length; i++) {\r\n      bytes[i] = binary.charCodeAt(i);\r\n    }\r\n    return bytes.buffer;\r\n  }\r\n}\r\n\r\n/**\r\n * Singleton instance of EncryptionManager.\r\n *\r\n * Pre-instantiated encryption manager for application-wide use. Should be\r\n * initialized with `await encryptionManager.init()` before first use.\r\n *\r\n * @constant\r\n * @type {EncryptionManager}\r\n *\r\n * @example\r\n * ```typescript\r\n * // Initialize on app startup\r\n * await encryptionManager.init();\r\n *\r\n * // Use throughout the application\r\n * const encrypted = await encryptionManager.encryptData(data);\r\n * ```\r\n *\r\n * @see {@link EncryptionManager} for class documentation\r\n */\r\nexport const encryptionManager = new EncryptionManager();\r\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 357, "column": 0}, "map": {"version":3,"sources":["file:///F:/temp/white-cross/frontend/src/identity-access/utils/tokenSecurity.storage.ts"],"sourcesContent":["/**\r\n * @fileoverview Token Storage Management\r\n * @module identity-access/utils/tokenSecurity.storage\r\n *\r\n * Provides secure token storage operations with encryption, expiration tracking, and\r\n * legacy migration support. Manages the complete lifecycle of authentication token\r\n * storage in localStorage with AES-GCM encryption.\r\n *\r\n * Security Considerations:\r\n * - Tokens are encrypted before storage using AES-GCM\r\n * - Expiration timestamps prevent use of stale tokens\r\n * - Automatic expiration checking on retrieval\r\n * - Legacy key cleanup on new token storage\r\n * - Falls back to unencrypted storage if encryption unavailable\r\n * - Consider httpOnly cookies for production environments\r\n *\r\n * Architecture Notes:\r\n * - Singleton pattern via exported `tokenSecurityManager` instance\r\n * - Depends on EncryptionManager for encryption operations\r\n * - Provides both synchronous (clearToken) and async operations\r\n * - Supports graceful migration from legacy storage formats\r\n *\r\n * @see {@link encryptionManager} for encryption implementation\r\n * @see {@link TokenData} for token data structure\r\n *\r\n * @since 2025-11-04\r\n */\r\n\r\nimport { User } from '@/types';\r\nimport { TokenData, EncryptedTokenData, TOKEN_SECURITY_CONFIG } from './tokenSecurity.types';\r\nimport { encryptionManager } from './tokenSecurity.encryption';\r\n\r\n/**\r\n * Token security manager for secure storage operations.\r\n *\r\n * Manages the complete lifecycle of authentication token storage including\r\n * encryption, expiration tracking, and retrieval with validation. Provides\r\n * methods for storing, retrieving, updating, and clearing tokens.\r\n *\r\n * @class TokenSecurityManager\r\n *\r\n * @remarks\r\n * Security Features:\r\n * - AES-GCM encryption for stored tokens\r\n * - Automatic expiration validation on retrieval\r\n * - 5-minute expiry buffer for token refresh\r\n * - Legacy storage key cleanup\r\n * - Graceful fallback if encryption unavailable\r\n *\r\n * Typical Usage Pattern:\r\n * 1. Initialize on app startup: `await tokenSecurityManager.init()`\r\n * 2. Store token after login: `await tokenSecurityManager.storeToken(token, user)`\r\n * 3. Retrieve token when needed: `await tokenSecurityManager.getValidToken()`\r\n * 4. Clear on logout: `tokenSecurityManager.clearToken()`\r\n *\r\n * @example\r\n * ```typescript\r\n * // Initialize on app startup\r\n * await tokenSecurityManager.init();\r\n *\r\n * // Store token after successful login\r\n * await tokenSecurityManager.storeToken(\r\n *   'jwt-token-string',\r\n *   { id: '123', email: 'user@example.com', role: 'NURSE' },\r\n *   24 * 60 * 60 * 1000 // 24 hours\r\n * );\r\n *\r\n * // Later, retrieve valid token\r\n * const tokenData = await tokenSecurityManager.getValidToken();\r\n * if (tokenData) {\r\n *   // Use token for authenticated request\r\n *   makeAuthenticatedRequest(tokenData.token);\r\n * } else {\r\n *   // Token expired or invalid, redirect to login\r\n *   redirectToLogin();\r\n * }\r\n *\r\n * // Clear on logout\r\n * tokenSecurityManager.clearToken();\r\n * ```\r\n *\r\n * @see {@link storeToken} for storing tokens\r\n * @see {@link getValidToken} for retrieving tokens\r\n * @see {@link clearToken} for clearing tokens\r\n */\r\nexport class TokenSecurityManager {\r\n  /**\r\n   * Initializes the token security manager.\r\n   *\r\n   * Must be called before performing any token operations. Initializes the\r\n   * underlying encryption manager for secure storage.\r\n   *\r\n   * @async\r\n   * @returns {Promise<void>} Resolves when initialization completes\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * const manager = new TokenSecurityManager();\r\n   * await manager.init();\r\n   * // Manager is now ready for token operations\r\n   * ```\r\n   *\r\n   * @remarks\r\n   * - Should be called once during application initialization\r\n   * - Safe to call multiple times (idempotent)\r\n   * - Initializes encryption subsystem\r\n   * - No-op if encryption unavailable (falls back to unencrypted storage)\r\n   *\r\n   * @see {@link EncryptionManager.init} for encryption initialization details\r\n   */\r\n  async init(): Promise<void> {\r\n    await encryptionManager.init();\r\n  }\r\n\r\n  /**\r\n   * Stores authentication token with encryption and expiration metadata.\r\n   *\r\n   * Encrypts the token and user data before storing in localStorage. Includes\r\n   * expiration timestamp for automatic validation on retrieval. Clears legacy\r\n   * storage keys if present.\r\n   *\r\n   * @async\r\n   * @param {string} token - JWT authentication token to store\r\n   * @param {User} user - User object associated with the token\r\n   * @param {number} [expiresIn=24h] - Token lifetime in milliseconds (defaults to 24 hours)\r\n   * @returns {Promise<void>} Resolves when storage completes\r\n   *\r\n   * @throws {Error} If token storage fails (encryption error, localStorage full, etc.)\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * // Store token with default 24-hour expiration\r\n   * await tokenSecurityManager.storeToken(\r\n   *   'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...',\r\n   *   { id: '123', email: 'nurse@example.com', role: 'NURSE' }\r\n   * );\r\n   *\r\n   * // Store token with custom expiration (1 hour)\r\n   * await tokenSecurityManager.storeToken(\r\n   *   token,\r\n   *   user,\r\n   *   60 * 60 * 1000\r\n   * );\r\n   * ```\r\n   *\r\n   * @remarks\r\n   * Security Features:\r\n   * - Encrypts token and user data using AES-GCM\r\n   * - Stores issued and expiration timestamps\r\n   * - Falls back to unencrypted storage if encryption unavailable\r\n   * - Logs error but throws if storage fails\r\n   *\r\n   * Storage Structure:\r\n   * - Stores encrypted TokenData in localStorage\r\n   * - Uses key from TOKEN_SECURITY_CONFIG.STORAGE_KEY\r\n   * - Includes timestamp, IV, and encrypted payload\r\n   *\r\n   * @see {@link getValidToken} for retrieving stored tokens\r\n   * @see {@link TokenData} for stored data structure\r\n   */\r\n  async storeToken(\r\n    token: string,\r\n    user: User,\r\n    expiresIn: number = TOKEN_SECURITY_CONFIG.DEFAULT_TOKEN_LIFETIME\r\n  ): Promise<void> {\r\n    const now = Date.now();\r\n    const tokenData: TokenData = {\r\n      token,\r\n      user,\r\n      expiresAt: now + expiresIn,\r\n      issuedAt: now\r\n    };\r\n\r\n    try {\r\n      if (encryptionManager.isEncryptionAvailable()) {\r\n        const encrypted = await encryptionManager.encryptData(JSON.stringify(tokenData));\r\n        localStorage.setItem(TOKEN_SECURITY_CONFIG.STORAGE_KEY, JSON.stringify(encrypted));\r\n      } else {\r\n        // Fallback to unencrypted storage\r\n        localStorage.setItem(TOKEN_SECURITY_CONFIG.STORAGE_KEY, JSON.stringify(tokenData));\r\n      }\r\n    } catch (error) {\r\n      console.error('Failed to store encrypted token:', error);\r\n      throw new Error('Token storage failed');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Retrieves and validates stored token.\r\n   *\r\n   * Retrieves the token from localStorage, decrypts it if encrypted, and validates\r\n   * expiration. Returns null if token is expired, invalid, or not found. Logs\r\n   * warning if token is close to expiring (within 5-minute buffer).\r\n   *\r\n   * @async\r\n   * @returns {Promise<TokenData | null>} Token data if valid, null if expired/invalid/missing\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * const tokenData = await tokenSecurityManager.getValidToken();\r\n   *\r\n   * if (tokenData) {\r\n   *   // Token is valid, use it\r\n   *   const response = await fetch('/api/protected', {\r\n   *     headers: {\r\n   *       'Authorization': `Bearer ${tokenData.token}`\r\n   *     }\r\n   *   });\r\n   * } else {\r\n   *   // Token is expired or missing, redirect to login\r\n   *   router.push('/login');\r\n   * }\r\n   * ```\r\n   *\r\n   * @remarks\r\n   * Validation Logic:\r\n   * - Returns null if no token stored\r\n   * - Attempts decryption if encrypted\r\n   * - Falls back to unencrypted parsing if decryption fails\r\n   * - Validates expiration timestamp\r\n   * - Clears token if expired\r\n   * - Warns if token expiring within 5-minute buffer\r\n   *\r\n   * Expiration Handling:\r\n   * - Expired tokens are automatically cleared\r\n   * - Tokens expiring soon (< 5 min) log warning\r\n   * - Use warning to trigger token refresh\r\n   *\r\n   * Error Handling:\r\n   * - Logs errors and clears invalid tokens\r\n   * - Returns null on any error (graceful degradation)\r\n   * - Handles both encrypted and unencrypted fallback\r\n   *\r\n   * @see {@link storeToken} for storing tokens\r\n   * @see {@link isTokenValid} for simple validation check\r\n   * @see {@link TOKEN_SECURITY_CONFIG.TOKEN_EXPIRY_BUFFER} for expiry buffer duration\r\n   */\r\n  async getValidToken(): Promise<TokenData | null> {\r\n    try {\r\n      const storedData = localStorage.getItem(TOKEN_SECURITY_CONFIG.STORAGE_KEY);\r\n      if (!storedData) return null;\r\n\r\n      let tokenData: TokenData;\r\n\r\n      if (encryptionManager.isEncryptionAvailable()) {\r\n        try {\r\n          const encryptedData: EncryptedTokenData = JSON.parse(storedData);\r\n          const decryptedString = await encryptionManager.decryptData(encryptedData);\r\n          tokenData = JSON.parse(decryptedString);\r\n        } catch (decryptError) {\r\n          console.warn('Failed to decrypt token, attempting fallback:', decryptError);\r\n          // Try to parse as unencrypted data\r\n          tokenData = JSON.parse(storedData);\r\n        }\r\n      } else {\r\n        tokenData = JSON.parse(storedData);\r\n      }\r\n\r\n      // Validate token expiration\r\n      const now = Date.now();\r\n      if (tokenData.expiresAt && tokenData.expiresAt < now) {\r\n        this.clearToken();\r\n        return null;\r\n      }\r\n\r\n      // Check if token is close to expiring (within buffer time)\r\n      if (\r\n        tokenData.expiresAt &&\r\n        (tokenData.expiresAt - now) < TOKEN_SECURITY_CONFIG.TOKEN_EXPIRY_BUFFER\r\n      ) {\r\n        console.warn('Token is close to expiring');\r\n        // Could trigger refresh here\r\n      }\r\n\r\n      return tokenData;\r\n    } catch (error) {\r\n      console.error('Failed to retrieve token:', error);\r\n      this.clearToken();\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Checks if current token is valid without retrieving full data.\r\n   *\r\n   * Convenience method to check token validity without retrieving the full\r\n   * token data object. More efficient than calling getValidToken() when you\r\n   * only need to know if a valid token exists.\r\n   *\r\n   * @async\r\n   * @returns {Promise<boolean>} True if valid token exists, false otherwise\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * if (await tokenSecurityManager.isTokenValid()) {\r\n   *   // User is authenticated, proceed\r\n   *   renderDashboard();\r\n   * } else {\r\n   *   // User not authenticated, redirect\r\n   *   redirectToLogin();\r\n   * }\r\n   * ```\r\n   *\r\n   * @remarks\r\n   * - Internally calls {@link getValidToken} and checks for null\r\n   * - Performs full validation including expiration checking\r\n   * - Does not return the token data (more secure for simple checks)\r\n   * - Use when you only need authentication status, not token details\r\n   *\r\n   * @see {@link getValidToken} for retrieving token data\r\n   */\r\n  async isTokenValid(): Promise<boolean> {\r\n    const tokenData = await this.getValidToken();\r\n    return tokenData !== null;\r\n  }\r\n\r\n  /**\r\n   * Gets the current authenticated user from stored token.\r\n   *\r\n   * Retrieves the user object from the stored token data. Returns null if\r\n   * token is expired, invalid, or not found.\r\n   *\r\n   * @async\r\n   * @returns {Promise<User | null>} User object if token valid, null otherwise\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * const user = await tokenSecurityManager.getCurrentUser();\r\n   *\r\n   * if (user) {\r\n   *   console.log(`Welcome, ${user.email}!`);\r\n   *   console.log(`Role: ${user.role}`);\r\n   * } else {\r\n   *   console.log('No authenticated user');\r\n   * }\r\n   * ```\r\n   *\r\n   * @remarks\r\n   * - Performs full token validation before returning user\r\n   * - Returns null if token is expired\r\n   * - Use when you need user details for authenticated requests\r\n   * - More efficient than getValidToken() if you only need user data\r\n   *\r\n   * @see {@link getValidToken} for full token data\r\n   * @see {@link isTokenValid} for authentication check only\r\n   */\r\n  async getCurrentUser(): Promise<User | null> {\r\n    const tokenData = await this.getValidToken();\r\n    return tokenData?.user || null;\r\n  }\r\n\r\n  /**\r\n   * Clears all stored authentication data.\r\n   *\r\n   * Removes the current token and clears all legacy storage keys for backward\r\n   * compatibility. Should be called on logout or when token becomes invalid.\r\n   *\r\n   * @returns {void}\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * // On user logout\r\n   * tokenSecurityManager.clearToken();\r\n   * router.push('/login');\r\n   * ```\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * // After detecting invalid token\r\n   * const tokenData = await tokenSecurityManager.getValidToken();\r\n   * if (!tokenData) {\r\n   *   tokenSecurityManager.clearToken();\r\n   *   showSessionExpiredMessage();\r\n   * }\r\n   * ```\r\n   *\r\n   * @remarks\r\n   * Security Features:\r\n   * - Clears primary storage key\r\n   * - Clears all legacy storage keys\r\n   * - Synchronous operation (no await needed)\r\n   * - Safe to call multiple times (idempotent)\r\n   *\r\n   * Cleared Keys:\r\n   * - Primary: 'auth_data'\r\n   * - Legacy: 'auth_token', 'token', 'authToken', 'user'\r\n   *\r\n   * Best Practices:\r\n   * - Always call on logout\r\n   * - Call when detecting expired tokens\r\n   * - Call before redirecting to login\r\n   * - Consider clearing other app state simultaneously\r\n   *\r\n   * @see {@link TOKEN_SECURITY_CONFIG.LEGACY_TOKEN_KEYS} for legacy keys\r\n   */\r\n  clearToken(): void {\r\n    localStorage.removeItem(TOKEN_SECURITY_CONFIG.STORAGE_KEY);\r\n\r\n    // Clear legacy storage keys for backward compatibility\r\n    TOKEN_SECURITY_CONFIG.LEGACY_TOKEN_KEYS.forEach(key => {\r\n      localStorage.removeItem(key);\r\n    });\r\n\r\n    localStorage.removeItem(TOKEN_SECURITY_CONFIG.LEGACY_USER_KEY);\r\n  }\r\n\r\n  /**\r\n   * Updates user data in stored token while preserving token and expiration.\r\n   *\r\n   * Updates only the user object in the stored token data, keeping the token\r\n   * string and expiration unchanged. Useful when user profile is updated but\r\n   * token remains valid.\r\n   *\r\n   * @async\r\n   * @param {User} user - Updated user object\r\n   * @returns {Promise<void>} Resolves when update completes\r\n   *\r\n   * @throws {Error} If token storage fails during update\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * // After user profile update\r\n   * const updatedUser = { ...currentUser, name: 'New Name' };\r\n   * await tokenSecurityManager.updateUser(updatedUser);\r\n   * ```\r\n   *\r\n   * @remarks\r\n   * Use Cases:\r\n   * - User profile updated on server\r\n   * - Role or permissions changed\r\n   * - User preferences updated\r\n   * - Any user metadata change while token stays valid\r\n   *\r\n   * Behavior:\r\n   * - Retrieves current token data\r\n   * - Replaces user object only\r\n   * - Preserves token string and expiration\r\n   * - Re-encrypts and stores updated data\r\n   * - No-op if no valid token exists\r\n   *\r\n   * Important Notes:\r\n   * - Does not update the actual JWT token\r\n   * - Only updates the cached user object\r\n   * - Token expiration remains unchanged\r\n   * - Silently fails if no token exists\r\n   *\r\n   * @see {@link storeToken} for full token storage\r\n   * @see {@link getCurrentUser} for retrieving user data\r\n   */\r\n  async updateUser(user: User): Promise<void> {\r\n    const tokenData = await this.getValidToken();\r\n    if (tokenData) {\r\n      tokenData.user = user;\r\n      await this.storeToken(tokenData.token, user, tokenData.expiresAt - Date.now());\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Gets the raw JWT token string if available and valid.\r\n   *\r\n   * Retrieves only the token string without other metadata. Returns null if\r\n   * token is expired, invalid, or not found.\r\n   *\r\n   * @async\r\n   * @returns {Promise<string | null>} JWT token string or null\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * const token = await tokenSecurityManager.getToken();\r\n   *\r\n   * if (token) {\r\n   *   // Add token to request headers\r\n   *   const headers = {\r\n   *     'Authorization': `Bearer ${token}`\r\n   *   };\r\n   * }\r\n   * ```\r\n   *\r\n   * @remarks\r\n   * - Performs full validation before returning token\r\n   * - Returns null if token expired\r\n   * - Use for authenticated API requests\r\n   * - More efficient than getValidToken() if you only need token string\r\n   *\r\n   * @see {@link getValidToken} for full token data\r\n   * @see {@link getCurrentUser} for user data only\r\n   */\r\n  async getToken(): Promise<string | null> {\r\n    const tokenData = await this.getValidToken();\r\n    return tokenData?.token || null;\r\n  }\r\n\r\n  /**\r\n   * Gets token expiration timestamp.\r\n   *\r\n   * Retrieves the expiration timestamp from stored token data. Useful for\r\n   * displaying countdown timers or determining when to refresh token.\r\n   *\r\n   * @async\r\n   * @returns {Promise<number | null>} Unix timestamp (ms) of expiration, or null if no valid token\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * const expiresAt = await tokenSecurityManager.getTokenExpiration();\r\n   *\r\n   * if (expiresAt) {\r\n   *   const timeRemaining = expiresAt - Date.now();\r\n   *   const minutesRemaining = Math.floor(timeRemaining / 60000);\r\n   *   console.log(`Token expires in ${minutesRemaining} minutes`);\r\n   *\r\n   *   // Refresh if less than 5 minutes remaining\r\n   *   if (minutesRemaining < 5) {\r\n   *     await refreshToken();\r\n   *   }\r\n   * }\r\n   * ```\r\n   *\r\n   * @remarks\r\n   * - Performs full validation before returning expiration\r\n   * - Returns null if token expired or invalid\r\n   * - Timestamp is in milliseconds (use Date.now() for comparison)\r\n   * - Useful for implementing session timers\r\n   * - Can be used to trigger proactive token refresh\r\n   *\r\n   * @see {@link getValidToken} for full token data\r\n   * @see {@link isTokenValid} for simple validity check\r\n   * @see {@link TOKEN_SECURITY_CONFIG.TOKEN_EXPIRY_BUFFER} for expiry buffer\r\n   */\r\n  async getTokenExpiration(): Promise<number | null> {\r\n    const tokenData = await this.getValidToken();\r\n    return tokenData?.expiresAt || null;\r\n  }\r\n}\r\n\r\n/**\r\n * Singleton instance of TokenSecurityManager.\r\n *\r\n * Pre-instantiated token security manager for application-wide use. Should be\r\n * initialized with `await tokenSecurityManager.init()` before first use.\r\n *\r\n * @constant\r\n * @type {TokenSecurityManager}\r\n *\r\n * @example\r\n * ```typescript\r\n * // Initialize on app startup (e.g., in _app.tsx or layout.tsx)\r\n * await tokenSecurityManager.init();\r\n *\r\n * // Use throughout the application\r\n * const user = await tokenSecurityManager.getCurrentUser();\r\n * ```\r\n *\r\n * @see {@link TokenSecurityManager} for class documentation\r\n */\r\nexport const tokenSecurityManager = new TokenSecurityManager();\r\n"],"names":[],"mappings":"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","debugId":null}}]
}