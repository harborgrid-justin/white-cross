{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 40, "column": 0}, "map": {"version":3,"sources":["file:///F:/temp/white-cross/frontend/src/identity-access/lib/config/cookies.ts"],"sourcesContent":["/**\r\n * @fileoverview Centralized Cookie Configuration\r\n * @module lib/config/cookies\r\n *\r\n * Single source of truth for all authentication cookie settings.\r\n * Implements security best practices including:\r\n * - __Host- prefix for maximum security\r\n * - Consistent naming across the application\r\n * - Secure defaults for production environments\r\n * - HIPAA-compliant session management\r\n *\r\n * Security Features:\r\n * - __Host- prefix prevents subdomain and path manipulation\r\n * - httpOnly prevents XSS attacks\r\n * - secure ensures HTTPS-only transmission\r\n * - sameSite prevents CSRF attacks\r\n * - Appropriate maxAge for healthcare security requirements\r\n *\r\n * @see https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie\r\n * @see https://web.dev/first-party-cookie-recipes/\r\n */\r\n\r\nimport { ResponseCookie } from 'next/dist/compiled/@edge-runtime/cookies';\r\n\r\n/**\r\n * Cookie names with __Host- prefix for maximum security\r\n *\r\n * The __Host- prefix ensures:\r\n * - Cookie must be set with Secure flag\r\n * - Cookie must be set from a secure origin (HTTPS)\r\n * - Cookie must NOT have a Domain attribute (preventing subdomain access)\r\n * - Cookie path must be /\r\n *\r\n * NOTE: __Host- prefix requires HTTPS. In development (localhost), we use\r\n * regular cookie names without the prefix.\r\n */\r\nexport const COOKIE_NAMES = {\r\n  /** Access token for API authentication */\r\n  ACCESS_TOKEN: process.env.NODE_ENV === 'production' ? '__Host-auth.token' : 'auth.token',\r\n\r\n  /** Refresh token for obtaining new access tokens */\r\n  REFRESH_TOKEN: process.env.NODE_ENV === 'production' ? '__Host-auth.refresh' : 'auth.refresh',\r\n\r\n  /** Session identifier (if using session-based auth alongside JWT) */\r\n  SESSION_ID: process.env.NODE_ENV === 'production' ? '__Host-auth.session' : 'auth.session',\r\n} as const;\r\n\r\n/**\r\n * Cookie expiration times in seconds\r\n */\r\nexport const COOKIE_MAX_AGE = {\r\n  /** Access token: 1 hour (short-lived for security) */\r\n  ACCESS_TOKEN: 60 * 60,\r\n\r\n  /** Refresh token: 7 days (allows persistent login) */\r\n  REFRESH_TOKEN: 7 * 24 * 60 * 60,\r\n\r\n  /** Session: 24 hours (daily re-authentication for HIPAA compliance) */\r\n  SESSION: 24 * 60 * 60,\r\n} as const;\r\n\r\n/**\r\n * Base cookie options for all authentication cookies\r\n * These settings ensure maximum security\r\n */\r\nconst BASE_COOKIE_OPTIONS: Partial<ResponseCookie> = {\r\n  /** Path where cookie is valid */\r\n  path: '/',\r\n\r\n  /** Prevent JavaScript access (XSS protection) */\r\n  httpOnly: true,\r\n\r\n  /** Strict CSRF protection - cookie only sent to same-site requests */\r\n  sameSite: 'strict',\r\n\r\n  /** Only send over HTTPS in production */\r\n  secure: process.env.NODE_ENV === 'production',\r\n} as const;\r\n\r\n/**\r\n * Get cookie options for access token\r\n *\r\n * @param overrides - Optional overrides for specific use cases\r\n * @returns Complete cookie configuration for access token\r\n *\r\n * @example\r\n * ```typescript\r\n * import { cookies } from 'next/headers';\r\n * import { getAccessTokenCookieOptions, COOKIE_NAMES } from './config/cookies';\r\n *\r\n * const cookieStore = await cookies();\r\n * cookieStore.set(COOKIE_NAMES.ACCESS_TOKEN, token, getAccessTokenCookieOptions());\r\n * ```\r\n */\r\nexport function getAccessTokenCookieOptions(\r\n  overrides?: Partial<ResponseCookie>\r\n): ResponseCookie {\r\n  return {\r\n    ...BASE_COOKIE_OPTIONS,\r\n    maxAge: COOKIE_MAX_AGE.ACCESS_TOKEN,\r\n    ...overrides,\r\n  } as ResponseCookie;\r\n}\r\n\r\n/**\r\n * Get cookie options for refresh token\r\n *\r\n * @param overrides - Optional overrides for specific use cases\r\n * @returns Complete cookie configuration for refresh token\r\n *\r\n * @example\r\n * ```typescript\r\n * cookieStore.set(COOKIE_NAMES.REFRESH_TOKEN, refreshToken, getRefreshTokenCookieOptions());\r\n * ```\r\n */\r\nexport function getRefreshTokenCookieOptions(\r\n  overrides?: Partial<ResponseCookie>\r\n): ResponseCookie {\r\n  return {\r\n    ...BASE_COOKIE_OPTIONS,\r\n    maxAge: COOKIE_MAX_AGE.REFRESH_TOKEN,\r\n    ...overrides,\r\n  } as ResponseCookie;\r\n}\r\n\r\n/**\r\n * Get cookie options for session identifier\r\n *\r\n * @param overrides - Optional overrides for specific use cases\r\n * @returns Complete cookie configuration for session\r\n *\r\n * @example\r\n * ```typescript\r\n * cookieStore.set(COOKIE_NAMES.SESSION_ID, sessionId, getSessionCookieOptions());\r\n * ```\r\n */\r\nexport function getSessionCookieOptions(\r\n  overrides?: Partial<ResponseCookie>\r\n): ResponseCookie {\r\n  return {\r\n    ...BASE_COOKIE_OPTIONS,\r\n    maxAge: COOKIE_MAX_AGE.SESSION,\r\n    ...overrides,\r\n  } as ResponseCookie;\r\n}\r\n\r\n/**\r\n * Legacy cookie names for migration support\r\n * These should be removed in a future version\r\n *\r\n * @deprecated Use COOKIE_NAMES instead\r\n */\r\nexport const LEGACY_COOKIE_NAMES = {\r\n  auth_token: 'auth_token',\r\n  refresh_token: 'refresh_token',\r\n  authToken: 'authToken',\r\n  refreshToken: 'refreshToken',\r\n} as const;\r\n\r\n/**\r\n * Clear all authentication cookies\r\n * Useful for logout operations\r\n *\r\n * @param cookieStore - Next.js cookies() instance\r\n *\r\n * @example\r\n * ```typescript\r\n * import { cookies } from 'next/headers';\r\n * import { clearAuthCookies } from './config/cookies';\r\n *\r\n * export async function logout() {\r\n *   const cookieStore = await cookies();\r\n *   clearAuthCookies(cookieStore);\r\n * }\r\n * ```\r\n */\r\nexport async function clearAuthCookies(\r\n  cookieStore: Awaited<ReturnType<typeof import('next/headers').cookies>>\r\n): Promise<void> {\r\n  // Clear current cookies\r\n  cookieStore.delete(COOKIE_NAMES.ACCESS_TOKEN);\r\n  cookieStore.delete(COOKIE_NAMES.REFRESH_TOKEN);\r\n  cookieStore.delete(COOKIE_NAMES.SESSION_ID);\r\n\r\n  // Clear legacy cookies for migration\r\n  Object.values(LEGACY_COOKIE_NAMES).forEach((name) => {\r\n    cookieStore.delete(name);\r\n  });\r\n}\r\n\r\n/**\r\n * Get token from cookies with fallback to legacy names\r\n * This supports migration from old cookie names to new secure names\r\n *\r\n * @param cookieStore - Next.js cookies() instance\r\n * @returns Access token if found, null otherwise\r\n *\r\n * @example\r\n * ```typescript\r\n * const token = getAccessTokenFromCookies(await cookies());\r\n * if (token) {\r\n *   // Verify and use token\r\n * }\r\n * ```\r\n */\r\nexport function getAccessTokenFromCookies(\r\n  cookieStore: Awaited<ReturnType<typeof import('next/headers').cookies>>\r\n): string | null {\r\n  // Try new secure cookie name first\r\n  let token = cookieStore.get(COOKIE_NAMES.ACCESS_TOKEN)?.value;\r\n\r\n  if (token) {\r\n    return token;\r\n  }\r\n\r\n  // Fall back to legacy names for migration\r\n  for (const legacyName of Object.values(LEGACY_COOKIE_NAMES)) {\r\n    token = cookieStore.get(legacyName)?.value;\r\n    if (token) {\r\n      console.warn(\r\n        `[Cookie Migration] Found token in legacy cookie '${legacyName}'. ` +\r\n        `Please migrate to '${COOKIE_NAMES.ACCESS_TOKEN}' for improved security.`\r\n      );\r\n      return token;\r\n    }\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\n/**\r\n * Get refresh token from cookies with fallback to legacy names\r\n *\r\n * @param cookieStore - Next.js cookies() instance\r\n * @returns Refresh token if found, null otherwise\r\n */\r\nexport function getRefreshTokenFromCookies(\r\n  cookieStore: Awaited<ReturnType<typeof import('next/headers').cookies>>\r\n): string | null {\r\n  // Try new secure cookie name first\r\n  const token = cookieStore.get(COOKIE_NAMES.REFRESH_TOKEN)?.value;\r\n\r\n  if (token) {\r\n    return token;\r\n  }\r\n\r\n  // Fall back to legacy refresh_token\r\n  const legacyToken = cookieStore.get(LEGACY_COOKIE_NAMES.refresh_token)?.value ||\r\n                      cookieStore.get(LEGACY_COOKIE_NAMES.refreshToken)?.value;\r\n\r\n  if (legacyToken) {\r\n    console.warn(\r\n      '[Cookie Migration] Found refresh token in legacy cookie. ' +\r\n      `Please migrate to '${COOKIE_NAMES.REFRESH_TOKEN}' for improved security.`\r\n    );\r\n  }\r\n\r\n  return legacyToken || null;\r\n}\r\n"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;CAoBC;;;;;;;;;;;;;;;;;;;;AAgBM,MAAM,eAAe;IAC1B,wCAAwC,GACxC,cAAc,sCAAwC,0BAAsB;IAE5E,kDAAkD,GAClD,eAAe,sCAAwC,0BAAwB;IAE/E,mEAAmE,GACnE,YAAY,sCAAwC,0BAAwB;AAC9E;AAKO,MAAM,iBAAiB;IAC5B,oDAAoD,GACpD,cAAc,KAAK;IAEnB,oDAAoD,GACpD,eAAe,IAAI,KAAK,KAAK;IAE7B,qEAAqE,GACrE,SAAS,KAAK,KAAK;AACrB;AAEA;;;CAGC,GACD,MAAM,sBAA+C;IACnD,+BAA+B,GAC/B,MAAM;IAEN,+CAA+C,GAC/C,UAAU;IAEV,oEAAoE,GACpE,UAAU;IAEV,uCAAuC,GACvC,QAAQ,oDAAyB;AACnC;AAiBO,SAAS,4BACd,SAAmC;IAEnC,OAAO;QACL,GAAG,mBAAmB;QACtB,QAAQ,eAAe,YAAY;QACnC,GAAG,SAAS;IACd;AACF;AAaO,SAAS,6BACd,SAAmC;IAEnC,OAAO;QACL,GAAG,mBAAmB;QACtB,QAAQ,eAAe,aAAa;QACpC,GAAG,SAAS;IACd;AACF;AAaO,SAAS,wBACd,SAAmC;IAEnC,OAAO;QACL,GAAG,mBAAmB;QACtB,QAAQ,eAAe,OAAO;QAC9B,GAAG,SAAS;IACd;AACF;AAQO,MAAM,sBAAsB;IACjC,YAAY;IACZ,eAAe;IACf,WAAW;IACX,cAAc;AAChB;AAmBO,eAAe,iBACpB,WAAuE;IAEvE,wBAAwB;IACxB,YAAY,MAAM,CAAC,aAAa,YAAY;IAC5C,YAAY,MAAM,CAAC,aAAa,aAAa;IAC7C,YAAY,MAAM,CAAC,aAAa,UAAU;IAE1C,qCAAqC;IACrC,OAAO,MAAM,CAAC,qBAAqB,OAAO,CAAC,CAAC;QAC1C,YAAY,MAAM,CAAC;IACrB;AACF;AAiBO,SAAS,0BACd,WAAuE;IAEvE,mCAAmC;IACnC,IAAI,QAAQ,YAAY,GAAG,CAAC,aAAa,YAAY,GAAG;IAExD,IAAI,OAAO;QACT,OAAO;IACT;IAEA,0CAA0C;IAC1C,KAAK,MAAM,cAAc,OAAO,MAAM,CAAC,qBAAsB;QAC3D,QAAQ,YAAY,GAAG,CAAC,aAAa;QACrC,IAAI,OAAO;YACT,QAAQ,IAAI,CACV,CAAC,iDAAiD,EAAE,WAAW,GAAG,CAAC,GACnE,CAAC,mBAAmB,EAAE,aAAa,YAAY,CAAC,wBAAwB,CAAC;YAE3E,OAAO;QACT;IACF;IAEA,OAAO;AACT;AAQO,SAAS,2BACd,WAAuE;IAEvE,mCAAmC;IACnC,MAAM,QAAQ,YAAY,GAAG,CAAC,aAAa,aAAa,GAAG;IAE3D,IAAI,OAAO;QACT,OAAO;IACT;IAEA,oCAAoC;IACpC,MAAM,cAAc,YAAY,GAAG,CAAC,oBAAoB,aAAa,GAAG,SACpD,YAAY,GAAG,CAAC,oBAAoB,YAAY,GAAG;IAEvE,IAAI,aAAa;QACf,QAAQ,IAAI,CACV,8DACA,CAAC,mBAAmB,EAAE,aAAa,aAAa,CAAC,wBAAwB,CAAC;IAE9E;IAEA,OAAO,eAAe;AACxB","debugId":null}},
    {"offset": {"line": 169, "column": 0}, "map": {"version":3,"sources":["file:///F:/temp/white-cross/frontend/src/identity-access/lib/utils/token-utils.ts"],"sourcesContent":["/**\r\n * Centralized Token Utilities\r\n *\r\n * Single source of truth for token extraction, validation, and cookie management.\r\n * Consolidates all token-related operations across the application.\r\n *\r\n * @module lib/utils/token-utils\r\n * @since 2025-11-04\r\n */\r\n\r\nimport { cookies, headers } from 'next/headers';\r\nimport type { NextRequest } from 'next/server';\r\nimport { COOKIE_NAMES } from '../config/cookies';\r\n\r\n/**\r\n * Token cookie configuration\r\n * Centralized cookie names and settings\r\n */\r\nexport const TOKEN_CONFIG = {\r\n  // Cookie names - use centralized COOKIE_NAMES\r\n  ACCESS_TOKEN: COOKIE_NAMES.ACCESS_TOKEN,\r\n  REFRESH_TOKEN: COOKIE_NAMES.REFRESH_TOKEN,\r\n\r\n  // Alternative cookie names to check (for backwards compatibility)\r\n  ALT_ACCESS_NAMES: ['auth_token', 'access_token', 'token', 'jwt', 'authToken'],\r\n  ALT_REFRESH_NAMES: ['refresh_token', 'refreshToken'],\r\n\r\n  // Cookie options\r\n  OPTIONS: {\r\n    httpOnly: true,\r\n    secure: process.env.NODE_ENV === 'production',\r\n    sameSite: 'lax' as const,\r\n    path: '/',\r\n    maxAge: {\r\n      access: 24 * 60 * 60, // 24 hours\r\n      refresh: 7 * 24 * 60 * 60, // 7 days\r\n    },\r\n  },\r\n} as const;\r\n\r\n/**\r\n * Token payload interface\r\n */\r\nexport interface TokenPayload {\r\n  id?: string;\r\n  userId?: string;\r\n  email: string;\r\n  role: string;\r\n  exp: number;\r\n  iat: number;\r\n  firstName?: string;\r\n  lastName?: string;\r\n}\r\n\r\n/**\r\n * Extract token from Next.js request\r\n * Works in middleware, API routes, and server components\r\n *\r\n * @param request - Next.js request object\r\n * @returns Token string or null\r\n *\r\n * @example\r\n * ```typescript\r\n * // In middleware\r\n * export function middleware(request: NextRequest) {\r\n *   const token = extractTokenFromRequest(request);\r\n *   if (!token) return redirectToLogin();\r\n * }\r\n * ```\r\n */\r\nexport function extractTokenFromRequest(request: NextRequest): string | null {\r\n  // Try primary cookie name first\r\n  let token = request.cookies.get(TOKEN_CONFIG.ACCESS_TOKEN)?.value;\r\n\r\n  if (token) {\r\n    return token;\r\n  }\r\n\r\n  // Try alternative cookie names for backwards compatibility\r\n  for (const altName of TOKEN_CONFIG.ALT_ACCESS_NAMES) {\r\n    token = request.cookies.get(altName)?.value;\r\n    if (token) {\r\n      return token;\r\n    }\r\n  }\r\n\r\n  // Try Authorization header\r\n  const authHeader = request.headers.get('authorization');\r\n  if (authHeader) {\r\n    // Support both \"Bearer <token>\" and \"<token>\" formats\r\n    return authHeader.startsWith('Bearer ')\r\n      ? authHeader.substring(7)\r\n      : authHeader;\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\n/**\r\n * Extract token from server context (Server Components, Server Actions)\r\n * Uses Next.js cookies() and headers() helpers\r\n *\r\n * @returns Token string or null\r\n *\r\n * @example\r\n * ```typescript\r\n * // In server component\r\n * export default async function Page() {\r\n *   const token = await extractTokenFromServer();\r\n *   if (!token) redirect('/login');\r\n * }\r\n * ```\r\n */\r\nexport async function extractTokenFromServer(): Promise<string | null> {\r\n  try {\r\n    const cookieStore = await cookies();\r\n\r\n    // Try primary cookie name first\r\n    let token = cookieStore.get(TOKEN_CONFIG.ACCESS_TOKEN)?.value;\r\n\r\n    if (token) {\r\n      return token;\r\n    }\r\n\r\n    // Try alternative cookie names\r\n    for (const altName of TOKEN_CONFIG.ALT_ACCESS_NAMES) {\r\n      token = cookieStore.get(altName)?.value;\r\n      if (token) {\r\n        return token;\r\n      }\r\n    }\r\n\r\n    // Try Authorization header (for API clients)\r\n    try {\r\n      const headersList = await headers();\r\n      const authHeader = headersList.get('authorization');\r\n\r\n      if (authHeader) {\r\n        return authHeader.startsWith('Bearer ')\r\n          ? authHeader.substring(7)\r\n          : authHeader;\r\n      }\r\n    } catch {\r\n      // headers() might throw in some contexts (e.g., static pages)\r\n      // This is expected, continue with null token\r\n    }\r\n\r\n    return null;\r\n  } catch (error) {\r\n    console.error('[TokenUtils] Token extraction failed:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\n/**\r\n * Get refresh token from server context\r\n *\r\n * @returns Refresh token string or null\r\n */\r\nexport async function getRefreshTokenFromServer(): Promise<string | null> {\r\n  try {\r\n    const cookieStore = await cookies();\r\n\r\n    // Try primary refresh token name\r\n    let token = cookieStore.get(TOKEN_CONFIG.REFRESH_TOKEN)?.value;\r\n\r\n    if (token) {\r\n      return token;\r\n    }\r\n\r\n    // Try alternative names\r\n    for (const altName of TOKEN_CONFIG.ALT_REFRESH_NAMES) {\r\n      token = cookieStore.get(altName)?.value;\r\n      if (token) {\r\n        return token;\r\n      }\r\n    }\r\n\r\n    return null;\r\n  } catch (error) {\r\n    console.error('[TokenUtils] Refresh token extraction failed:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\n/**\r\n * Decode JWT token (without verification)\r\n * NOTE: This only decodes the payload, does NOT verify signature\r\n * Signature verification must be done server-side with proper secret\r\n *\r\n * @param token - JWT token string\r\n * @returns Decoded payload or null\r\n */\r\nexport function decodeToken(token: string): TokenPayload | null {\r\n  try {\r\n    const base64Url = token.split('.')[1];\r\n    if (!base64Url) return null;\r\n\r\n    const base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/');\r\n    const jsonPayload = decodeURIComponent(\r\n      atob(base64)\r\n        .split('')\r\n        .map((c) => '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2))\r\n        .join('')\r\n    );\r\n\r\n    return JSON.parse(jsonPayload) as TokenPayload;\r\n  } catch (error) {\r\n    console.error('[TokenUtils] Token decode error:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\n/**\r\n * Check if token is expired\r\n *\r\n * @param payload - Decoded token payload\r\n * @param clockSkewSeconds - Allow for clock skew (default: 30 seconds)\r\n * @returns true if token is expired\r\n */\r\nexport function isTokenExpired(payload: TokenPayload, clockSkewSeconds: number = 30): boolean {\r\n  if (!payload.exp) {\r\n    return true;\r\n  }\r\n\r\n  const now = Math.floor(Date.now() / 1000);\r\n  return payload.exp < (now - clockSkewSeconds);\r\n}\r\n\r\n/**\r\n * Check if token is expiring soon\r\n *\r\n * @param payload - Decoded token payload\r\n * @param warningThresholdSeconds - Threshold in seconds (default: 5 minutes)\r\n * @returns true if token expires within threshold\r\n */\r\nexport function isTokenExpiringSoon(payload: TokenPayload, warningThresholdSeconds: number = 300): boolean {\r\n  if (!payload.exp) {\r\n    return true;\r\n  }\r\n\r\n  const now = Math.floor(Date.now() / 1000);\r\n  return payload.exp < (now + warningThresholdSeconds);\r\n}\r\n\r\n/**\r\n * Get time remaining until token expiration\r\n *\r\n * @param payload - Decoded token payload\r\n * @returns Seconds until expiration, or 0 if already expired\r\n */\r\nexport function getTimeRemaining(payload: TokenPayload): number {\r\n  if (!payload.exp) {\r\n    return 0;\r\n  }\r\n\r\n  const now = Math.floor(Date.now() / 1000);\r\n  return Math.max(0, payload.exp - now);\r\n}\r\n\r\n/**\r\n * Set access token cookie\r\n * Server-side only\r\n *\r\n * @param token - Access token to set\r\n * @param maxAge - Optional max age in seconds\r\n */\r\nexport async function setAccessToken(token: string, maxAge?: number): Promise<void> {\r\n  const cookieStore = await cookies();\r\n\r\n  cookieStore.set(TOKEN_CONFIG.ACCESS_TOKEN, token, {\r\n    ...TOKEN_CONFIG.OPTIONS,\r\n    maxAge: maxAge || TOKEN_CONFIG.OPTIONS.maxAge.access,\r\n  });\r\n}\r\n\r\n/**\r\n * Set refresh token cookie\r\n * Server-side only\r\n *\r\n * @param token - Refresh token to set\r\n * @param maxAge - Optional max age in seconds\r\n */\r\nexport async function setRefreshToken(token: string, maxAge?: number): Promise<void> {\r\n  const cookieStore = await cookies();\r\n\r\n  cookieStore.set(TOKEN_CONFIG.REFRESH_TOKEN, token, {\r\n    ...TOKEN_CONFIG.OPTIONS,\r\n    maxAge: maxAge || TOKEN_CONFIG.OPTIONS.maxAge.refresh,\r\n  });\r\n}\r\n\r\n/**\r\n * Set both access and refresh tokens\r\n * Server-side only\r\n *\r\n * @param accessToken - Access token\r\n * @param refreshToken - Refresh token\r\n */\r\nexport async function setTokens(accessToken: string, refreshToken: string): Promise<void> {\r\n  await Promise.all([\r\n    setAccessToken(accessToken),\r\n    setRefreshToken(refreshToken),\r\n  ]);\r\n}\r\n\r\n/**\r\n * Clear access token cookie\r\n * Server-side only\r\n */\r\nexport async function clearAccessToken(): Promise<void> {\r\n  const cookieStore = await cookies();\r\n  cookieStore.delete(TOKEN_CONFIG.ACCESS_TOKEN);\r\n}\r\n\r\n/**\r\n * Clear refresh token cookie\r\n * Server-side only\r\n */\r\nexport async function clearRefreshToken(): Promise<void> {\r\n  const cookieStore = await cookies();\r\n  cookieStore.delete(TOKEN_CONFIG.REFRESH_TOKEN);\r\n}\r\n\r\n/**\r\n * Clear all token cookies\r\n * Server-side only\r\n */\r\nexport async function clearAllTokens(): Promise<void> {\r\n  const cookieStore = await cookies();\r\n\r\n  // Clear primary tokens\r\n  cookieStore.delete(TOKEN_CONFIG.ACCESS_TOKEN);\r\n  cookieStore.delete(TOKEN_CONFIG.REFRESH_TOKEN);\r\n\r\n  // Clear alternative token names for thorough cleanup\r\n  for (const altName of TOKEN_CONFIG.ALT_ACCESS_NAMES) {\r\n    try {\r\n      cookieStore.delete(altName);\r\n    } catch {\r\n      // Ignore errors for non-existent cookies\r\n    }\r\n  }\r\n\r\n  for (const altName of TOKEN_CONFIG.ALT_REFRESH_NAMES) {\r\n    try {\r\n      cookieStore.delete(altName);\r\n    } catch {\r\n      // Ignore errors for non-existent cookies\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Check if token exists (without validation)\r\n * Quick check for token presence\r\n *\r\n * @returns true if access token cookie exists\r\n */\r\nexport async function hasToken(): Promise<boolean> {\r\n  try {\r\n    const token = await extractTokenFromServer();\r\n    return token !== null;\r\n  } catch {\r\n    return false;\r\n  }\r\n}\r\n\r\n/**\r\n * Validate token structure (basic check)\r\n * Does NOT verify signature - only checks format\r\n *\r\n * @param token - Token string to validate\r\n * @returns true if token has valid JWT structure\r\n */\r\nexport function isValidTokenStructure(token: string): boolean {\r\n  if (!token || typeof token !== 'string') {\r\n    return false;\r\n  }\r\n\r\n  const parts = token.split('.');\r\n\r\n  // JWT should have 3 parts: header.payload.signature\r\n  if (parts.length !== 3) {\r\n    return false;\r\n  }\r\n\r\n  // Check if parts are base64 encoded\r\n  try {\r\n    atob(parts[0].replace(/-/g, '+').replace(/_/g, '/'));\r\n    atob(parts[1].replace(/-/g, '+').replace(/_/g, '/'));\r\n    return true;\r\n  } catch {\r\n    return false;\r\n  }\r\n}\r\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 453, "column": 0}, "map": {"version":3,"sources":["file:///F:/temp/white-cross/frontend/src/identity-access/lib/config/roles.ts"],"sourcesContent":["/**\r\n * Centralized Role Configuration\r\n *\r\n * Single source of truth for role hierarchy and role-related types.\r\n * Used across the application for consistent role handling.\r\n *\r\n * @module lib/config/roles\r\n * @since 2025-11-04\r\n */\r\n\r\n/**\r\n * System roles enum\r\n * Represents all user roles in the system\r\n */\r\nexport enum UserRole {\r\n  SUPER_ADMIN = 'SUPER_ADMIN',\r\n  ADMIN = 'ADMIN',\r\n  DISTRICT_ADMIN = 'DISTRICT_ADMIN',\r\n  SCHOOL_ADMIN = 'SCHOOL_ADMIN',\r\n  SCHOOL_NURSE = 'SCHOOL_NURSE',\r\n  NURSE = 'NURSE',\r\n  OFFICE_STAFF = 'OFFICE_STAFF',\r\n  STAFF = 'STAFF',\r\n  COUNSELOR = 'COUNSELOR',\r\n  VIEWER = 'VIEWER',\r\n  PARENT = 'PARENT',\r\n  STUDENT = 'STUDENT',\r\n}\r\n\r\n/**\r\n * Role hierarchy for permission inheritance and comparison\r\n * Higher values indicate higher privilege levels\r\n *\r\n * Used for:\r\n * - Permission inheritance (higher roles inherit lower role permissions)\r\n * - Role comparison (checking if user has minimum required role)\r\n * - Authorization checks across the application\r\n */\r\nexport const ROLE_HIERARCHY: Record<UserRole, number> = {\r\n  [UserRole.SUPER_ADMIN]: 100,\r\n  [UserRole.ADMIN]: 90,\r\n  [UserRole.DISTRICT_ADMIN]: 80,\r\n  [UserRole.SCHOOL_ADMIN]: 70,\r\n  [UserRole.SCHOOL_NURSE]: 65,\r\n  [UserRole.NURSE]: 60,\r\n  [UserRole.COUNSELOR]: 50,\r\n  [UserRole.OFFICE_STAFF]: 45,\r\n  [UserRole.STAFF]: 40,\r\n  [UserRole.VIEWER]: 30,\r\n  [UserRole.PARENT]: 20,\r\n  [UserRole.STUDENT]: 10,\r\n};\r\n\r\n/**\r\n * Check if a user role has minimum required role level\r\n *\r\n * @param userRole - The user's current role\r\n * @param minimumRole - The minimum required role\r\n * @returns true if user role meets or exceeds minimum role\r\n *\r\n * @example\r\n * ```typescript\r\n * hasMinimumRole(UserRole.NURSE, UserRole.STAFF) // true (NURSE > STAFF)\r\n * hasMinimumRole(UserRole.VIEWER, UserRole.NURSE) // false (VIEWER < NURSE)\r\n * ```\r\n */\r\nexport function hasMinimumRole(userRole: UserRole | string, minimumRole: UserRole | string): boolean {\r\n  const userLevel = ROLE_HIERARCHY[userRole as UserRole] || 0;\r\n  const requiredLevel = ROLE_HIERARCHY[minimumRole as UserRole] || 0;\r\n\r\n  return userLevel >= requiredLevel;\r\n}\r\n\r\n/**\r\n * Compare two roles\r\n *\r\n * @param role1 - First role\r\n * @param role2 - Second role\r\n * @returns Negative if role1 < role2, 0 if equal, positive if role1 > role2\r\n */\r\nexport function compareRoles(role1: UserRole | string, role2: UserRole | string): number {\r\n  const level1 = ROLE_HIERARCHY[role1 as UserRole] || 0;\r\n  const level2 = ROLE_HIERARCHY[role2 as UserRole] || 0;\r\n\r\n  return level1 - level2;\r\n}\r\n\r\n/**\r\n * Get role level\r\n *\r\n * @param role - Role to get level for\r\n * @returns Numeric level of the role (higher = more privileged)\r\n */\r\nexport function getRoleLevel(role: UserRole | string): number {\r\n  return ROLE_HIERARCHY[role as UserRole] || 0;\r\n}\r\n\r\n/**\r\n * Check if role exists in system\r\n *\r\n * @param role - Role to check\r\n * @returns true if role is valid\r\n */\r\nexport function isValidRole(role: string): role is UserRole {\r\n  return Object.values(UserRole).includes(role as UserRole);\r\n}\r\n\r\n/**\r\n * Get all roles at or above a certain level\r\n *\r\n * @param minimumRole - Minimum role level\r\n * @returns Array of roles that meet the minimum level\r\n */\r\nexport function getRolesAbove(minimumRole: UserRole | string): UserRole[] {\r\n  const minLevel = ROLE_HIERARCHY[minimumRole as UserRole] || 0;\r\n\r\n  return Object.entries(ROLE_HIERARCHY)\r\n    .filter(([_, level]) => level >= minLevel)\r\n    .map(([role]) => role as UserRole);\r\n}\r\n\r\n/**\r\n * Get all roles below a certain level\r\n *\r\n * @param maximumRole - Maximum role level\r\n * @returns Array of roles below the maximum level\r\n */\r\nexport function getRolesBelow(maximumRole: UserRole | string): UserRole[] {\r\n  const maxLevel = ROLE_HIERARCHY[maximumRole as UserRole] || 0;\r\n\r\n  return Object.entries(ROLE_HIERARCHY)\r\n    .filter(([_, level]) => level < maxLevel)\r\n    .map(([role]) => role as UserRole);\r\n}\r\n\r\n/**\r\n * Role type for string literals\r\n */\r\nexport type Role = keyof typeof ROLE_HIERARCHY;\r\n\r\n/**\r\n * Get human-readable role name\r\n *\r\n * @param role - Role to format\r\n * @returns Formatted role name\r\n */\r\nexport function formatRoleName(role: UserRole | string): string {\r\n  const roleMap: Record<string, string> = {\r\n    [UserRole.SUPER_ADMIN]: 'Super Administrator',\r\n    [UserRole.ADMIN]: 'Administrator',\r\n    [UserRole.DISTRICT_ADMIN]: 'District Administrator',\r\n    [UserRole.SCHOOL_ADMIN]: 'School Administrator',\r\n    [UserRole.SCHOOL_NURSE]: 'School Nurse',\r\n    [UserRole.NURSE]: 'Nurse',\r\n    [UserRole.OFFICE_STAFF]: 'Office Staff',\r\n    [UserRole.STAFF]: 'Staff',\r\n    [UserRole.COUNSELOR]: 'Counselor',\r\n    [UserRole.VIEWER]: 'Viewer',\r\n    [UserRole.PARENT]: 'Parent',\r\n    [UserRole.STUDENT]: 'Student',\r\n  };\r\n\r\n  return roleMap[role] || role;\r\n}\r\n"],"names":[],"mappings":"AAAA;;;;;;;;CAQC,GAED;;;CAGC;;;;;;;;;;;;;;;;;;;;AACM,IAAA,AAAK,kCAAA;;;;;;;;;;;;;WAAA;;AAwBL,MAAM,iBAA2C;IACtD,eAAsB,EAAE;IACxB,SAAgB,EAAE;IAClB,kBAAyB,EAAE;IAC3B,gBAAuB,EAAE;IACzB,gBAAuB,EAAE;IACzB,SAAgB,EAAE;IAClB,aAAoB,EAAE;IACtB,gBAAuB,EAAE;IACzB,SAAgB,EAAE;IAClB,UAAiB,EAAE;IACnB,UAAiB,EAAE;IACnB,WAAkB,EAAE;AACtB;AAeO,SAAS,eAAe,QAA2B,EAAE,WAA8B;IACxF,MAAM,YAAY,cAAc,CAAC,SAAqB,IAAI;IAC1D,MAAM,gBAAgB,cAAc,CAAC,YAAwB,IAAI;IAEjE,OAAO,aAAa;AACtB;AASO,SAAS,aAAa,KAAwB,EAAE,KAAwB;IAC7E,MAAM,SAAS,cAAc,CAAC,MAAkB,IAAI;IACpD,MAAM,SAAS,cAAc,CAAC,MAAkB,IAAI;IAEpD,OAAO,SAAS;AAClB;AAQO,SAAS,aAAa,IAAuB;IAClD,OAAO,cAAc,CAAC,KAAiB,IAAI;AAC7C;AAQO,SAAS,YAAY,IAAY;IACtC,OAAO,OAAO,MAAM,CAAC,UAAU,QAAQ,CAAC;AAC1C;AAQO,SAAS,cAAc,WAA8B;IAC1D,MAAM,WAAW,cAAc,CAAC,YAAwB,IAAI;IAE5D,OAAO,OAAO,OAAO,CAAC,gBACnB,MAAM,CAAC,CAAC,CAAC,GAAG,MAAM,GAAK,SAAS,UAChC,GAAG,CAAC,CAAC,CAAC,KAAK,GAAK;AACrB;AAQO,SAAS,cAAc,WAA8B;IAC1D,MAAM,WAAW,cAAc,CAAC,YAAwB,IAAI;IAE5D,OAAO,OAAO,OAAO,CAAC,gBACnB,MAAM,CAAC,CAAC,CAAC,GAAG,MAAM,GAAK,QAAQ,UAC/B,GAAG,CAAC,CAAC,CAAC,KAAK,GAAK;AACrB;AAaO,SAAS,eAAe,IAAuB;IACpD,MAAM,UAAkC;QACtC,eAAsB,EAAE;QACxB,SAAgB,EAAE;QAClB,kBAAyB,EAAE;QAC3B,gBAAuB,EAAE;QACzB,gBAAuB,EAAE;QACzB,SAAgB,EAAE;QAClB,gBAAuB,EAAE;QACzB,SAAgB,EAAE;QAClB,aAAoB,EAAE;QACtB,UAAiB,EAAE;QACnB,UAAiB,EAAE;QACnB,WAAkB,EAAE;IACtB;IAEA,OAAO,OAAO,CAAC,KAAK,IAAI;AAC1B","debugId":null}},
    {"offset": {"line": 558, "column": 0}, "map": {"version":3,"sources":["file:///F:/temp/white-cross/frontend/src/lib/auth.ts"],"sourcesContent":["/**\r\n * Authentication Utilities for Next.js API Routes\r\n *\r\n * Provides comprehensive JWT validation, token verification, and user authentication\r\n * for Next.js API routes and server components. Includes role-based access control\r\n * and security validation at module load time.\r\n *\r\n * **Security Features**:\r\n * - JWT token validation with issuer/audience verification\r\n * - Separate access and refresh token handling\r\n * - Role-based permission checking\r\n * - Module-level secret validation (fails fast on missing secrets)\r\n *\r\n * @module lib/auth\r\n */\r\n\r\nimport { NextRequest } from 'next/server';\r\nimport jwt from 'jsonwebtoken';\r\n\r\n// CRITICAL: Validate JWT secrets at module load time\r\n// This prevents the application from starting with missing or empty secrets\r\nif (!process.env.JWT_SECRET) {\r\n  throw new Error(\r\n    'FATAL: JWT_SECRET environment variable is not set. ' +\r\n    'This is a critical security requirement. The application cannot start without it. ' +\r\n    'Please configure JWT_SECRET in your environment variables.'\r\n  );\r\n}\r\n\r\nif (!process.env.JWT_REFRESH_SECRET) {\r\n  console.warn(\r\n    'WARNING: JWT_REFRESH_SECRET not set, falling back to JWT_SECRET. ' +\r\n    'For production environments, use separate secrets for access and refresh tokens.'\r\n  );\r\n}\r\n\r\nconst JWT_SECRET = process.env.JWT_SECRET;\r\nconst JWT_REFRESH_SECRET = process.env.JWT_REFRESH_SECRET || process.env.JWT_SECRET;\r\n\r\n/**\r\n * JWT token payload structure.\r\n *\r\n * Represents the decoded JWT token contents including user identity,\r\n * role, and token metadata.\r\n *\r\n * @property {string} id - User unique identifier\r\n * @property {string} email - User email address\r\n * @property {string} role - User role (e.g., 'admin', 'nurse', 'parent')\r\n * @property {'access' | 'refresh'} [type] - Token type designation\r\n * @property {number} [iat] - Issued at timestamp (Unix epoch)\r\n * @property {number} [exp] - Expiration timestamp (Unix epoch)\r\n * @property {string} [jti] - JWT ID for token tracking/revocation\r\n */\r\nexport interface TokenPayload {\r\n  id: string;\r\n  email: string;\r\n  role: string;\r\n  type?: 'access' | 'refresh';\r\n  iat?: number;\r\n  exp?: number;\r\n  jti?: string;\r\n}\r\n\r\n/**\r\n * Authenticated user representation.\r\n *\r\n * Represents a successfully authenticated user with their identity and role information.\r\n * Used throughout the application for access control and personalization.\r\n *\r\n * @property {string} id - User unique identifier\r\n * @property {string} email - User email address\r\n * @property {string} role - User role for permission checking\r\n * @property {Object} [user] - Nested user object for backward compatibility\r\n * @property {string} user.id - User unique identifier (nested)\r\n * @property {string} user.email - User email address (nested)\r\n * @property {string} user.role - User role (nested)\r\n */\r\nexport interface AuthenticatedUser {\r\n  id: string;\r\n  email: string;\r\n  role: string;\r\n  user?: {\r\n    id: string;\r\n    email: string;\r\n    role: string;\r\n  };\r\n}\r\n\r\n/**\r\n * Extracts JWT token from request Authorization header.\r\n *\r\n * Supports both \"Bearer <token>\" and \"<token>\" header formats.\r\n * Returns null if no Authorization header is present.\r\n *\r\n * @param {NextRequest} request - Next.js request object\r\n * @returns {string | null} Extracted token or null if not found\r\n *\r\n * @example\r\n * ```typescript\r\n * // With Bearer prefix\r\n * // Header: \"Authorization: Bearer abc123xyz\"\r\n * const token = extractToken(request); // 'abc123xyz'\r\n *\r\n * // Without Bearer prefix\r\n * // Header: \"Authorization: abc123xyz\"\r\n * const token = extractToken(request); // 'abc123xyz'\r\n *\r\n * // No Authorization header\r\n * const token = extractToken(request); // null\r\n * ```\r\n */\r\nexport function extractToken(request: NextRequest): string | null {\r\n  const authHeader = request.headers.get('authorization');\r\n\r\n  if (!authHeader) {\r\n    return null;\r\n  }\r\n\r\n  // Support both \"Bearer <token>\" and \"<token>\" formats\r\n  if (authHeader.startsWith('Bearer ')) {\r\n    return authHeader.substring(7);\r\n  }\r\n\r\n  return authHeader;\r\n}\r\n\r\n/**\r\n * Verifies and decodes a JWT access token.\r\n *\r\n * Validates the token signature, expiration, issuer, and audience.\r\n * Also verifies the token type is 'access' if specified.\r\n *\r\n * @param {string} token - JWT access token to verify\r\n * @returns {TokenPayload} Decoded and verified token payload\r\n * @throws {Error} If token is invalid, expired, or wrong type\r\n *\r\n * @example\r\n * ```typescript\r\n * try {\r\n *   const payload = verifyAccessToken(token);\r\n *   console.log(`User: ${payload.email}, Role: ${payload.role}`);\r\n * } catch (error) {\r\n *   console.error('Invalid token:', error.message);\r\n *   // Redirect to login\r\n * }\r\n * ```\r\n *\r\n * @see {@link verifyRefreshToken} for refresh token verification\r\n */\r\nexport function verifyAccessToken(token: string): TokenPayload {\r\n  // Note: JWT_SECRET is validated at module load time, guaranteed to exist\r\n  try {\r\n    const decoded = jwt.verify(token, JWT_SECRET, {\r\n      issuer: 'white-cross-healthcare',\r\n      audience: 'white-cross-api'\r\n    }) as TokenPayload;\r\n\r\n    // Verify token type\r\n    if (decoded.type && decoded.type !== 'access') {\r\n      throw new Error('Invalid token type');\r\n    }\r\n\r\n    return decoded;\r\n  } catch (error) {\r\n    if (error instanceof jwt.JsonWebTokenError) {\r\n      throw new Error('Invalid token');\r\n    }\r\n    if (error instanceof jwt.TokenExpiredError) {\r\n      throw new Error('Token has expired');\r\n    }\r\n    throw error;\r\n  }\r\n}\r\n\r\n/**\r\n * Verifies and decodes a JWT refresh token.\r\n *\r\n * Validates the token signature, expiration, and issuer.\r\n * Also verifies the token type is 'refresh' if specified.\r\n * Refresh tokens typically have longer expiration times than access tokens.\r\n *\r\n * @param {string} token - JWT refresh token to verify\r\n * @returns {TokenPayload} Decoded and verified token payload\r\n * @throws {Error} If token is invalid, expired, or wrong type\r\n *\r\n * @example\r\n * ```typescript\r\n * try {\r\n *   const payload = verifyRefreshToken(refreshToken);\r\n *   // Generate new access token for user\r\n *   const newAccessToken = generateAccessToken(payload.id);\r\n * } catch (error) {\r\n *   console.error('Invalid refresh token:', error.message);\r\n *   // Require re-authentication\r\n * }\r\n * ```\r\n *\r\n * @see {@link verifyAccessToken} for access token verification\r\n */\r\nexport function verifyRefreshToken(token: string): TokenPayload {\r\n  // Note: JWT_REFRESH_SECRET is validated at module load time, guaranteed to exist\r\n  try {\r\n    const decoded = jwt.verify(token, JWT_REFRESH_SECRET, {\r\n      issuer: 'white-cross-healthcare'\r\n    }) as TokenPayload;\r\n\r\n    // Verify token type\r\n    if (decoded.type && decoded.type !== 'refresh') {\r\n      throw new Error('Invalid token type');\r\n    }\r\n\r\n    return decoded;\r\n  } catch (error) {\r\n    if (error instanceof jwt.JsonWebTokenError) {\r\n      throw new Error('Invalid refresh token');\r\n    }\r\n    if (error instanceof jwt.TokenExpiredError) {\r\n      throw new Error('Refresh token has expired');\r\n    }\r\n    throw error;\r\n  }\r\n}\r\n\r\n/**\r\n * Authenticates a request and extracts user information from JWT token.\r\n *\r\n * Performs complete authentication flow:\r\n * 1. Extracts token from Authorization header\r\n * 2. Verifies token signature and expiration\r\n * 3. Returns authenticated user object\r\n *\r\n * Returns null if no token present, token is invalid, or verification fails.\r\n * Errors are logged but not thrown to allow graceful handling.\r\n *\r\n * @param {NextRequest} [request] - Next.js request object (optional for server components)\r\n * @returns {AuthenticatedUser | null} Authenticated user or null if authentication fails\r\n *\r\n * @example\r\n * ```typescript\r\n * // In API route\r\n * export async function GET(request: NextRequest) {\r\n *   const user = authenticateRequest(request);\r\n *\r\n *   if (!user) {\r\n *     return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });\r\n *   }\r\n *\r\n *   // User is authenticated\r\n *   console.log(`Request from: ${user.email}`);\r\n * }\r\n * ```\r\n *\r\n * @see {@link extractToken} for token extraction\r\n * @see {@link verifyAccessToken} for token verification\r\n */\r\nexport function authenticateRequest(request?: NextRequest): AuthenticatedUser | null {\r\n  if (!request) {\r\n    // Server component context - create mock authenticated user\r\n    // In production, this should use next-auth or similar\r\n    return null;\r\n  }\r\n\r\n  try {\r\n    const token = extractToken(request);\r\n\r\n    if (!token) {\r\n      return null;\r\n    }\r\n\r\n    const payload = verifyAccessToken(token);\r\n\r\n    const user = {\r\n      id: payload.id,\r\n      email: payload.email,\r\n      role: payload.role\r\n    };\r\n\r\n    return {\r\n      ...user,\r\n      user // Also expose as nested .user for compatibility\r\n    };\r\n  } catch (error) {\r\n    console.error('Authentication failed:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\n/**\r\n * Checks if user has one of the required roles.\r\n *\r\n * Performs exact role matching (case-sensitive).\r\n * Accepts either a single role or array of roles.\r\n *\r\n * @param {AuthenticatedUser} user - Authenticated user to check\r\n * @param {string | string[]} requiredRole - Required role(s) - user must have one\r\n * @returns {boolean} True if user has one of the required roles\r\n *\r\n * @example\r\n * ```typescript\r\n * // Single role check\r\n * if (hasRole(user, 'admin')) {\r\n *   // User is admin\r\n * }\r\n *\r\n * // Multiple roles check (user needs to be one of these)\r\n * if (hasRole(user, ['admin', 'nurse', 'doctor'])) {\r\n *   // User is admin, nurse, or doctor\r\n * }\r\n * ```\r\n *\r\n * @see {@link hasMinimumRole} for hierarchical role checking\r\n */\r\nexport function hasRole(user: AuthenticatedUser, requiredRole: string | string[]): boolean {\r\n  const roles = Array.isArray(requiredRole) ? requiredRole : [requiredRole];\r\n  return roles.includes(user.role);\r\n}\r\n\r\n/**\r\n * Role hierarchy for permission checking\r\n * @deprecated Import from @/identity-access/lib/config/roles instead\r\n *\r\n * This is maintained for backward compatibility only.\r\n * New code should use the centralized role configuration.\r\n */\r\nimport { ROLE_HIERARCHY as CENTRALIZED_ROLE_HIERARCHY, hasMinimumRole as hasMinimumRoleLevel } from '@/identity-access/lib/config/roles';\r\n\r\nconst ROLE_HIERARCHY = CENTRALIZED_ROLE_HIERARCHY;\r\n\r\n/**\r\n * Checks if user has minimum role level based on role hierarchy.\r\n *\r\n * Uses hierarchical role comparison where higher-level roles\r\n * automatically satisfy requirements for lower-level roles.\r\n * For example, 'admin' satisfies 'nurse' requirements.\r\n *\r\n * @deprecated Use hasMinimumRoleLevel from @/identity-access/lib/config/roles instead.\r\n *             This function is maintained for backward compatibility only.\r\n *\r\n * @param {AuthenticatedUser} user - Authenticated user to check\r\n * @param {string} minimumRole - Minimum required role level\r\n * @returns {boolean} True if user's role meets or exceeds minimum role\r\n *\r\n * @example\r\n * ```typescript\r\n * // Admin checking nurse requirement\r\n * hasMinimumRole(adminUser, 'nurse') // true (admin > nurse in hierarchy)\r\n *\r\n * // Nurse checking admin requirement\r\n * hasMinimumRole(nurseUser, 'admin') // false (nurse < admin in hierarchy)\r\n * ```\r\n *\r\n * @see {@link hasRole} for exact role matching\r\n */\r\nexport function hasMinimumRole(user: AuthenticatedUser, minimumRole: string): boolean {\r\n  return hasMinimumRoleLevel(user.role, minimumRole);\r\n}\r\n\r\n/**\r\n * Auth function - alias for authenticateRequest.\r\n *\r\n * Provided for backward compatibility and convenience.\r\n * Identical to authenticateRequest in functionality.\r\n *\r\n * @function auth\r\n * @type {typeof authenticateRequest}\r\n *\r\n * @example\r\n * ```typescript\r\n * // Can use either name\r\n * const user1 = auth(request);\r\n * const user2 = authenticateRequest(request);\r\n * // Both do the same thing\r\n * ```\r\n *\r\n * @see {@link authenticateRequest} for full documentation\r\n */\r\nexport const auth = authenticateRequest;\r\n"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;CAcC;;;;;;;;;;;;;;;;AAGD;AA4SA;;;;;;CAMC,GACD;;AAjTA,qDAAqD;AACrD,4EAA4E;AAC5E,IAAI,CAAC,QAAQ,GAAG,CAAC,UAAU,EAAE;IAC3B,MAAM,IAAI,MACR,wDACA,uFACA;AAEJ;AAEA,IAAI,CAAC,QAAQ,GAAG,CAAC,kBAAkB,EAAE;IACnC,QAAQ,IAAI,CACV,sEACA;AAEJ;AAEA,MAAM,aAAa,QAAQ,GAAG,CAAC,UAAU;AACzC,MAAM,qBAAqB,QAAQ,GAAG,CAAC,kBAAkB,IAAI,QAAQ,GAAG,CAAC,UAAU;AA0E5E,SAAS,aAAa,OAAoB;IAC/C,MAAM,aAAa,QAAQ,OAAO,CAAC,GAAG,CAAC;IAEvC,IAAI,CAAC,YAAY;QACf,OAAO;IACT;IAEA,sDAAsD;IACtD,IAAI,WAAW,UAAU,CAAC,YAAY;QACpC,OAAO,WAAW,SAAS,CAAC;IAC9B;IAEA,OAAO;AACT;AAyBO,SAAS,kBAAkB,KAAa;IAC7C,yEAAyE;IACzE,IAAI;QACF,MAAM,UAAU,gJAAG,CAAC,MAAM,CAAC,OAAO,YAAY;YAC5C,QAAQ;YACR,UAAU;QACZ;QAEA,oBAAoB;QACpB,IAAI,QAAQ,IAAI,IAAI,QAAQ,IAAI,KAAK,UAAU;YAC7C,MAAM,IAAI,MAAM;QAClB;QAEA,OAAO;IACT,EAAE,OAAO,OAAO;QACd,IAAI,iBAAiB,gJAAG,CAAC,iBAAiB,EAAE;YAC1C,MAAM,IAAI,MAAM;QAClB;QACA,IAAI,iBAAiB,gJAAG,CAAC,iBAAiB,EAAE;YAC1C,MAAM,IAAI,MAAM;QAClB;QACA,MAAM;IACR;AACF;AA2BO,SAAS,mBAAmB,KAAa;IAC9C,iFAAiF;IACjF,IAAI;QACF,MAAM,UAAU,gJAAG,CAAC,MAAM,CAAC,OAAO,oBAAoB;YACpD,QAAQ;QACV;QAEA,oBAAoB;QACpB,IAAI,QAAQ,IAAI,IAAI,QAAQ,IAAI,KAAK,WAAW;YAC9C,MAAM,IAAI,MAAM;QAClB;QAEA,OAAO;IACT,EAAE,OAAO,OAAO;QACd,IAAI,iBAAiB,gJAAG,CAAC,iBAAiB,EAAE;YAC1C,MAAM,IAAI,MAAM;QAClB;QACA,IAAI,iBAAiB,gJAAG,CAAC,iBAAiB,EAAE;YAC1C,MAAM,IAAI,MAAM;QAClB;QACA,MAAM;IACR;AACF;AAkCO,SAAS,oBAAoB,OAAqB;IACvD,IAAI,CAAC,SAAS;QACZ,4DAA4D;QAC5D,sDAAsD;QACtD,OAAO;IACT;IAEA,IAAI;QACF,MAAM,QAAQ,aAAa;QAE3B,IAAI,CAAC,OAAO;YACV,OAAO;QACT;QAEA,MAAM,UAAU,kBAAkB;QAElC,MAAM,OAAO;YACX,IAAI,QAAQ,EAAE;YACd,OAAO,QAAQ,KAAK;YACpB,MAAM,QAAQ,IAAI;QACpB;QAEA,OAAO;YACL,GAAG,IAAI;YACP;QACF;IACF,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,0BAA0B;QACxC,OAAO;IACT;AACF;AA2BO,SAAS,QAAQ,IAAuB,EAAE,YAA+B;IAC9E,MAAM,QAAQ,MAAM,OAAO,CAAC,gBAAgB,eAAe;QAAC;KAAa;IACzE,OAAO,MAAM,QAAQ,CAAC,KAAK,IAAI;AACjC;;AAWA,MAAM,iBAAiB,qKAA0B;AA2B1C,SAAS,eAAe,IAAuB,EAAE,WAAmB;IACzE,OAAO,IAAA,qKAAmB,EAAC,KAAK,IAAI,EAAE;AACxC;AAqBO,MAAM,OAAO","debugId":null}},
    {"offset": {"line": 703, "column": 0}, "map": {"version":3,"sources":["file:///F:/temp/white-cross/frontend/middleware.ts"],"sourcesContent":["/**\r\n * Next.js Middleware - Authentication, Security & Rate Limiting\r\n *\r\n * CRITICAL SECURITY: This middleware enforces authentication and HIPAA compliance.\r\n * All PHI routes require valid authentication tokens and role-based access.\r\n *\r\n * @module middleware\r\n * @since 2025-11-05\r\n */\r\n\r\nimport { NextRequest, NextResponse } from 'next/server';\r\nimport { extractTokenFromRequest } from './src/identity-access/lib/utils/token-utils';\r\nimport { verifyAccessToken } from './src/lib/auth';\r\n\r\n// Stub for rate limiter - will be implemented later\r\nfunction getRateLimiter() {\r\n  return {\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    check: async (_identifier: string, _limit: number, _window: string) => ({\r\n      success: true,\r\n      retryAfter: null,\r\n    }),\r\n  };\r\n}\r\n\r\n/**\r\n * Public routes that don't require authentication\r\n */\r\nconst PUBLIC_ROUTES = [\r\n  '/login',\r\n  '/session-expired',\r\n  '/forgot-password',\r\n  '/reset-password',\r\n  '/_next',\r\n  '/favicon.ico',\r\n  '/api/health',\r\n];\r\n\r\n/**\r\n * PHI routes requiring enhanced security and audit logging\r\n */\r\nconst PHI_ROUTES = [\r\n  '/students',\r\n  '/health-records',\r\n  '/medications',\r\n  '/incidents',\r\n  '/communications',\r\n  '/api/v1/students',\r\n  '/api/v1/health-records',\r\n  '/api/v1/medications',\r\n];\r\n\r\n/**\r\n * Admin routes requiring ADMIN or SYSTEM_ADMIN role\r\n */\r\nconst ADMIN_ROUTES = [\r\n  '/admin',\r\n  '/api/v1/admin',\r\n];\r\n\r\n/**\r\n * Main middleware function\r\n */\r\nexport default async function middleware(request: NextRequest) {\r\n  const { pathname } = request.nextUrl;\r\n\r\n  // Allow public routes\r\n  if (PUBLIC_ROUTES.some(route => pathname.startsWith(route))) {\r\n    return NextResponse.next();\r\n  }\r\n\r\n  // Rate limiting for API routes\r\n  if (pathname.startsWith('/api/')) {\r\n    const rateLimitResult = await checkRateLimit(request);\r\n    if (!rateLimitResult.success) {\r\n      return new NextResponse('Too Many Requests', {\r\n        status: 429,\r\n        headers: {\r\n          'Retry-After': rateLimitResult.retryAfter || '60',\r\n        },\r\n      });\r\n    }\r\n  }\r\n\r\n  // Authentication check\r\n  const authResult = await authenticateRequest(request);\r\n\r\n  if (!authResult.authenticated) {\r\n    // Redirect to login with return URL\r\n    const loginUrl = new URL('/login', request.url);\r\n    loginUrl.searchParams.set('returnUrl', pathname);\r\n    return NextResponse.redirect(loginUrl);\r\n  }\r\n\r\n  // Redirect authenticated users from root to dashboard\r\n  if (pathname === '/') {\r\n    return NextResponse.redirect(new URL('/dashboard', request.url));\r\n  }\r\n\r\n  // Role-based access control for admin routes\r\n  if (ADMIN_ROUTES.some(route => pathname.startsWith(route))) {\r\n    if (!['ADMIN', 'SYSTEM_ADMIN'].includes(authResult.user?.role || '')) {\r\n      return new NextResponse('Forbidden', { status: 403 });\r\n    }\r\n  }\r\n\r\n  // PHI access audit logging\r\n  if (PHI_ROUTES.some(route => pathname.startsWith(route))) {\r\n    // Note: Actual audit logging should happen in Server Actions/API routes\r\n    // Here we just add headers for downstream processing\r\n    const response = NextResponse.next();\r\n    response.headers.set('X-PHI-Access', 'true');\r\n    response.headers.set('X-User-Id', authResult.user?.id || '');\r\n    response.headers.set('X-User-Role', authResult.user?.role || '');\r\n    return response;\r\n  }\r\n\r\n  // Add user context to request headers\r\n  const response = NextResponse.next();\r\n  if (authResult.user) {\r\n    response.headers.set('X-User-Id', authResult.user.id);\r\n    response.headers.set('X-User-Email', authResult.user.email);\r\n    response.headers.set('X-User-Role', authResult.user.role);\r\n  }\r\n\r\n  return response;\r\n}\r\n\r\n/**\r\n * Authenticate request using JWT token from cookies\r\n */\r\nasync function authenticateRequest(request: NextRequest) {\r\n  try {\r\n    const token = extractTokenFromRequest(request);\r\n\r\n    if (!token) {\r\n      return { authenticated: false };\r\n    }\r\n\r\n    // Verify JWT token (server-side only)\r\n    const payload = await verifyAccessToken(token);\r\n\r\n    return {\r\n      authenticated: true,\r\n      user: {\r\n        id: payload.id,\r\n        email: payload.email,\r\n        role: payload.role,\r\n      },\r\n    };\r\n  } catch (error) {\r\n    console.error('[Middleware] Authentication failed:', error);\r\n    return { authenticated: false };\r\n  }\r\n}\r\n\r\n/**\r\n * Rate limiting check\r\n */\r\nasync function checkRateLimit(request: NextRequest) {\r\n  const { pathname } = request.nextUrl;\r\n  const limiter = getRateLimiter();\r\n\r\n  // Different limits for different routes\r\n  const limits = {\r\n    '/api/v1/health-records': { limit: 100, window: '15m' },\r\n    '/api/v1/students': { limit: 100, window: '15m' },\r\n    '/api/v1/medications': { limit: 100, window: '15m' },\r\n    '/api/v1': { limit: 500, window: '15m' },\r\n    default: { limit: 1000, window: '15m' },\r\n  };\r\n\r\n  const identifier = request.headers.get('x-forwarded-for') || request.headers.get('x-real-ip') || 'unknown';\r\n\r\n  // Find matching limit\r\n  let limit = limits.default;\r\n  for (const [route, routeLimit] of Object.entries(limits)) {\r\n    if (route !== 'default' && pathname.startsWith(route)) {\r\n      limit = routeLimit;\r\n      break;\r\n    }\r\n  }\r\n\r\n  return await limiter.check(identifier, limit.limit, limit.window);\r\n}\r\n\r\n/**\r\n * Middleware configuration\r\n */\r\nexport const config = {\r\n  matcher: [\r\n    /*\r\n     * Match all request paths except:\r\n     * - _next/static (static files)\r\n     * - _next/image (image optimization)\r\n     * - favicon.ico (favicon file)\r\n     */\r\n    '/((?!_next/static|_next/image|favicon.ico).*)',\r\n  ],\r\n};\r\n\r\n/**\r\n * Force Node.js runtime for JWT verification\r\n * Edge runtime doesn't support Node.js crypto module\r\n */\r\nexport const runtime = 'nodejs';\r\n"],"names":[],"mappings":"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","debugId":null}}]
}