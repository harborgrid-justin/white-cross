/**
 * LOC: SR003AUTO
 * Stock Reorder Automation Service
 * 
 * Automated inventory management and purchase order generation
 * Predictive stock level analysis and vendor management
 * 
 * UPSTREAM (imports from):
 *   - database models
 *   - logger utility
 *   - inventory service
 *   - vendor service
 * 
 * DOWNSTREAM (imported by):
 *   - inventory routes
 *   - purchase order routes
 *   - scheduled jobs
 */

import { logger } from '../../utils/logger';
import { AuditService } from '../auditService';

/**
 * Reorder Priority Levels
 */
export enum ReorderPriority {
  CRITICAL = 'CRITICAL',   // Out of stock or emergency medication
  HIGH = 'HIGH',           // Below minimum threshold
  MEDIUM = 'MEDIUM',       // Approaching reorder point
  LOW = 'LOW'              // Routine restocking
}

/**
 * Purchase Order Status
 */
export enum PurchaseOrderStatus {
  PENDING = 'PENDING',           // Created, awaiting approval
  APPROVED = 'APPROVED',         // Approved, ready to send
  SUBMITTED = 'SUBMITTED',       // Sent to vendor
  PARTIALLY_RECEIVED = 'PARTIALLY_RECEIVED',
  RECEIVED = 'RECEIVED',         // Fully received
  CANCELLED = 'CANCELLED',       // Order cancelled
  REJECTED = 'REJECTED'          // Approval rejected
}

/**
 * Inventory Item for Reorder
 */
export interface InventoryItem {
  itemId: string;
  itemName: string;
  itemType: 'MEDICATION' | 'SUPPLY' | 'EQUIPMENT';
  category?: string;
  
  // Stock levels
  currentStock: number;
  unit: string;
  reorderPoint: number;        // When to reorder
  minimumStock: number;        // Safety stock level
  maximumStock: number;        // Maximum to stock
  optimalStock: number;        // Ideal quantity
  
  // Usage tracking
  averageMonthlyUsage: number;
  usageTrend: 'INCREASING' | 'STABLE' | 'DECREASING';
  daysUntilStockout?: number;
  
  // Vendor information
  preferredVendorId?: string;
  alternateVendors?: string[];
  unitCost?: number;
  
  // Flags
  isControlledSubstance: boolean;
  isRefrigerated: boolean;
  isPrescriptionRequired: boolean;
  isSeasonalItem: boolean;
  
  // Location
  location: string;
  schoolId?: string;
  
  // Metadata
  lastOrderDate?: Date;
  lastReceivedDate?: Date;
  expirationDate?: Date;
}

/**
 * Reorder Recommendation
 */
export interface ReorderRecommendation {
  itemId: string;
  itemName: string;
  priority: ReorderPriority;
  
  // Stock information
  currentStock: number;
  reorderPoint: number;
  minimumStock: number;
  recommendedOrderQuantity: number;
  unit: string;
  
  // Analysis
  reason: string;
  daysUntilStockout?: number;
  averageMonthlyUsage: number;
  leadTimeDays: number;
  
  // Vendor recommendation
  recommendedVendorId?: string;
  estimatedCost?: number;
  estimatedDeliveryDate?: Date;
  
  // Generated data
  generatedDate: Date;
  validUntil: Date;
  autoGenerated: boolean;
}

/**
 * Automated Purchase Order
 */
export interface AutomatedPurchaseOrder {
  id: string;
  orderNumber: string;
  orderDate: Date;
  
  // Vendor information
  vendorId: string;
  vendorName: string;
  vendorContact?: string;
  
  // Order details
  items: {
    itemId: string;
    itemName: string;
    quantity: number;
    unit: string;
    unitCost: number;
    totalCost: number;
    priority: ReorderPriority;
  }[];
  
  // Financial
  subtotal: number;
  taxRate: number;
  taxAmount: number;
  shippingCost: number;
  totalAmount: number;
  budgetCode?: string;
  
  // Status
  status: PurchaseOrderStatus;
  priority: ReorderPriority;
  
  // Approval
  requiresApproval: boolean;
  approvalThreshold: number;
  approvedBy?: string;
  approvalDate?: Date;
  rejectionReason?: string;
  
  // Delivery
  expectedDeliveryDate?: Date;
  actualDeliveryDate?: Date;
  deliveryAddress: string;
  
  // Documentation
  notes?: string;
  attachments?: string[];
  
  // Audit trail
  createdBy: string;
  createdAt: Date;
  updatedAt?: Date;
  schoolId?: string;
  
  // Flags
  autoGenerated: boolean;
  urgent: boolean;
}

/**
 * Usage Forecast
 */
export interface UsageForecast {
  itemId: string;
  forecastDate: Date;
  forecastPeriodMonths: number;
  estimatedUsage: number;
  confidenceLevel: number; // 0-100
  seasonalAdjustment: number;
}

/**
 * Stock Reorder Automation Service
 */
export class StockReorderAutomation {
  
  // In-memory storage (replace with database in production)
  private static inventory: Map<string, InventoryItem> = new Map();
  private static purchaseOrders: AutomatedPurchaseOrder[] = [];
  private static recommendations: ReorderRecommendation[] = [];
  
  // Configuration
  private static readonly DEFAULT_LEAD_TIME_DAYS = 7;
  private static readonly APPROVAL_THRESHOLD = 500; // Dollar amount requiring approval
  private static readonly RECOMMENDATION_VALID_DAYS = 7;
  
  /**
   * Analyze inventory and generate reorder recommendations
   */
  static async analyzeInventory(schoolId?: string): Promise<ReorderRecommendation[]> {
    try {
      const recommendations: ReorderRecommendation[] = [];
      const items = Array.from(this.inventory.values());
      
      for (const item of items) {
        // Skip if school filter doesn't match
        if (schoolId && item.schoolId !== schoolId) {
          continue;
        }
        
        // Check if reorder is needed
        const reorderNeeded = this.isReorderNeeded(item);
        
        if (reorderNeeded) {
          const recommendation = await this.generateRecommendation(item);
          recommendations.push(recommendation);
        }
      }
      
      // Sort by priority
      recommendations.sort((a, b) => {
        const priorityOrder = { CRITICAL: 0, HIGH: 1, MEDIUM: 2, LOW: 3 };
        return priorityOrder[a.priority] - priorityOrder[b.priority];
      });
      
      // Store recommendations
      this.recommendations = recommendations;
      
      logger.info('Inventory analysis completed', {
        totalItems: items.length,
        recommendations: recommendations.length,
        critical: recommendations.filter(r => r.priority === ReorderPriority.CRITICAL).length,
        high: recommendations.filter(r => r.priority === ReorderPriority.HIGH).length
      });
      
      return recommendations;
      
    } catch (error) {
      logger.error('Error analyzing inventory', { error });
      throw error;
    }
  }
  
  /**
   * Generate automated purchase orders from recommendations
   */
  static async generatePurchaseOrders(
    recommendations: ReorderRecommendation[],
    options: {
      createdBy: string;
      schoolId?: string;
      autoApproveUnderThreshold?: boolean;
    }
  ): Promise<AutomatedPurchaseOrder[]> {
    try {
      // Group recommendations by vendor
      const byVendor = new Map<string, ReorderRecommendation[]>();
      
      for (const rec of recommendations) {
        const vendorId = rec.recommendedVendorId || 'default-vendor';
        if (!byVendor.has(vendorId)) {
          byVendor.set(vendorId, []);
        }
        byVendor.get(vendorId)!.push(rec);
      }
      
      const orders: AutomatedPurchaseOrder[] = [];
      
      // Create one PO per vendor
      for (const [vendorId, items] of byVendor) {
        const order = await this.createPurchaseOrder(
          vendorId,
          items,
          options.createdBy,
          options.schoolId,
          options.autoApproveUnderThreshold
        );
        
        orders.push(order);
      }
      
      logger.info('Automated purchase orders generated', {
        recommendationCount: recommendations.length,
        orderCount: orders.length,
        totalValue: orders.reduce((sum, o) => sum + o.totalAmount, 0)
      });
      
      return orders;
      
    } catch (error) {
      logger.error('Error generating purchase orders', { error });
      throw error;
    }
  }
  
  /**
   * Create a single purchase order
   */
  private static async createPurchaseOrder(
    vendorId: string,
    recommendations: ReorderRecommendation[],
    createdBy: string,
    schoolId?: string,
    autoApprove?: boolean
  ): Promise<AutomatedPurchaseOrder> {
    
    // Calculate order details
    const items = recommendations.map(rec => ({
      itemId: rec.itemId,
      itemName: rec.itemName,
      quantity: rec.recommendedOrderQuantity,
      unit: rec.unit,
      unitCost: rec.estimatedCost || 0,
      totalCost: (rec.estimatedCost || 0) * rec.recommendedOrderQuantity,
      priority: rec.priority
    }));
    
    const subtotal = items.reduce((sum, item) => sum + item.totalCost, 0);
    const taxRate = 0.08; // 8% (would be configurable)
    const taxAmount = subtotal * taxRate;
    const shippingCost = this.calculateShipping(subtotal, vendorId);
    const totalAmount = subtotal + taxAmount + shippingCost;
    
    // Determine priority (highest priority item)
    const priority = items.reduce((highest, item) => {
      const priorityOrder = { CRITICAL: 0, HIGH: 1, MEDIUM: 2, LOW: 3 };
      return priorityOrder[item.priority] < priorityOrder[highest] ? item.priority : highest;
    }, ReorderPriority.LOW);
    
    // Auto-approve if under threshold
    const requiresApproval = totalAmount >= this.APPROVAL_THRESHOLD;
    const approved = autoApprove && !requiresApproval;
    
    const order: AutomatedPurchaseOrder = {
      id: this.generateOrderId(),
      orderNumber: this.generateOrderNumber(),
      orderDate: new Date(),
      vendorId,
      vendorName: `Vendor ${vendorId}`, // Would lookup from vendor database
      items,
      subtotal,
      taxRate,
      taxAmount,
      shippingCost,
      totalAmount,
      status: approved ? PurchaseOrderStatus.APPROVED : PurchaseOrderStatus.PENDING,
      priority,
      requiresApproval,
      approvalThreshold: this.APPROVAL_THRESHOLD,
      approvedBy: approved ? 'AUTO-APPROVED' : undefined,
      approvalDate: approved ? new Date() : undefined,
      expectedDeliveryDate: this.calculateExpectedDelivery(),
      deliveryAddress: 'School Nurse Office', // Would be configurable
      createdBy,
      createdAt: new Date(),
      schoolId,
      autoGenerated: true,
      urgent: priority === ReorderPriority.CRITICAL
    };
    
    this.purchaseOrders.push(order);
    
    // Audit log
    await AuditService.logAction({
      userId: createdBy,
      action: 'CREATE_AUTOMATED_PURCHASE_ORDER',
      resourceType: 'PurchaseOrder',
      resourceId: order.id,
      details: {
        orderNumber: order.orderNumber,
        vendorId,
        itemCount: items.length,
        totalAmount,
        autoApproved: approved
      }
    });
    
    logger.info('Purchase order created', {
      orderId: order.id,
      orderNumber: order.orderNumber,
      itemCount: items.length,
      totalAmount,
      requiresApproval,
      approved
    });
    
    return order;
  }
  
  /**
   * Approve a purchase order
   */
  static async approvePurchaseOrder(
    orderId: string,
    approvedBy: string,
    notes?: string
  ): Promise<AutomatedPurchaseOrder> {
    try {
      const order = this.purchaseOrders.find(o => o.id === orderId);
      
      if (!order) {
        throw new Error('Purchase order not found');
      }
      
      if (order.status !== PurchaseOrderStatus.PENDING) {
        throw new Error('Purchase order is not pending approval');
      }
      
      order.status = PurchaseOrderStatus.APPROVED;
      order.approvedBy = approvedBy;
      order.approvalDate = new Date();
      order.updatedAt = new Date();
      
      if (notes) {
        order.notes = order.notes ? `${order.notes}\n\nApproval: ${notes}` : notes;
      }
      
      logger.info('Purchase order approved', {
        orderId,
        orderNumber: order.orderNumber,
        approvedBy,
        totalAmount: order.totalAmount
      });
      
      return order;
      
    } catch (error) {
      logger.error('Error approving purchase order', { error, orderId });
      throw error;
    }
  }
  
  /**
   * Submit purchase order to vendor
   */
  static async submitToVendor(orderId: string, submittedBy: string): Promise<AutomatedPurchaseOrder> {
    try {
      const order = this.purchaseOrders.find(o => o.id === orderId);
      
      if (!order) {
        throw new Error('Purchase order not found');
      }
      
      if (order.status !== PurchaseOrderStatus.APPROVED) {
        throw new Error('Purchase order must be approved before submission');
      }
      
      order.status = PurchaseOrderStatus.SUBMITTED;
      order.updatedAt = new Date();
      
      // TODO: Integrate with vendor API/email system
      
      logger.info('Purchase order submitted to vendor', {
        orderId,
        orderNumber: order.orderNumber,
        vendorId: order.vendorId
      });
      
      return order;
      
    } catch (error) {
      logger.error('Error submitting purchase order', { error, orderId });
      throw error;
    }
  }
  
  /**
   * Record receipt of items
   */
  static async receiveItems(
    orderId: string,
    receivedItems: {
      itemId: string;
      quantityReceived: number;
    }[],
    receivedBy: string
  ): Promise<AutomatedPurchaseOrder> {
    try {
      const order = this.purchaseOrders.find(o => o.id === orderId);
      
      if (!order) {
        throw new Error('Purchase order not found');
      }
      
      // Check if all items received
      let allReceived = true;
      
      for (const orderItem of order.items) {
        const received = receivedItems.find(r => r.itemId === orderItem.itemId);
        
        if (!received || received.quantityReceived < orderItem.quantity) {
          allReceived = false;
        }
        
        // Update inventory
        if (received && received.quantityReceived > 0) {
          const inventoryItem = this.inventory.get(orderItem.itemId);
          if (inventoryItem) {
            inventoryItem.currentStock += received.quantityReceived;
            inventoryItem.lastReceivedDate = new Date();
          }
        }
      }
      
      order.status = allReceived ? PurchaseOrderStatus.RECEIVED : PurchaseOrderStatus.PARTIALLY_RECEIVED;
      order.actualDeliveryDate = new Date();
      order.updatedAt = new Date();
      
      logger.info('Purchase order items received', {
        orderId,
        orderNumber: order.orderNumber,
        itemsReceived: receivedItems.length,
        fullyReceived: allReceived
      });
      
      return order;
      
    } catch (error) {
      logger.error('Error receiving items', { error, orderId });
      throw error;
    }
  }
  
  /**
   * Get active recommendations
   */
  static async getRecommendations(priority?: ReorderPriority): Promise<ReorderRecommendation[]> {
    const now = new Date();
    
    let recommendations = this.recommendations.filter(r => r.validUntil > now);
    
    if (priority) {
      recommendations = recommendations.filter(r => r.priority === priority);
    }
    
    return recommendations;
  }
  
  /**
   * Get pending purchase orders
   */
  static async getPendingOrders(): Promise<AutomatedPurchaseOrder[]> {
    return this.purchaseOrders.filter(o => o.status === PurchaseOrderStatus.PENDING);
  }
  
  /**
   * Forecast future stock needs
   */
  static async forecastStockNeeds(itemId: string, months: number = 3): Promise<UsageForecast> {
    try {
      const item = this.inventory.get(itemId);
      
      if (!item) {
        throw new Error('Inventory item not found');
      }
      
      // Simple linear forecast (would use more sophisticated model in production)
      const baseUsage = item.averageMonthlyUsage * months;
      
      // Apply trend adjustment
      let trendAdjustment = 1.0;
      if (item.usageTrend === 'INCREASING') {
        trendAdjustment = 1.1; // 10% increase
      } else if (item.usageTrend === 'DECREASING') {
        trendAdjustment = 0.9; // 10% decrease
      }
      
      // Apply seasonal adjustment (simplified)
      let seasonalAdjustment = 1.0;
      if (item.isSeasonalItem) {
        const currentMonth = new Date().getMonth();
        // Higher usage in cold/flu season (Oct-Mar)
        seasonalAdjustment = (currentMonth >= 9 || currentMonth <= 2) ? 1.3 : 0.8;
      }
      
      const estimatedUsage = Math.round(baseUsage * trendAdjustment * seasonalAdjustment);
      
      // Confidence level based on data availability and stability
      const confidenceLevel = item.usageTrend === 'STABLE' ? 85 : 70;
      
      return {
        itemId,
        forecastDate: new Date(),
        forecastPeriodMonths: months,
        estimatedUsage,
        confidenceLevel,
        seasonalAdjustment
      };
      
    } catch (error) {
      logger.error('Error forecasting stock needs', { error, itemId });
      throw error;
    }
  }
  
  /**
   * Update inventory item stock level
   */
  static async updateStockLevel(
    itemId: string,
    newStock: number,
    updatedBy: string,
    reason?: string
  ): Promise<InventoryItem> {
    try {
      const item = this.inventory.get(itemId);
      
      if (!item) {
        throw new Error('Inventory item not found');
      }
      
      const oldStock = item.currentStock;
      item.currentStock = newStock;
      
      logger.info('Inventory stock level updated', {
        itemId,
        itemName: item.itemName,
        oldStock,
        newStock,
        difference: newStock - oldStock,
        reason
      });
      
      return item;
      
    } catch (error) {
      logger.error('Error updating stock level', { error, itemId });
      throw error;
    }
  }
  
  // === Private helper methods ===
  
  private static isReorderNeeded(item: InventoryItem): boolean {
    // Critical: Out of stock or below minimum
    if (item.currentStock <= item.minimumStock) {
      return true;
    }
    
    // High: At or below reorder point
    if (item.currentStock <= item.reorderPoint) {
      return true;
    }
    
    // Medium: Calculate days until stockout
    if (item.averageMonthlyUsage > 0) {
      const dailyUsage = item.averageMonthlyUsage / 30;
      const daysUntilStockout = item.currentStock / dailyUsage;
      
      // Reorder if less than lead time + safety buffer
      if (daysUntilStockout < (this.DEFAULT_LEAD_TIME_DAYS + 7)) {
        return true;
      }
    }
    
    return false;
  }
  
  private static async generateRecommendation(item: InventoryItem): Promise<ReorderRecommendation> {
    // Determine priority
    let priority: ReorderPriority;
    
    if (item.currentStock <= 0) {
      priority = ReorderPriority.CRITICAL;
    } else if (item.currentStock <= item.minimumStock) {
      priority = ReorderPriority.HIGH;
    } else if (item.currentStock <= item.reorderPoint) {
      priority = ReorderPriority.MEDIUM;
    } else {
      priority = ReorderPriority.LOW;
    }
    
    // Calculate recommended order quantity
    // Economic Order Quantity (EOQ) approach: order up to optimal level
    const recommendedOrderQuantity = Math.max(
      item.optimalStock - item.currentStock,
      item.minimumStock * 2 // Minimum order at least 2x minimum stock
    );
    
    // Calculate days until stockout
    let daysUntilStockout: number | undefined;
    if (item.averageMonthlyUsage > 0) {
      const dailyUsage = item.averageMonthlyUsage / 30;
      daysUntilStockout = Math.floor(item.currentStock / dailyUsage);
    }
    
    // Generate reason
    let reason = '';
    if (item.currentStock <= 0) {
      reason = 'OUT OF STOCK - Immediate reorder required';
    } else if (item.currentStock <= item.minimumStock) {
      reason = `Below minimum stock level (${item.minimumStock} ${item.unit})`;
    } else if (item.currentStock <= item.reorderPoint) {
      reason = `At reorder point (${item.reorderPoint} ${item.unit})`;
    } else if (daysUntilStockout) {
      reason = `Stock estimated to run out in ${daysUntilStockout} days`;
    }
    
    const now = new Date();
    const validUntil = new Date(now.getTime() + this.RECOMMENDATION_VALID_DAYS * 24 * 60 * 60 * 1000);
    
    return {
      itemId: item.itemId,
      itemName: item.itemName,
      priority,
      currentStock: item.currentStock,
      reorderPoint: item.reorderPoint,
      minimumStock: item.minimumStock,
      recommendedOrderQuantity,
      unit: item.unit,
      reason,
      daysUntilStockout,
      averageMonthlyUsage: item.averageMonthlyUsage,
      leadTimeDays: this.DEFAULT_LEAD_TIME_DAYS,
      recommendedVendorId: item.preferredVendorId,
      estimatedCost: item.unitCost,
      estimatedDeliveryDate: this.calculateExpectedDelivery(),
      generatedDate: now,
      validUntil,
      autoGenerated: true
    };
  }
  
  private static generateOrderId(): string {
    return `PO-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
  }
  
  private static generateOrderNumber(): string {
    const date = new Date();
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, '0');
    const sequence = String(this.purchaseOrders.length + 1).padStart(4, '0');
    return `PO-${year}${month}-${sequence}`;
  }
  
  private static calculateShipping(subtotal: number, vendorId: string): number {
    // Free shipping over $100, otherwise $15
    return subtotal >= 100 ? 0 : 15;
  }
  
  private static calculateExpectedDelivery(): Date {
    const today = new Date();
    const deliveryDate = new Date(today);
    deliveryDate.setDate(today.getDate() + this.DEFAULT_LEAD_TIME_DAYS);
    return deliveryDate;
  }
}
